[
  {
    "file": "app/api/test-discord-link/route.ts",
    "original": "import { NextRequest, NextResponse } from 'next/server'\nimport { redis } from '@/lib/redis'\nimport { nanoid } from 'nanoid'\n\nexport async function POST(request: NextRequest) {\n  try {\n    const { sessionId, twitterHandle } = await request.json()\n    \n    if (!sessionId || !twitterHandle) {\n      return NextResponse.json(\n        { error: 'Missing sessionId or twitterHandle' },\n        { status: 400 }\n      )\n    }\n    \n    // Get the Discord verification session\n    const sessionKey = `discord:verify:${sessionId}`\n    const sessionData = await redis.get(sessionKey)\n    \n    if (!sessionData) {\n      return NextResponse.json(\n        { error: 'Verification session expired or not found' },\n        { status: 404 }\n      )\n    }\n    \n    const parsedData = typeof sessionData === 'string' ? JSON.parse(sessionData) : sessionData\n    const { discordId, discordUsername, discordTag } = parsedData\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    \n    // Check if user profile exists\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    let userId: string\n    let isNewUser = false\n    \n    if (!userIds || userIds.length === 0) {\n      // Create new profile\n      userId = `user:${nanoid()}`\n      isNewUser = true\n      \n      const newProfile = {\n        id: userId,\n        twitterHandle: `@${normalizedHandle}`,\n        name: normalizedHandle,\n        profileImageUrl: '',\n        approvalStatus: 'pending',\n        role: 'user',\n        tier: 'micro',\n        isKOL: false,\n        discordId: discordId,\n        discordUsername: discordUsername,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        socialAccounts: {\n          twitter: {\n            handle: normalizedHandle,\n            connected: true\n          },\n          discord: {\n            id: discordId,\n            username: discordUsername,\n            tag: discordTag,\n            connected: true\n          }\n        }\n      }\n      \n      // Save to Redis\n      await redis.json.set(userId, '$', newProfile)\n      \n      // Create username index\n      await redis.sadd(`idx:username:${normalizedHandle}`, userId)\n      \n      // Add to pending users set\n      await redis.sadd('users:pending', userId)\n    } else {\n      // Update existing profile\n      userId = userIds[0]\n      \n      // Get the existing profile first\n      const existingProfile = await redis.json.get(userId) as any\n      \n      if (!existingProfile) {\n        // Profile key exists in index but actual profile is missing\n        // Remove from index and treat as new user\n        await redis.srem(`idx:username:${normalizedHandle}`, userId)\n        \n        // Create new profile\n        userId = `user:${nanoid()}`\n        isNewUser = true\n        \n        const newProfile = {\n          id: userId,\n          twitterHandle: `@${normalizedHandle}`,\n          name: normalizedHandle,\n          profileImageUrl: '',\n          approvalStatus: 'pending',\n          role: 'user',\n          tier: 'micro',\n          isKOL: false,\n          discordId: discordId,\n          discordUsername: discordUsername,\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          socialAccounts: {\n            twitter: {\n              handle: normalizedHandle,\n              connected: true\n            },\n            discord: {\n              id: discordId,\n              username: discordUsername,\n              tag: discordTag,\n              connected: true\n            }\n          }\n        }\n        \n        // Save to Redis\n        await redis.json.set(userId, '$', newProfile)\n        \n        // Create username index\n        await redis.sadd(`idx:username:${normalizedHandle}`, userId)\n        \n        // Add to pending users set\n        await redis.sadd('users:pending', userId)\n      } else {\n        // Update the profile with Discord info\n        const updatedProfile = {\n          ...existingProfile,\n          discordId: discordId,\n          discordUsername: discordUsername,\n          updatedAt: new Date().toISOString(),\n          socialAccounts: {\n            ...(existingProfile.socialAccounts || {}),\n            discord: {\n              id: discordId,\n              username: discordUsername,\n              tag: discordTag,\n              connected: true\n            }\n          }\n        }\n        \n        // Save the entire updated profile\n        await redis.json.set(userId, '$', updatedProfile)\n      }\n    }\n    \n    // Get the profile data\n    const profile = await redis.json.get(userId) as any\n    \n    // Create engagement connection\n    const connection = {\n      discordId: discordId,\n      twitterHandle: normalizedHandle,\n      tier: profile?.tier || 'micro',\n      connectedAt: new Date().toISOString(),\n      totalPoints: 0,\n      role: profile?.role || 'user'\n    }\n    \n    await redis.json.set(`engagement:connection:${discordId}`, '$', connection)\n    await redis.set(`engagement:twitter:${normalizedHandle}`, discordId)\n    \n    // Clean up verification session\n    await redis.del(sessionKey)\n    \n    return NextResponse.json({\n      success: true,\n      message: isNewUser ? 'Account created and linked successfully' : 'Accounts linked successfully',\n      profile: {\n        twitterHandle: `@${normalizedHandle}`,\n        discordUsername: discordUsername,\n        approvalStatus: profile?.approvalStatus || 'pending',\n        isNewUser\n      }\n    })\n    \n  } catch (error) {\n    console.error('Error in test Discord link:', error)\n    return NextResponse.json(\n      { error: 'Failed to link accounts', details: error instanceof Error ? error.message : 'Unknown error' },\n      { status: 500 }\n    )\n  }\n} ",
    "fixed": "import { NextRequest, NextResponse } from 'next/server'\nimport { redis } from '@/lib/redis'\nimport { nanoid } from 'nanoid'\n\nexport async function POST(request: NextRequest) {\n  try {\n    const { sessionId, twitterHandle } = await request.json()\n    \n    if (!sessionId || !twitterHandle) {\n      return NextResponse.json(\n        { error: 'Missing sessionId or twitterHandle' },\n        { status: 400 }\n      )\n    }\n    \n    // Get the Discord verification session\n    const sessionKey = `discord:verify:${sessionId}`\n    const sessionData = await redis.get(sessionKey)\n    \n    if (!sessionData) {\n      return NextResponse.json(\n        { error: 'Verification session expired or not found' },\n        { status: 404 }\n      )\n    }\n    \n    const parsedData = typeof sessionData === 'string' ? JSON.parse(sessionData) : sessionData\n    const { discordId, discordUsername, discordTag } = parsedData\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    \n    // Check if user profile exists\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    let userId: string\n    let isNewUser = false\n    \n    if (!userIds || userIds.length === 0) {\n      // Create new profile\n      userId = `user_${normalizedHandle}`\n      isNewUser = true\n      \n      const newProfile = {\n        id: userId,\n        twitterHandle: `@${normalizedHandle}`,\n        name: normalizedHandle,\n        profileImageUrl: '',\n        approvalStatus: 'pending',\n        role: 'user',\n        tier: 'micro',\n        isKOL: false,\n        discordId: discordId,\n        discordUsername: discordUsername,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        socialAccounts: {\n          twitter: {\n            handle: normalizedHandle,\n            connected: true\n          },\n          discord: {\n            id: discordId,\n            username: discordUsername,\n            tag: discordTag,\n            connected: true\n          }\n        }\n      }\n      \n      // Save to Redis\n      await redis.json.set(userId, '$', newProfile)\n      \n      // Create username index\n      await redis.sadd(`idx:username:${normalizedHandle}`, userId)\n      \n      // Add to pending users set\n      await redis.sadd('users:pending', userId)\n    } else {\n      // Update existing profile\n      userId = userIds[0]\n      \n      // Get the existing profile first\n      const existingProfile = await redis.json.get(userId) as any\n      \n      if (!existingProfile) {\n        // Profile key exists in index but actual profile is missing\n        // Remove from index and treat as new user\n        await redis.srem(`idx:username:${normalizedHandle}`, userId)\n        \n        // Create new profile\n        userId = `user_${normalizedHandle}`\n        isNewUser = true\n        \n        const newProfile = {\n          id: userId,\n          twitterHandle: `@${normalizedHandle}`,\n          name: normalizedHandle,\n          profileImageUrl: '',\n          approvalStatus: 'pending',\n          role: 'user',\n          tier: 'micro',\n          isKOL: false,\n          discordId: discordId,\n          discordUsername: discordUsername,\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          socialAccounts: {\n            twitter: {\n              handle: normalizedHandle,\n              connected: true\n            },\n            discord: {\n              id: discordId,\n              username: discordUsername,\n              tag: discordTag,\n              connected: true\n            }\n          }\n        }\n        \n        // Save to Redis\n        await redis.json.set(userId, '$', newProfile)\n        \n        // Create username index\n        await redis.sadd(`idx:username:${normalizedHandle}`, userId)\n        \n        // Add to pending users set\n        await redis.sadd('users:pending', userId)\n      } else {\n        // Update the profile with Discord info\n        const updatedProfile = {\n          ...existingProfile,\n          discordId: discordId,\n          discordUsername: discordUsername,\n          updatedAt: new Date().toISOString(),\n          socialAccounts: {\n            ...(existingProfile.socialAccounts || {}),\n            discord: {\n              id: discordId,\n              username: discordUsername,\n              tag: discordTag,\n              connected: true\n            }\n          }\n        }\n        \n        // Save the entire updated profile\n        await redis.json.set(userId, '$', updatedProfile)\n      }\n    }\n    \n    // Get the profile data\n    const profile = await redis.json.get(userId) as any\n    \n    // Create engagement connection\n    const connection = {\n      discordId: discordId,\n      twitterHandle: normalizedHandle,\n      tier: profile?.tier || 'micro',\n      connectedAt: new Date().toISOString(),\n      totalPoints: 0,\n      role: profile?.role || 'user'\n    }\n    \n    await redis.json.set(`engagement:connection:${discordId}`, '$', connection)\n    await redis.set(`engagement:twitter:${normalizedHandle}`, discordId)\n    \n    // Clean up verification session\n    await redis.del(sessionKey)\n    \n    return NextResponse.json({\n      success: true,\n      message: isNewUser ? 'Account created and linked successfully' : 'Accounts linked successfully',\n      profile: {\n        twitterHandle: `@${normalizedHandle}`,\n        discordUsername: discordUsername,\n        approvalStatus: profile?.approvalStatus || 'pending',\n        isNewUser\n      }\n    })\n    \n  } catch (error) {\n    console.error('Error in test Discord link:', error)\n    return NextResponse.json(\n      { error: 'Failed to link accounts', details: error instanceof Error ? error.message : 'Unknown error' },\n      { status: 500 }\n    )\n  }\n} "
  },
  {
    "file": "app/api/auth/discord-link/route.ts",
    "original": "import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth-options'\nimport { redis } from '@/lib/redis'\nimport { nanoid } from 'nanoid'\n\nexport async function POST(request: NextRequest) {\n  try {\n    // Get the current session\n    const session = await getServerSession(authOptions)\n    console.log('Discord link API - Session:', JSON.stringify(session, null, 2))\n    \n    const twitterHandleFromSession = session?.twitterHandle || (session?.user as any)?.twitterHandle\n    \n    if (!session?.user || !twitterHandleFromSession) {\n      console.log('Discord link API - No session or Twitter handle')\n      return NextResponse.json(\n        { error: 'Not authenticated or missing Twitter handle' },\n        { status: 401 }\n      )\n    }\n    \n    const { sessionId } = await request.json()\n    console.log('Discord link API - Session ID:', sessionId)\n    \n    if (!sessionId) {\n      return NextResponse.json(\n        { error: 'No session ID provided' },\n        { status: 400 }\n      )\n    }\n    \n    // Get the Discord verification session\n    const sessionKey = `discord:verify:${sessionId}`\n    const sessionData = await redis.get(sessionKey)\n    \n    if (!sessionData) {\n      return NextResponse.json(\n        { error: 'Verification session expired or not found' },\n        { status: 404 }\n      )\n    }\n    \n    const parsedData = typeof sessionData === 'string' ? JSON.parse(sessionData) : sessionData\n    const { discordId, discordUsername, discordTag } = parsedData\n    const twitterHandle = twitterHandleFromSession.toLowerCase().replace('@', '')\n    \n    // Check if user profile exists\n    const userIds = await redis.smembers(`idx:username:${twitterHandle}`)\n    let userId: string\n    let isNewUser = false\n    \n    if (!userIds || userIds.length === 0) {\n      // Create new profile\n      userId = `user:${nanoid()}`\n      isNewUser = true\n      \n      const newProfile = {\n        id: userId,\n        twitterHandle: `@${twitterHandle}`,\n        name: session.user.name,\n        profileImageUrl: session.user.image || '',\n        approvalStatus: 'pending',\n        role: 'user',\n        tier: 'micro',\n        isKOL: false,\n        discordId: discordId,\n        discordUsername: discordUsername,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        socialAccounts: {\n          twitter: {\n            handle: twitterHandle,\n            connected: true\n          },\n          discord: {\n            id: discordId,\n            username: discordUsername,\n            tag: discordTag,\n            connected: true\n          }\n        }\n      }\n      \n      // Save to Redis\n      await redis.json.set(userId, '$', newProfile)\n      \n      // Create username index\n      await redis.sadd(`idx:username:${twitterHandle}`, userId)\n      \n      // Add to pending users set\n      await redis.sadd('users:pending', userId)\n    } else {\n      // Update existing profile\n      userId = userIds[0]\n      \n      // Get the existing profile first\n      const existingProfile = await redis.json.get(userId) as any\n      \n      // If profile doesn't exist in Redis, create a new one\n      if (!existingProfile) {\n        const newProfile = {\n          id: userId,\n          twitterHandle: `@${twitterHandle}`,\n          name: session.user.name,\n          profileImageUrl: session.user.image || '',\n          approvalStatus: 'approved', // Existing user, likely already approved\n          role: session.role || 'user',\n          tier: 'micro',\n          isKOL: false,\n          discordId: discordId,\n          discordUsername: discordUsername,\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          socialAccounts: {\n            twitter: {\n              handle: twitterHandle,\n              connected: true\n            },\n            discord: {\n              id: discordId,\n              username: discordUsername,\n              tag: discordTag,\n              connected: true\n            }\n          }\n        }\n        \n        await redis.json.set(userId, '$', newProfile)\n      } else {\n        // Update the profile with Discord info\n        const updatedProfile = {\n          ...existingProfile,\n          discordId: discordId,\n          discordUsername: discordUsername,\n          updatedAt: new Date().toISOString(),\n          socialAccounts: {\n            ...(existingProfile.socialAccounts || {}),\n            discord: {\n              id: discordId,\n              username: discordUsername,\n              tag: discordTag,\n              connected: true\n            }\n          }\n        }\n        \n        await redis.json.set(userId, '$', updatedProfile)\n      }\n    }\n    \n    // Get the profile data\n    const profile = await redis.json.get(userId) as any\n    \n    // Create engagement connection\n    const connection = {\n      discordId: discordId,\n      twitterHandle: twitterHandle,\n      tier: profile?.tier || 'micro',\n      connectedAt: new Date(),\n      totalPoints: 0,\n      role: profile?.role || 'user'\n    }\n    \n    await redis.json.set(`engagement:connection:${discordId}`, '$', connection)\n    await redis.set(`engagement:twitter:${twitterHandle}`, discordId)\n    \n    // Clean up verification session\n    await redis.del(sessionKey)\n    \n    return NextResponse.json({\n      success: true,\n      message: isNewUser ? 'Account created and linked successfully' : 'Accounts linked successfully',\n      profile: {\n        twitterHandle: `@${twitterHandle}`,\n        discordUsername: discordUsername,\n        approvalStatus: profile?.approvalStatus || 'pending',\n        isNewUser\n      }\n    })\n    \n  } catch (error) {\n    console.error('Error linking Discord account:', error)\n    console.error('Stack trace:', error instanceof Error ? error.stack : 'No stack trace')\n    return NextResponse.json(\n      { error: 'Failed to link accounts', details: error instanceof Error ? error.message : 'Unknown error' },\n      { status: 500 }\n    )\n  }\n} ",
    "fixed": "import { NextRequest, NextResponse } from 'next/server'\nimport { getServerSession } from 'next-auth'\nimport { authOptions } from '@/lib/auth-options'\nimport { redis } from '@/lib/redis'\nimport { nanoid } from 'nanoid'\n\nexport async function POST(request: NextRequest) {\n  try {\n    // Get the current session\n    const session = await getServerSession(authOptions)\n    console.log('Discord link API - Session:', JSON.stringify(session, null, 2))\n    \n    const twitterHandleFromSession = session?.twitterHandle || (session?.user as any)?.twitterHandle\n    \n    if (!session?.user || !twitterHandleFromSession) {\n      console.log('Discord link API - No session or Twitter handle')\n      return NextResponse.json(\n        { error: 'Not authenticated or missing Twitter handle' },\n        { status: 401 }\n      )\n    }\n    \n    const { sessionId } = await request.json()\n    console.log('Discord link API - Session ID:', sessionId)\n    \n    if (!sessionId) {\n      return NextResponse.json(\n        { error: 'No session ID provided' },\n        { status: 400 }\n      )\n    }\n    \n    // Get the Discord verification session\n    const sessionKey = `discord:verify:${sessionId}`\n    const sessionData = await redis.get(sessionKey)\n    \n    if (!sessionData) {\n      return NextResponse.json(\n        { error: 'Verification session expired or not found' },\n        { status: 404 }\n      )\n    }\n    \n    const parsedData = typeof sessionData === 'string' ? JSON.parse(sessionData) : sessionData\n    const { discordId, discordUsername, discordTag } = parsedData\n    const twitterHandle = twitterHandleFromSession.toLowerCase().replace('@', '')\n    \n    // Check if user profile exists\n    const userIds = await redis.smembers(`idx:username:${twitterHandle}`)\n    let userId: string\n    let isNewUser = false\n    \n    if (!userIds || userIds.length === 0) {\n      // Create new profile\n      userId = `user_${normalizedHandle}`\n      isNewUser = true\n      \n      const newProfile = {\n        id: userId,\n        twitterHandle: `@${twitterHandle}`,\n        name: session.user.name,\n        profileImageUrl: session.user.image || '',\n        approvalStatus: 'pending',\n        role: 'user',\n        tier: 'micro',\n        isKOL: false,\n        discordId: discordId,\n        discordUsername: discordUsername,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        socialAccounts: {\n          twitter: {\n            handle: twitterHandle,\n            connected: true\n          },\n          discord: {\n            id: discordId,\n            username: discordUsername,\n            tag: discordTag,\n            connected: true\n          }\n        }\n      }\n      \n      // Save to Redis\n      await redis.json.set(userId, '$', newProfile)\n      \n      // Create username index\n      await redis.sadd(`idx:username:${twitterHandle}`, userId)\n      \n      // Add to pending users set\n      await redis.sadd('users:pending', userId)\n    } else {\n      // Update existing profile\n      userId = userIds[0]\n      \n      // Get the existing profile first\n      const existingProfile = await redis.json.get(userId) as any\n      \n      // If profile doesn't exist in Redis, create a new one\n      if (!existingProfile) {\n        const newProfile = {\n          id: userId,\n          twitterHandle: `@${twitterHandle}`,\n          name: session.user.name,\n          profileImageUrl: session.user.image || '',\n          approvalStatus: 'approved', // Existing user, likely already approved\n          role: session.role || 'user',\n          tier: 'micro',\n          isKOL: false,\n          discordId: discordId,\n          discordUsername: discordUsername,\n          createdAt: new Date().toISOString(),\n          updatedAt: new Date().toISOString(),\n          socialAccounts: {\n            twitter: {\n              handle: twitterHandle,\n              connected: true\n            },\n            discord: {\n              id: discordId,\n              username: discordUsername,\n              tag: discordTag,\n              connected: true\n            }\n          }\n        }\n        \n        await redis.json.set(userId, '$', newProfile)\n      } else {\n        // Update the profile with Discord info\n        const updatedProfile = {\n          ...existingProfile,\n          discordId: discordId,\n          discordUsername: discordUsername,\n          updatedAt: new Date().toISOString(),\n          socialAccounts: {\n            ...(existingProfile.socialAccounts || {}),\n            discord: {\n              id: discordId,\n              username: discordUsername,\n              tag: discordTag,\n              connected: true\n            }\n          }\n        }\n        \n        await redis.json.set(userId, '$', updatedProfile)\n      }\n    }\n    \n    // Get the profile data\n    const profile = await redis.json.get(userId) as any\n    \n    // Create engagement connection\n    const connection = {\n      discordId: discordId,\n      twitterHandle: twitterHandle,\n      tier: profile?.tier || 'micro',\n      connectedAt: new Date(),\n      totalPoints: 0,\n      role: profile?.role || 'user'\n    }\n    \n    await redis.json.set(`engagement:connection:${discordId}`, '$', connection)\n    await redis.set(`engagement:twitter:${twitterHandle}`, discordId)\n    \n    // Clean up verification session\n    await redis.del(sessionKey)\n    \n    return NextResponse.json({\n      success: true,\n      message: isNewUser ? 'Account created and linked successfully' : 'Accounts linked successfully',\n      profile: {\n        twitterHandle: `@${twitterHandle}`,\n        discordUsername: discordUsername,\n        approvalStatus: profile?.approvalStatus || 'pending',\n        isNewUser\n      }\n    })\n    \n  } catch (error) {\n    console.error('Error linking Discord account:', error)\n    console.error('Stack trace:', error instanceof Error ? error.stack : 'No stack trace')\n    return NextResponse.json(\n      { error: 'Failed to link accounts', details: error instanceof Error ? error.message : 'Unknown error' },\n      { status: 500 }\n    )\n  }\n} "
  },
  {
    "file": "discord-bots/engagement-bot.js",
    "original": "const { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle, REST, Routes } = require('discord.js')\nconst { config } = require('dotenv')\nconst { Redis } = require('@upstash/redis')\nconst { GoogleGenerativeAI } = require('@google/generative-ai')\nconst path = require('path')\nconst { nanoid } = require('nanoid')\n\n// Load environment variables from parent directory\nconst envPath = path.join(__dirname, '..', '.env.local')\nconsole.log('🔍 Loading environment from:', envPath)\nconfig({ path: envPath })\n\n// Check required environment variables\nconst requiredVars = ['UPSTASH_REDIS_REST_URL', 'UPSTASH_REDIS_REST_TOKEN', 'DISCORD_BOT_TOKEN']\nconst optionalVars = ['GEMINI_API_KEY', 'GOOGLE_AI_API_KEY'] // Try both for compatibility\nconst missingVars = requiredVars.filter(v => !process.env[v])\n\n// Check for Gemini/Google AI key\nconst hasAiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n\nif (missingVars.length > 0) {\n  console.error('❌ Missing required environment variables:', missingVars.join(', '))\n  console.error('🔍 Please check your .env.local file contains:')\n  missingVars.forEach(v => console.error(`   ${v}=your_value_here`))\n  process.exit(1)\n}\n\nif (!hasAiKey) {\n  console.warn('⚠️  No AI API key found (GEMINI_API_KEY or GOOGLE_AI_API_KEY)')\n  console.warn('   Sentiment analysis will be disabled')\n}\n\n// Initialize Redis\nconst redis = new Redis({\n  url: process.env.UPSTASH_REDIS_REST_URL,\n  token: process.env.UPSTASH_REDIS_REST_TOKEN\n})\n\n// Initialize Gemini for sentiment analysis (if available)\nlet genAI = null\nlet model = null\n\nif (hasAiKey) {\n  const apiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n  genAI = new GoogleGenerativeAI(apiKey)\n  model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' })\n  console.log('✅ AI model initialized for sentiment analysis')\n}\n\n// Initialize Discord client\nconst client = new Client({\n  intents: [\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildMessages,\n    GatewayIntentBits.MessageContent,\n    GatewayIntentBits.GuildMessageReactions,\n    GatewayIntentBits.GuildMembers\n  ]\n})\n\n// Tweet URL regex\nconst TWEET_REGEX = /https?:\\/\\/(twitter\\.com|x\\.com)\\/[\\w]+\\/status\\/(\\d+)/i\n\n// Bot configuration\nconst BOT_CHANNEL_NAME = 'engagement-tracker'\nconst ADMIN_ROLE_NAME = 'admin'\nconst KOL_ROLE_NAME = 'kol'\n\n// Role hierarchy (higher number = higher priority)\nconst ROLE_HIERARCHY = {\n  'admin': 4,\n  'core': 3,\n  'team': 2,\n  'kol': 1,\n  'user': 0\n}\n\n// Helper function to extract tweet ID from URL\nfunction extractTweetId(url) {\n  const match = url.match(TWEET_REGEX)\n  return match ? match[2] : null\n}\n\n// Helper function to extract Twitter handle from URL\nfunction extractTwitterHandle(url) {\n  const match = url.match(/https?:\\/\\/(twitter\\.com|x\\.com)\\/([\\w]+)\\/status/)\n  return match ? match[2] : null\n}\n\n// Create a new user profile (pending approval)\nasync function createUserProfile(twitterHandle, discordId) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userId = `user:${nanoid()}`\n    \n    const newUser = {\n      id: userId,\n      twitterHandle: `@${normalizedHandle}`,\n      name: normalizedHandle, // Use handle as name initially\n      approvalStatus: 'pending', // Set to pending, requiring admin approval\n      role: 'user', // Default to user role\n      tier: 'micro', // Default tier\n      discordId: discordId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      socialAccounts: {\n        twitter: {\n          handle: normalizedHandle,\n          connected: true\n        }\n      }\n    }\n    \n    // Save to Redis\n    await redis.json.set(userId, '$', newUser)\n    \n    // Create username index\n    await redis.sadd(`idx:username:${normalizedHandle}`, userId)\n    \n    // Add to pending users set (not approved)\n    await redis.sadd('users:pending', userId)\n    \n    console.log(`✅ Created new user profile (pending) for @${normalizedHandle}`)\n    return newUser\n  } catch (error) {\n    console.error('Error creating user profile:', error)\n    throw error\n  }\n}\n\n\n// Check if user is approved in the database\nasync function isUserApproved(twitterHandle) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    \n    // Check if user exists via username index\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    if (!userIds || userIds.length === 0) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Get user data\n    const userData = await redis.json.get(`user:${userIds[0]}`)\n    if (!userData) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Check approval status\n    const isApproved = userData.approvalStatus === 'approved'\n    return { approved: isApproved, userData, exists: true }\n  } catch (error) {\n    console.error('Error checking user approval:', error)\n    return { approved: false, userData: null, exists: false }\n  }\n}\n\n// Get user's current role from database\nasync function getUserRole(twitterHandle) {\n  try {\n    const { approved, userData } = await isUserApproved(twitterHandle)\n    if (!approved || !userData) return 'user'\n    \n    return userData.role || 'user'\n  } catch (error) {\n    console.error('Error getting user role:', error)\n    return 'user'\n  }\n}\n\n// Update user's role in database\nasync function updateUserRole(twitterHandle, newRole) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    \n    if (userIds && userIds.length > 0) {\n      await redis.json.set(`user:${userIds[0]}`, '$.role', newRole)\n      return true\n    }\n    return false\n  } catch (error) {\n    console.error('Error updating user role:', error)\n    return false\n  }\n}\n\n// Get tier-based scenarios\nasync function getTierScenarios(tier) {\n  try {\n    const safeTier = tier || 'micro' // Default to micro if tier is null/undefined\n    const scenarios = await redis.json.get(`engagement:scenarios:${safeTier}`)\n    return scenarios || getDefaultScenarios(safeTier)\n  } catch (error) {\n    console.error('Error getting tier scenarios:', error)\n    return getDefaultScenarios(tier || 'micro')\n  }\n}\n\n// Default scenarios by tier\nfunction getDefaultScenarios(tier) {\n  const scenarios = {\n    'micro': {\n      dailyTweetLimit: 5,\n      categories: ['General', 'DeFi', 'NFT'],\n      minFollowers: 100,\n      bonusMultiplier: 1.0\n    },\n    'rising': {\n      dailyTweetLimit: 10,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech'],\n      minFollowers: 500,\n      bonusMultiplier: 1.5\n    },\n    'star': {\n      dailyTweetLimit: 20,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News'],\n      minFollowers: 1000,\n      bonusMultiplier: 2.0\n    },\n    'legend': {\n      dailyTweetLimit: 30,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special'],\n      minFollowers: 5000,\n      bonusMultiplier: 2.5\n    },\n    'hero': {\n      dailyTweetLimit: 50,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special', 'VIP'],\n      minFollowers: 10000,\n      bonusMultiplier: 3.0\n    }\n  }\n  \n  return scenarios[tier] || scenarios['micro']\n}\n\n// Create minimal tweet embed with preview\nfunction createTweetEmbed(tweet, submitterName, includeButtons = true) {\n  // Choose color based on tier\n  const tierColors = {\n    'micro': 0x6B7280,  // Gray\n    'rising': 0x3BA55D, // Green\n    'star': 0x5865F2,   // Blue\n    'legend': 0xEA580C, // Orange\n    'hero': 0x9333EA    // Purple\n  }\n  \n  // Calculate potential points\n  const likePoints = Math.floor(10 * tweet.bonusMultiplier)\n  const retweetPoints = Math.floor(20 * tweet.bonusMultiplier)\n  const replyPoints = Math.floor(30 * tweet.bonusMultiplier)\n  \n  const embed = new EmbedBuilder()\n    .setColor(tierColors[tweet.tier] || 0x1DA1F2)\n    .setAuthor({ \n      name: `@${tweet.authorHandle}`, \n      url: `https://twitter.com/${tweet.authorHandle}`,\n      iconURL: 'https://abs.twimg.com/icons/apple-touch-icon-192x192.png'\n    })\n    .setDescription(\n      `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n      `**💰 Earn ${tweet.bonusMultiplier}x points:**\\n` +\n      `❤️ Like: ${likePoints} pts | 🔁 RT: ${retweetPoints} pts | 💬 Reply: ${replyPoints} pts`\n    )\n    .addFields(\n      { name: 'Tier', value: `⭐ ${tweet.tier}`, inline: true },\n      { name: 'Category', value: `${tweet.category}`, inline: true },\n      { name: 'Submitted', value: `<t:${Math.floor(new Date(tweet.submittedAt).getTime() / 1000)}:R>`, inline: true }\n    )\n    .setFooter({ text: `Submitted by ${submitterName}` })\n  \n  if (includeButtons) {\n    // Create clickable button for the tweet\n    const row = new ActionRowBuilder()\n      .addComponents(\n        new ButtonBuilder()\n          .setLabel('View & Engage')\n          .setStyle(ButtonStyle.Link)\n          .setURL(tweet.url)\n          .setEmoji('🐦')\n      )\n    \n    return { embeds: [embed], components: [row] }\n  }\n  \n  return { embeds: [embed] }\n}\n\n// Handle slash commands\nclient.on('ready', async () => {\n  console.log(`✅ Engagement bot logged in as ${client.user.tag}`)\n  \n  // Start checking for channel info requests\n  setInterval(async () => {\n    try {\n      // Look for any channel info requests\n      const keys = await redis.keys('discord:channel-info-request:*')\n      \n      for (const key of keys) {\n        const request = await redis.get(key)\n        if (!request) continue\n        \n        let channelId, serverId, projectId\n        try {\n          // Upstash Redis returns the parsed object directly\n          const parsed = typeof request === 'string' ? JSON.parse(request) : request\n          channelId = parsed.channelId\n          serverId = parsed.serverId\n          projectId = parsed.projectId\n        } catch (parseError) {\n          console.error(`Error parsing channel info request from ${key}:`, parseError)\n          console.error('Raw request data:', request)\n          await redis.del(key)\n          continue\n        }\n        \n        // Try to fetch the channel\n        try {\n          console.log(`[DEBUG] Looking for guild ${serverId}`)\n          console.log(`[DEBUG] Available guilds: ${client.guilds.cache.map(g => `${g.name} (${g.id})`).join(', ')}`)\n          \n          const guild = client.guilds.cache.get(serverId)\n          if (!guild) {\n            console.log(`Guild ${serverId} not found in cache`)\n            continue\n          }\n          \n          const channel = guild.channels.cache.get(channelId)\n          if (channel) {\n            // Store the response\n            const responseKey = `discord:channel-info-response:${channelId}`\n            await redis.set(responseKey, JSON.stringify({\n              id: channelId,\n              name: channel.name,\n              type: channel.type === 0 ? 'text' : 'voice'\n            }), {\n              ex: 60 // expire in 60 seconds\n            })\n            \n            // Also store permanent channel metadata\n            const channelMetadataKey = `channel:discord:${channelId}`\n            await redis.json.set(channelMetadataKey, '$', {\n              id: channelId,\n              name: channel.name,\n              type: channel.type === 0 ? 'text' : 'voice',\n              projectId: projectId || null,\n              updatedAt: new Date().toISOString()\n            })\n            \n            console.log(`✅ Fetched channel info: #${channel.name} (${channelId})`)\n          } else {\n            console.log(`Channel ${channelId} not found in guild ${serverId}`)\n          }\n        } catch (error) {\n          console.error(`Error fetching channel ${channelId}:`, error)\n        }\n        \n        // Delete the request\n        await redis.del(key)\n      }\n    } catch (error) {\n      console.error('Error processing channel info requests:', error)\n    }\n  }, 2000) // Check every 2 seconds\n  \n  // Register slash commands\n  const commands = [\n    {\n      name: 'ping',\n      description: 'Test if bot is responding'\n    },\n    {\n      name: 'connect',\n      description: 'Connect your Twitter account (must be approved)'\n    },\n    {\n      name: 'submit',\n      description: 'Submit a tweet for engagement tracking',\n      options: [{\n        name: 'url',\n        type: 3, // STRING\n        description: 'The tweet URL',\n        required: true\n      }, {\n        name: 'category',\n        type: 3,\n        description: 'Tweet category (optional)',\n        required: false\n      }]\n    },\n    {\n      name: 'stats',\n      description: 'View your engagement stats'\n    },\n    {\n      name: 'leaderboard',\n      description: 'View the engagement leaderboard'\n    },\n    {\n      name: 'recent',\n      description: 'View recently submitted tweets'\n    },\n    {\n      name: 'tier',\n      description: 'Admin: Set user tier',\n      options: [{\n        name: 'user',\n        type: 6, // USER\n        description: 'The user to update',\n        required: true\n      }, {\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }]\n    },\n    {\n      name: 'scenarios',\n      description: 'Admin: Configure tier scenarios',\n      options: [{\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }, {\n        name: 'daily_limit',\n        type: 4,\n        description: 'Daily tweet limit',\n        required: false\n      }, {\n        name: 'min_followers',\n        type: 4,\n        description: 'Minimum followers required',\n        required: false\n      }, {\n        name: 'bonus_multiplier',\n        type: 10, // DOUBLE\n        description: 'Points bonus multiplier',\n        required: false\n      }]\n    }\n  ]\n  \n  // Import REST and Routes for proper command registration\n  const { REST } = require('@discordjs/rest')\n  const { Routes } = require('discord-api-types/v9')\n  \n  const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_ENGAGEMENT_BOT_TOKEN || process.env.DISCORD_BOT_TOKEN)\n  \n  try {\n    console.log('🔄 Refreshing application (/) commands...')\n    \n    // Clear existing commands first to remove duplicates\n    await rest.put(\n      Routes.applicationCommands(client.user.id),\n      { body: [] }\n    )\n    \n    // Register commands to each guild for instant update\n    for (const guild of client.guilds.cache.values()) {\n      try {\n        await rest.put(\n          Routes.applicationGuildCommands(client.user.id, guild.id),\n          { body: commands }\n        )\n        console.log(`✅ Registered commands to guild: ${guild.name}`)\n      } catch (error) {\n        console.error(`❌ Failed to register to ${guild.name}:`, error.message)\n      }\n    }\n    \n    console.log('✅ Slash commands registered')\n  } catch (error) {\n    console.error('Error registering commands:', error)\n  }\n})\n\n// Handle interactions\nclient.on('interactionCreate', async (interaction) => {\n  console.log(`📥 Received interaction: ${interaction.type} - Command: ${interaction.commandName || 'N/A'} - User: ${interaction.user?.tag || 'Unknown'}`)\n  \n  try {\n    // Handle slash commands\n    if (interaction.isCommand()) {\n      const { commandName } = interaction\n      console.log(`🎯 Processing command: ${commandName}`)\n    \n    \n    if (commandName === 'connect') {\n      await interaction.deferReply({ flags: 64 })\n      \n      try {\n        // Generate a unique verification session\n        const sessionId = `verify-${interaction.user.id}-${Date.now()}`\n        const sessionKey = `discord:verify:${sessionId}`\n        \n        // Store session data\n        await redis.set(sessionKey, JSON.stringify({\n          discordId: interaction.user.id,\n          discordUsername: interaction.user.username,\n          discordTag: interaction.user.tag,\n          timestamp: Date.now()\n        }), { EX: 600 }) // Expires in 10 minutes\n        \n        // Create verification URL that will use the website's Twitter OAuth\n        const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3002'\n        const verificationUrl = `${baseUrl}/auth/discord-link?session=${sessionId}`\n        \n        const embed = new EmbedBuilder()\n          .setColor(0x1DA1F2) // Twitter blue\n          .setTitle('🔐 Secure Twitter Connection')\n          .setDescription(\n            'To securely connect your Twitter account, you need to verify ownership through Twitter OAuth.\\n\\n' +\n            '**Click the button below to:**\\n' +\n            '1. Sign in with Twitter (OAuth)\\n' +\n            '2. Authorize the connection\\n' +\n            '3. Your accounts will be linked automatically'\n          )\n          .addFields(\n            { name: '⏱️ Expires In', value: '10 minutes', inline: true },\n            { name: '🔒 Security', value: 'OAuth 2.0', inline: true }\n          )\n          .setFooter({ text: 'Only you can complete this verification' })\n        \n        const row = new ActionRowBuilder()\n          .addComponents(\n            new ButtonBuilder()\n              .setLabel('Verify Twitter Account')\n              .setStyle(ButtonStyle.Link)\n              .setURL(verificationUrl)\n              .setEmoji('🐦')\n          )\n        \n        await interaction.editReply({\n          embeds: [embed],\n          components: [row],\n          flags: 64\n        })\n      } catch (error) {\n        console.error('Error in connect command:', error)\n        await interaction.editReply('❌ An error occurred. Please try again.')\n      }\n    }\n    \n    else if (commandName === 'submit') {\n      await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n      \n      const url = interaction.options.getString('url')\n      const category = interaction.options.getString('category')\n      \n      // Validate URL\n      const tweetId = extractTweetId(url)\n      if (!tweetId) {\n        await interaction.editReply('❌ Invalid tweet URL. Please provide a valid Twitter/X URL.')\n        return\n      }\n      \n      // Check if user is connected\n      const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n      if (!connection) {\n        await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n        return\n      }\n      \n      // Check if user is still approved\n      const { approved } = await isUserApproved(connection.twitterHandle)\n      if (!approved) {\n        await interaction.editReply('❌ Your Twitter account is no longer approved. Please contact an admin.')\n        return\n      }\n      \n      // Check tier scenarios\n      const scenarios = await getTierScenarios(connection.tier)\n      \n      // Check daily limit\n      const today = new Date().toISOString().split('T')[0]\n      const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n      \n      if (dailySubmissions >= scenarios.dailyTweetLimit) {\n        await interaction.editReply(`❌ You've reached your daily limit of ${scenarios.dailyTweetLimit} tweets for Tier ${connection.tier}.`)\n        return\n      }\n      \n      // Check for duplicate\n      const isDuplicate = await redis.exists(`engagement:tweetid:${tweetId}`)\n      if (isDuplicate) {\n        await interaction.editReply('❌ This tweet has already been submitted.')\n        return\n      }\n      \n      // Extract author handle\n      const authorHandle = extractTwitterHandle(url)\n      \n      // Check if submitter is author or admin\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin && connection.twitterHandle !== authorHandle) {\n        await interaction.editReply('❌ You can only submit your own tweets. Admins can submit any tweet.')\n        return\n      }\n      \n      // Validate category\n      let finalCategory = category\n      if (category && !scenarios.categories.includes(category)) {\n        await interaction.editReply(`❌ Invalid category. Available categories for Tier ${connection.tier}: ${scenarios.categories.join(', ')}`)\n        return\n      }\n      \n      if (!finalCategory) {\n        finalCategory = 'General'\n      }\n      \n      // Submit tweet\n      try {\n        const { nanoid } = await import('nanoid')\n        // Try to fetch tweet content from Twitter API\n        let tweetContent = null\n        try {\n          const response = await fetch(`https://api.twitter.com/2/tweets/${tweetId}?tweet.fields=text`, {\n            headers: {\n              'Authorization': `Bearer ${process.env.TWITTER_BEARER_TOKEN}`\n            }\n          })\n          \n          if (response.ok) {\n            const tweetData = await response.json()\n            tweetContent = tweetData.data?.text || null\n            console.log('📝 Fetched tweet content:', tweetContent ? 'Success' : 'No content')\n          }\n        } catch (error) {\n          console.log('⚠️ Could not fetch tweet content:', error.message)\n        }\n\n        const tweet = {\n          id: nanoid(),\n          tweetId,\n          submitterDiscordId: interaction.user.id,\n          submittedAt: new Date(),\n          category: finalCategory,\n          url,\n          authorHandle,\n          content: tweetContent,\n          tier: connection.tier,\n          bonusMultiplier: scenarios.bonusMultiplier\n        }\n        \n        await redis.json.set(`engagement:tweet:${tweet.id}`, '$', tweet)\n        // Store in sorted set for admin panel compatibility\n        await redis.zadd('engagement:tweets:recent', { score: Date.now(), member: tweet.id })\n        await redis.set(`engagement:tweetid:${tweet.tweetId}`, tweet.id)\n        \n        // Increment daily counter\n        await redis.incr(`engagement:daily:${interaction.user.id}:${today}`)\n        await redis.expire(`engagement:daily:${interaction.user.id}:${today}`, 86400) // 24 hours\n        \n        // Send to channel\n        const channel = interaction.guild.channels.cache.find(ch => ch.name === BOT_CHANNEL_NAME)\n        if (channel) {\n          // Debug: Check bot permissions in channel\n          const botMember = interaction.guild.members.cache.get(client.user.id)\n          const perms = channel.permissionsFor(botMember)\n          console.log(`Bot permissions in #${BOT_CHANNEL_NAME}:`, {\n            viewChannel: perms.has('ViewChannel'),\n            sendMessages: perms.has('SendMessages'),\n            embedLinks: perms.has('EmbedLinks'),\n            readMessageHistory: perms.has('ReadMessageHistory'),\n            useExternalEmojis: perms.has('UseExternalEmojis')\n          })\n          try {\n            const messageContent = createTweetEmbed(tweet, interaction.user.username)\n            await channel.send(messageContent)\n            console.log(`✅ Posted tweet preview to #${BOT_CHANNEL_NAME}`)\n          } catch (channelError) {\n            console.error('Error posting to channel:', channelError)\n            console.log('Make sure the bot has permission to send messages in #engagement-tracker')\n            console.log('Required permissions: View Channel, Send Messages, Embed Links')\n            \n            // Try sending without buttons as fallback\n            try {\n              console.log('Attempting to send without buttons...')\n              const simpleEmbed = createTweetEmbed(tweet, interaction.user.username, false)\n              await channel.send(simpleEmbed)\n              console.log('✅ Sent simplified preview without buttons')\n            } catch (fallbackError) {\n              console.error('Even simple embed failed:', fallbackError)\n              console.log('Bot may lack basic permissions in the channel')\n              \n              // Last resort - send plain text\n              try {\n                const plainMessage = `**@${tweet.authorHandle}**\\n` +\n                  `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n                  `💰 Earn ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | ${tweet.category}\\n` +\n                  `🔗 ${tweet.url}`\n                await channel.send(plainMessage)\n                console.log('✅ Sent plain text preview')\n              } catch (textError) {\n                console.error('Cannot send any message to channel:', textError)\n              }\n            }\n          }\n        } else {\n          console.log(`Channel \"${BOT_CHANNEL_NAME}\" not found. Please create it for tweet announcements.`)\n        }\n        \n        await interaction.editReply(`✅ Tweet submitted successfully! (${parseInt(dailySubmissions) + 1}/${scenarios.dailyTweetLimit} today)`)\n      } catch (error) {\n        console.error('Error submitting tweet:', error)\n        await interaction.editReply('❌ An error occurred while submitting the tweet. Please try again.')\n      }\n    }\n    \n    else if (commandName === 'stats') {\n      await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n      \n      const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n      if (!connection) {\n        await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n        return\n      }\n      \n      // Get tier scenarios\n      const scenarios = await getTierScenarios(connection.tier)\n      \n      // Get today's submissions\n      const today = new Date().toISOString().split('T')[0]\n      const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n      \n      // Get recent engagements (skip for now since we don't have logs yet)\n      const logs = []\n      \n      const embed = new EmbedBuilder()\n        .setColor(0x00FF00)\n        .setTitle('📊 Your Engagement Stats')\n        .setDescription(`**Twitter:** @${connection.twitterHandle}\\n**Tier:** ${connection.tier ? connection.tier.toUpperCase() : 'MICRO'}\\n**Total Points:** ${connection.totalPoints || 0}`)\n        .addFields(\n          { name: 'Daily Limit', value: `${dailySubmissions}/${scenarios.dailyTweetLimit}`, inline: true },\n          { name: 'Bonus Multiplier', value: `${scenarios.bonusMultiplier}x`, inline: true },\n          { name: 'Categories', value: scenarios.categories.join(', '), inline: false }\n        )\n        .setTimestamp()\n      \n      if (logs.length > 0) {\n        const recentActivity = logs.map(log => \n          `${log.interactionType === 'like' ? '❤️' : log.interactionType === 'retweet' ? '🔁' : '💬'} +${log.points} points`\n        ).join('\\n')\n        embed.addFields({ name: 'Recent Activity', value: recentActivity })\n      }\n      \n      await interaction.editReply({ embeds: [embed] })\n    }\n    \n    else if (commandName === 'leaderboard') {\n      await interaction.deferReply()\n      \n      // Get leaderboard data\n      const keys = await redis.keys('engagement:connection:*')\n      const entries = []\n      \n      for (const key of keys.slice(0, 50)) {\n        const connection = await redis.json.get(key)\n        if (connection) {\n          entries.push({\n            discordId: connection.discordId,\n            twitterHandle: connection.twitterHandle,\n            totalPoints: connection.totalPoints || 0,\n            tier: connection.tier\n          })\n        }\n      }\n      \n      // Sort by points\n      entries.sort((a, b) => b.totalPoints - a.totalPoints)\n      \n      const embed = new EmbedBuilder()\n        .setColor(0xFFD700) // Gold\n        .setTitle('🏆 Engagement Leaderboard')\n        .setDescription('Top 10 Engagers')\n        .setTimestamp()\n      \n      const top10 = entries.slice(0, 10).map((entry, index) => {\n        const tierEmoji = {\n          'micro': '⚪',\n          'rising': '🟢',\n          'star': '⭐',\n          'legend': '🟠',\n          'hero': '👑'\n        }[entry.tier] || '⚪'\n        return `**${index + 1}.** @${entry.twitterHandle} ${tierEmoji} ${entry.tier ? entry.tier.toUpperCase() : 'MICRO'} - ${entry.totalPoints} points`\n      }).join('\\n')\n      \n      embed.addFields({ name: 'Rankings', value: top10 || 'No data yet' })\n      \n      await interaction.editReply({ embeds: [embed] })\n    }\n    \n    else if (commandName === 'recent') {\n      await interaction.deferReply()\n      \n      try {\n        // Get recent tweets from sorted set\n        const tweetIds = await redis.zrange('engagement:tweets:recent', 0, 9, { rev: true }) // Get last 10\n        const tweets = []\n        \n        for (const id of tweetIds) {\n          const tweet = await redis.json.get(`engagement:tweet:${id}`)\n          if (tweet) tweets.push(tweet)\n        }\n        \n        const embed = new EmbedBuilder()\n          .setColor(0x1DA1F2) // Twitter blue\n          .setTitle('🐦 Recent Tweets for Engagement')\n          .setDescription('Click on any tweet to engage and earn points!')\n          .setTimestamp()\n        \n        if (tweets.length === 0) {\n          embed.addFields({ name: 'No tweets yet', value: 'Be the first to submit a tweet with `/submit`!' })\n        } else {\n          let tweetList = ''\n          tweets.forEach((tweet, index) => {\n            tweetList += `**${index + 1}. @${tweet.authorHandle}**\\n`\n            if (tweet.content) {\n              tweetList += `\"${tweet.content.substring(0, 100)}${tweet.content.length > 100 ? '...' : ''}\"\\n`\n            }\n            tweetList += `💰 ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | [View Tweet](${tweet.url})\\n\\n`\n          })\n          embed.addFields({ name: 'Recent Tweets', value: tweetList || 'No tweets yet' })\n        }\n        \n        await interaction.editReply({ embeds: [embed] })\n      } catch (error) {\n        console.error('Error in /recent command:', error)\n        await interaction.editReply('❌ An error occurred while fetching recent tweets.')\n      }\n    }\n    \n    else if (commandName === 'tier') {\n      // Admin only\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin) {\n        await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n        return\n      }\n      \n      const user = interaction.options.getUser('user')\n      const tier = interaction.options.getString('tier')\n      \n      const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n      if (!validTiers.includes(tier)) {\n        await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n        return\n      }\n      \n      const connection = await redis.json.get(`engagement:connection:${user.id}`)\n      if (!connection) {\n        await interaction.reply({ content: '❌ User has not connected their Twitter account.', flags: 64 })\n        return\n      }\n      \n      await redis.json.set(`engagement:connection:${user.id}`, '$.tier', tier)\n      await interaction.reply({ content: `✅ Updated ${user.username}'s tier to ${tier.toUpperCase()}`, flags: 64 })\n    }\n    \n    else if (commandName === 'scenarios') {\n      // Admin only\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin) {\n        await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n        return\n      }\n      \n      const tier = interaction.options.getString('tier')\n      const dailyLimit = interaction.options.getInteger('daily_limit')\n      const minFollowers = interaction.options.getInteger('min_followers')\n      const bonusMultiplier = interaction.options.getNumber('bonus_multiplier')\n      \n      const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n      if (!validTiers.includes(tier)) {\n        await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n        return\n      }\n      \n      // Get current scenarios\n      const currentScenarios = await getTierScenarios(tier)\n      \n      // Update with new values\n      if (dailyLimit !== null) currentScenarios.dailyTweetLimit = dailyLimit\n      if (minFollowers !== null) currentScenarios.minFollowers = minFollowers\n      if (bonusMultiplier !== null) currentScenarios.bonusMultiplier = bonusMultiplier\n      \n      // Save scenarios\n      await redis.json.set(`engagement:scenarios:${tier}`, '$', currentScenarios)\n      \n      await interaction.reply({ \n        content: `✅ Updated ${tier.toUpperCase()} tier scenarios:\\n` +\n                 `Daily Limit: ${currentScenarios.dailyTweetLimit}\\n` +\n                 `Min Followers: ${currentScenarios.minFollowers}\\n` +\n                 `Bonus Multiplier: ${currentScenarios.bonusMultiplier}x`,\n        flags: 64 \n      })\n    }\n  }\n  \n  // Handle modal submissions\n  else if (interaction.isModalSubmit()) {\n    if (interaction.customId === 'connect-twitter') {\n      const handle = interaction.fields.getTextInputValue('twitter-handle')\n      const cleanHandle = handle.toLowerCase().replace('@', '').trim()\n      \n      // Check if user is approved\n      const { approved, userData, exists } = await isUserApproved(cleanHandle)\n      \n      // If user doesn't exist, create a new profile (pending approval)\n      if (!exists) {\n        try {\n          const newUser = await createUserProfile(cleanHandle, interaction.user.id)\n          console.log(`✅ Created new profile (pending) for @${cleanHandle}`)\n          \n          await interaction.reply({ \n            content: `📝 Your Twitter account @${cleanHandle} has been registered!\\n\\n` +\n                     `⏳ **Your account is pending approval.** An admin will review and approve your account soon.\\n` +\n                     `📢 You'll be notified once approved and can then use the engagement features.`, \n            flags: 64 \n          })\n          return\n        } catch (error) {\n          console.error('Error creating new user profile:', error)\n          await interaction.reply({ \n            content: '❌ An error occurred while creating your profile. Please try again or contact an admin.', \n            flags: 64 \n          })\n          return\n        }\n      }\n      \n      // If user exists but is not approved\n      if (!approved) {\n        await interaction.reply({ \n          content: '❌ Your Twitter account is pending approval. Please wait for an admin to approve your account.', \n          flags: 64 \n        })\n        return\n      }\n      \n      // Check if handle is already connected\n      const existingDiscordId = await redis.get(`engagement:twitter:${cleanHandle}`)\n      if (existingDiscordId && existingDiscordId !== interaction.user.id) {\n        await interaction.reply({ \n          content: '❌ This Twitter account is already connected to another Discord user.', \n          flags: 64 \n        })\n        return\n      }\n      \n      // Get current role from database\n      const currentRole = userData.role || 'user'\n      \n      // Assign KOL role if user doesn't have a higher role\n      let finalRole = currentRole\n      if (ROLE_HIERARCHY[currentRole] < ROLE_HIERARCHY['kol']) {\n        finalRole = 'kol'\n        await updateUserRole(cleanHandle, 'kol')\n        \n        // Also assign Discord role if available\n        try {\n          const member = await interaction.guild.members.fetch(interaction.user.id)\n          const kolRole = interaction.guild.roles.cache.find(role => role.name.toLowerCase() === KOL_ROLE_NAME)\n          \n          if (kolRole) {\n            // Check if bot has permission to manage roles\n            const botMember = interaction.guild.members.cache.get(client.user.id)\n            if (!botMember.permissions.has('ManageRoles')) {\n              console.warn('⚠️  Bot lacks \"Manage Roles\" permission - cannot assign KOL role')\n              console.log('   Please grant the bot \"Manage Roles\" permission in Discord')\n            } \n            // Check if bot's highest role is above the KOL role\n            else if (botMember.roles.highest.position <= kolRole.position) {\n              console.warn('⚠️  Bot\\'s role is not high enough to assign the KOL role')\n              console.log('   Please move the bot\\'s role above the KOL role in Discord settings')\n            }\n            // Try to assign the role\n            else if (!member.roles.cache.has(kolRole.id)) {\n              await member.roles.add(kolRole)\n              console.log(`✅ Assigned KOL role to ${member.user.tag}`)\n            }\n          } else {\n            console.warn(`⚠️  No role found with name \"${KOL_ROLE_NAME}\" (case-insensitive)`)\n            console.log('   Please create a role named \"kol\" in your Discord server')\n          }\n        } catch (error) {\n          console.error('❌ Error assigning Discord role:', error.message)\n          if (error.code === 50013) {\n            console.log('   This is a permissions issue. Please check:')\n            console.log('   1. Bot has \"Manage Roles\" permission')\n            console.log('   2. Bot\\'s role is above the KOL role in the hierarchy')\n          }\n        }\n      }\n      \n      // Create connection - get tier from user profile\n      const userTier = userData.tier || 'micro'  // Default to micro if no tier\n      const connection = {\n        discordId: interaction.user.id,\n        twitterHandle: cleanHandle,\n        tier: userTier,\n        connectedAt: new Date(),\n        totalPoints: 0,\n        role: finalRole\n      }\n      \n      await redis.json.set(`engagement:connection:${interaction.user.id}`, '$', connection)\n      await redis.set(`engagement:twitter:${cleanHandle}`, interaction.user.id)\n      \n      let message = `✅ Successfully connected Twitter account @${cleanHandle}!`\n      if (finalRole === 'kol' && currentRole !== 'kol') {\n        message += '\\n🎉 You\\'ve been assigned the KOL role!'\n      }\n      \n      await interaction.reply({ \n        content: message, \n        flags: 64 \n      })\n    }\n  }\n})\n\n// Error handling\nclient.on('error', console.error)\n\n// Handle regular messages (for ping/pong)\nclient.on('messageCreate', async (message) => {\n  // Ignore messages from bots\n  if (message.author.bot) return\n  \n  // Simple ping/pong response\n  if (message.content.toLowerCase() === 'ping' || message.content.toLowerCase() === '!ping') {\n    try {\n      await message.reply('pong! 🏓')\n      console.log(`Replied to ping from ${message.author.tag}`)\n    } catch (error) {\n      console.error('Error replying to ping:', error)\n    }\n  }\n})\n\n// Login\nconst botToken = process.env.DISCORD_ENGAGEMENT_BOT_TOKEN || process.env.DISCORD_BOT_TOKEN\nif (!botToken) {\n  console.error('❌ No bot token found! Please set DISCORD_ENGAGEMENT_BOT_TOKEN in your .env.local file')\n  console.error('   You need to create a separate Discord bot for the engagement bot')\n  process.exit(1)\n}\n\nclient.login(botToken)\n  .then(() => console.log('🚀 Engagement bot starting...'))\n  .catch((error) => {\n    console.error('❌ Failed to login:', error)\n    console.error('   Make sure DISCORD_ENGAGEMENT_BOT_TOKEN is set correctly in .env.local')\n  }) ",
    "fixed": "const { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle, REST, Routes } = require('discord.js')\nconst { config } = require('dotenv')\nconst { Redis } = require('@upstash/redis')\nconst { GoogleGenerativeAI } = require('@google/generative-ai')\nconst path = require('path')\nconst { nanoid } = require('nanoid')\n\n// Load environment variables from parent directory\nconst envPath = path.join(__dirname, '..', '.env.local')\nconsole.log('🔍 Loading environment from:', envPath)\nconfig({ path: envPath })\n\n// Check required environment variables\nconst requiredVars = ['UPSTASH_REDIS_REST_URL', 'UPSTASH_REDIS_REST_TOKEN', 'DISCORD_BOT_TOKEN']\nconst optionalVars = ['GEMINI_API_KEY', 'GOOGLE_AI_API_KEY'] // Try both for compatibility\nconst missingVars = requiredVars.filter(v => !process.env[v])\n\n// Check for Gemini/Google AI key\nconst hasAiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n\nif (missingVars.length > 0) {\n  console.error('❌ Missing required environment variables:', missingVars.join(', '))\n  console.error('🔍 Please check your .env.local file contains:')\n  missingVars.forEach(v => console.error(`   ${v}=your_value_here`))\n  process.exit(1)\n}\n\nif (!hasAiKey) {\n  console.warn('⚠️  No AI API key found (GEMINI_API_KEY or GOOGLE_AI_API_KEY)')\n  console.warn('   Sentiment analysis will be disabled')\n}\n\n// Initialize Redis\nconst redis = new Redis({\n  url: process.env.UPSTASH_REDIS_REST_URL,\n  token: process.env.UPSTASH_REDIS_REST_TOKEN\n})\n\n// Initialize Gemini for sentiment analysis (if available)\nlet genAI = null\nlet model = null\n\nif (hasAiKey) {\n  const apiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n  genAI = new GoogleGenerativeAI(apiKey)\n  model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' })\n  console.log('✅ AI model initialized for sentiment analysis')\n}\n\n// Initialize Discord client\nconst client = new Client({\n  intents: [\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildMessages,\n    GatewayIntentBits.MessageContent,\n    GatewayIntentBits.GuildMessageReactions,\n    GatewayIntentBits.GuildMembers\n  ]\n})\n\n// Tweet URL regex\nconst TWEET_REGEX = /https?:\\/\\/(twitter\\.com|x\\.com)\\/[\\w]+\\/status\\/(\\d+)/i\n\n// Bot configuration\nconst BOT_CHANNEL_NAME = 'engagement-tracker'\nconst ADMIN_ROLE_NAME = 'admin'\nconst KOL_ROLE_NAME = 'kol'\n\n// Role hierarchy (higher number = higher priority)\nconst ROLE_HIERARCHY = {\n  'admin': 4,\n  'core': 3,\n  'team': 2,\n  'kol': 1,\n  'user': 0\n}\n\n// Helper function to extract tweet ID from URL\nfunction extractTweetId(url) {\n  const match = url.match(TWEET_REGEX)\n  return match ? match[2] : null\n}\n\n// Helper function to extract Twitter handle from URL\nfunction extractTwitterHandle(url) {\n  const match = url.match(/https?:\\/\\/(twitter\\.com|x\\.com)\\/([\\w]+)\\/status/)\n  return match ? match[2] : null\n}\n\n// Create a new user profile (pending approval)\nasync function createUserProfile(twitterHandle, discordId) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userId = `user_${normalizedHandle}`\n    \n    const newUser = {\n      id: userId,\n      twitterHandle: `@${normalizedHandle}`,\n      name: normalizedHandle, // Use handle as name initially\n      approvalStatus: 'pending', // Set to pending, requiring admin approval\n      role: 'user', // Default to user role\n      tier: 'micro', // Default tier\n      discordId: discordId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      socialAccounts: {\n        twitter: {\n          handle: normalizedHandle,\n          connected: true\n        }\n      }\n    }\n    \n    // Save to Redis\n    await redis.json.set(userId, '$', newUser)\n    \n    // Create username index\n    await redis.sadd(`idx:username:${normalizedHandle}`, userId)\n    \n    // Add to pending users set (not approved)\n    await redis.sadd('users:pending', userId)\n    \n    console.log(`✅ Created new user profile (pending) for @${normalizedHandle}`)\n    return newUser\n  } catch (error) {\n    console.error('Error creating user profile:', error)\n    throw error\n  }\n}\n\n\n// Check if user is approved in the database\nasync function isUserApproved(twitterHandle) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    \n    // Check if user exists via username index\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    if (!userIds || userIds.length === 0) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Get user data\n    const userData = await redis.json.get(`user:${userIds[0]}`)\n    if (!userData) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Check approval status\n    const isApproved = userData.approvalStatus === 'approved'\n    return { approved: isApproved, userData, exists: true }\n  } catch (error) {\n    console.error('Error checking user approval:', error)\n    return { approved: false, userData: null, exists: false }\n  }\n}\n\n// Get user's current role from database\nasync function getUserRole(twitterHandle) {\n  try {\n    const { approved, userData } = await isUserApproved(twitterHandle)\n    if (!approved || !userData) return 'user'\n    \n    return userData.role || 'user'\n  } catch (error) {\n    console.error('Error getting user role:', error)\n    return 'user'\n  }\n}\n\n// Update user's role in database\nasync function updateUserRole(twitterHandle, newRole) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    \n    if (userIds && userIds.length > 0) {\n      await redis.json.set(`user:${userIds[0]}`, '$.role', newRole)\n      return true\n    }\n    return false\n  } catch (error) {\n    console.error('Error updating user role:', error)\n    return false\n  }\n}\n\n// Get tier-based scenarios\nasync function getTierScenarios(tier) {\n  try {\n    const safeTier = tier || 'micro' // Default to micro if tier is null/undefined\n    const scenarios = await redis.json.get(`engagement:scenarios:${safeTier}`)\n    return scenarios || getDefaultScenarios(safeTier)\n  } catch (error) {\n    console.error('Error getting tier scenarios:', error)\n    return getDefaultScenarios(tier || 'micro')\n  }\n}\n\n// Default scenarios by tier\nfunction getDefaultScenarios(tier) {\n  const scenarios = {\n    'micro': {\n      dailyTweetLimit: 5,\n      categories: ['General', 'DeFi', 'NFT'],\n      minFollowers: 100,\n      bonusMultiplier: 1.0\n    },\n    'rising': {\n      dailyTweetLimit: 10,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech'],\n      minFollowers: 500,\n      bonusMultiplier: 1.5\n    },\n    'star': {\n      dailyTweetLimit: 20,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News'],\n      minFollowers: 1000,\n      bonusMultiplier: 2.0\n    },\n    'legend': {\n      dailyTweetLimit: 30,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special'],\n      minFollowers: 5000,\n      bonusMultiplier: 2.5\n    },\n    'hero': {\n      dailyTweetLimit: 50,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special', 'VIP'],\n      minFollowers: 10000,\n      bonusMultiplier: 3.0\n    }\n  }\n  \n  return scenarios[tier] || scenarios['micro']\n}\n\n// Create minimal tweet embed with preview\nfunction createTweetEmbed(tweet, submitterName, includeButtons = true) {\n  // Choose color based on tier\n  const tierColors = {\n    'micro': 0x6B7280,  // Gray\n    'rising': 0x3BA55D, // Green\n    'star': 0x5865F2,   // Blue\n    'legend': 0xEA580C, // Orange\n    'hero': 0x9333EA    // Purple\n  }\n  \n  // Calculate potential points\n  const likePoints = Math.floor(10 * tweet.bonusMultiplier)\n  const retweetPoints = Math.floor(20 * tweet.bonusMultiplier)\n  const replyPoints = Math.floor(30 * tweet.bonusMultiplier)\n  \n  const embed = new EmbedBuilder()\n    .setColor(tierColors[tweet.tier] || 0x1DA1F2)\n    .setAuthor({ \n      name: `@${tweet.authorHandle}`, \n      url: `https://twitter.com/${tweet.authorHandle}`,\n      iconURL: 'https://abs.twimg.com/icons/apple-touch-icon-192x192.png'\n    })\n    .setDescription(\n      `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n      `**💰 Earn ${tweet.bonusMultiplier}x points:**\\n` +\n      `❤️ Like: ${likePoints} pts | 🔁 RT: ${retweetPoints} pts | 💬 Reply: ${replyPoints} pts`\n    )\n    .addFields(\n      { name: 'Tier', value: `⭐ ${tweet.tier}`, inline: true },\n      { name: 'Category', value: `${tweet.category}`, inline: true },\n      { name: 'Submitted', value: `<t:${Math.floor(new Date(tweet.submittedAt).getTime() / 1000)}:R>`, inline: true }\n    )\n    .setFooter({ text: `Submitted by ${submitterName}` })\n  \n  if (includeButtons) {\n    // Create clickable button for the tweet\n    const row = new ActionRowBuilder()\n      .addComponents(\n        new ButtonBuilder()\n          .setLabel('View & Engage')\n          .setStyle(ButtonStyle.Link)\n          .setURL(tweet.url)\n          .setEmoji('🐦')\n      )\n    \n    return { embeds: [embed], components: [row] }\n  }\n  \n  return { embeds: [embed] }\n}\n\n// Handle slash commands\nclient.on('ready', async () => {\n  console.log(`✅ Engagement bot logged in as ${client.user.tag}`)\n  \n  // Start checking for channel info requests\n  setInterval(async () => {\n    try {\n      // Look for any channel info requests\n      const keys = await redis.keys('discord:channel-info-request:*')\n      \n      for (const key of keys) {\n        const request = await redis.get(key)\n        if (!request) continue\n        \n        let channelId, serverId, projectId\n        try {\n          // Upstash Redis returns the parsed object directly\n          const parsed = typeof request === 'string' ? JSON.parse(request) : request\n          channelId = parsed.channelId\n          serverId = parsed.serverId\n          projectId = parsed.projectId\n        } catch (parseError) {\n          console.error(`Error parsing channel info request from ${key}:`, parseError)\n          console.error('Raw request data:', request)\n          await redis.del(key)\n          continue\n        }\n        \n        // Try to fetch the channel\n        try {\n          console.log(`[DEBUG] Looking for guild ${serverId}`)\n          console.log(`[DEBUG] Available guilds: ${client.guilds.cache.map(g => `${g.name} (${g.id})`).join(', ')}`)\n          \n          const guild = client.guilds.cache.get(serverId)\n          if (!guild) {\n            console.log(`Guild ${serverId} not found in cache`)\n            continue\n          }\n          \n          const channel = guild.channels.cache.get(channelId)\n          if (channel) {\n            // Store the response\n            const responseKey = `discord:channel-info-response:${channelId}`\n            await redis.set(responseKey, JSON.stringify({\n              id: channelId,\n              name: channel.name,\n              type: channel.type === 0 ? 'text' : 'voice'\n            }), {\n              ex: 60 // expire in 60 seconds\n            })\n            \n            // Also store permanent channel metadata\n            const channelMetadataKey = `channel:discord:${channelId}`\n            await redis.json.set(channelMetadataKey, '$', {\n              id: channelId,\n              name: channel.name,\n              type: channel.type === 0 ? 'text' : 'voice',\n              projectId: projectId || null,\n              updatedAt: new Date().toISOString()\n            })\n            \n            console.log(`✅ Fetched channel info: #${channel.name} (${channelId})`)\n          } else {\n            console.log(`Channel ${channelId} not found in guild ${serverId}`)\n          }\n        } catch (error) {\n          console.error(`Error fetching channel ${channelId}:`, error)\n        }\n        \n        // Delete the request\n        await redis.del(key)\n      }\n    } catch (error) {\n      console.error('Error processing channel info requests:', error)\n    }\n  }, 2000) // Check every 2 seconds\n  \n  // Register slash commands\n  const commands = [\n    {\n      name: 'ping',\n      description: 'Test if bot is responding'\n    },\n    {\n      name: 'connect',\n      description: 'Connect your Twitter account (must be approved)'\n    },\n    {\n      name: 'submit',\n      description: 'Submit a tweet for engagement tracking',\n      options: [{\n        name: 'url',\n        type: 3, // STRING\n        description: 'The tweet URL',\n        required: true\n      }, {\n        name: 'category',\n        type: 3,\n        description: 'Tweet category (optional)',\n        required: false\n      }]\n    },\n    {\n      name: 'stats',\n      description: 'View your engagement stats'\n    },\n    {\n      name: 'leaderboard',\n      description: 'View the engagement leaderboard'\n    },\n    {\n      name: 'recent',\n      description: 'View recently submitted tweets'\n    },\n    {\n      name: 'tier',\n      description: 'Admin: Set user tier',\n      options: [{\n        name: 'user',\n        type: 6, // USER\n        description: 'The user to update',\n        required: true\n      }, {\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }]\n    },\n    {\n      name: 'scenarios',\n      description: 'Admin: Configure tier scenarios',\n      options: [{\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }, {\n        name: 'daily_limit',\n        type: 4,\n        description: 'Daily tweet limit',\n        required: false\n      }, {\n        name: 'min_followers',\n        type: 4,\n        description: 'Minimum followers required',\n        required: false\n      }, {\n        name: 'bonus_multiplier',\n        type: 10, // DOUBLE\n        description: 'Points bonus multiplier',\n        required: false\n      }]\n    }\n  ]\n  \n  // Import REST and Routes for proper command registration\n  const { REST } = require('@discordjs/rest')\n  const { Routes } = require('discord-api-types/v9')\n  \n  const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_ENGAGEMENT_BOT_TOKEN || process.env.DISCORD_BOT_TOKEN)\n  \n  try {\n    console.log('🔄 Refreshing application (/) commands...')\n    \n    // Clear existing commands first to remove duplicates\n    await rest.put(\n      Routes.applicationCommands(client.user.id),\n      { body: [] }\n    )\n    \n    // Register commands to each guild for instant update\n    for (const guild of client.guilds.cache.values()) {\n      try {\n        await rest.put(\n          Routes.applicationGuildCommands(client.user.id, guild.id),\n          { body: commands }\n        )\n        console.log(`✅ Registered commands to guild: ${guild.name}`)\n      } catch (error) {\n        console.error(`❌ Failed to register to ${guild.name}:`, error.message)\n      }\n    }\n    \n    console.log('✅ Slash commands registered')\n  } catch (error) {\n    console.error('Error registering commands:', error)\n  }\n})\n\n// Handle interactions\nclient.on('interactionCreate', async (interaction) => {\n  console.log(`📥 Received interaction: ${interaction.type} - Command: ${interaction.commandName || 'N/A'} - User: ${interaction.user?.tag || 'Unknown'}`)\n  \n  try {\n    // Handle slash commands\n    if (interaction.isCommand()) {\n      const { commandName } = interaction\n      console.log(`🎯 Processing command: ${commandName}`)\n    \n    \n    if (commandName === 'connect') {\n      await interaction.deferReply({ flags: 64 })\n      \n      try {\n        // Generate a unique verification session\n        const sessionId = `verify-${interaction.user.id}-${Date.now()}`\n        const sessionKey = `discord:verify:${sessionId}`\n        \n        // Store session data\n        await redis.set(sessionKey, JSON.stringify({\n          discordId: interaction.user.id,\n          discordUsername: interaction.user.username,\n          discordTag: interaction.user.tag,\n          timestamp: Date.now()\n        }), { EX: 600 }) // Expires in 10 minutes\n        \n        // Create verification URL that will use the website's Twitter OAuth\n        const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3002'\n        const verificationUrl = `${baseUrl}/auth/discord-link?session=${sessionId}`\n        \n        const embed = new EmbedBuilder()\n          .setColor(0x1DA1F2) // Twitter blue\n          .setTitle('🔐 Secure Twitter Connection')\n          .setDescription(\n            'To securely connect your Twitter account, you need to verify ownership through Twitter OAuth.\\n\\n' +\n            '**Click the button below to:**\\n' +\n            '1. Sign in with Twitter (OAuth)\\n' +\n            '2. Authorize the connection\\n' +\n            '3. Your accounts will be linked automatically'\n          )\n          .addFields(\n            { name: '⏱️ Expires In', value: '10 minutes', inline: true },\n            { name: '🔒 Security', value: 'OAuth 2.0', inline: true }\n          )\n          .setFooter({ text: 'Only you can complete this verification' })\n        \n        const row = new ActionRowBuilder()\n          .addComponents(\n            new ButtonBuilder()\n              .setLabel('Verify Twitter Account')\n              .setStyle(ButtonStyle.Link)\n              .setURL(verificationUrl)\n              .setEmoji('🐦')\n          )\n        \n        await interaction.editReply({\n          embeds: [embed],\n          components: [row],\n          flags: 64\n        })\n      } catch (error) {\n        console.error('Error in connect command:', error)\n        await interaction.editReply('❌ An error occurred. Please try again.')\n      }\n    }\n    \n    else if (commandName === 'submit') {\n      await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n      \n      const url = interaction.options.getString('url')\n      const category = interaction.options.getString('category')\n      \n      // Validate URL\n      const tweetId = extractTweetId(url)\n      if (!tweetId) {\n        await interaction.editReply('❌ Invalid tweet URL. Please provide a valid Twitter/X URL.')\n        return\n      }\n      \n      // Check if user is connected\n      const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n      if (!connection) {\n        await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n        return\n      }\n      \n      // Check if user is still approved\n      const { approved } = await isUserApproved(connection.twitterHandle)\n      if (!approved) {\n        await interaction.editReply('❌ Your Twitter account is no longer approved. Please contact an admin.')\n        return\n      }\n      \n      // Check tier scenarios\n      const scenarios = await getTierScenarios(connection.tier)\n      \n      // Check daily limit\n      const today = new Date().toISOString().split('T')[0]\n      const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n      \n      if (dailySubmissions >= scenarios.dailyTweetLimit) {\n        await interaction.editReply(`❌ You've reached your daily limit of ${scenarios.dailyTweetLimit} tweets for Tier ${connection.tier}.`)\n        return\n      }\n      \n      // Check for duplicate\n      const isDuplicate = await redis.exists(`engagement:tweetid:${tweetId}`)\n      if (isDuplicate) {\n        await interaction.editReply('❌ This tweet has already been submitted.')\n        return\n      }\n      \n      // Extract author handle\n      const authorHandle = extractTwitterHandle(url)\n      \n      // Check if submitter is author or admin\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin && connection.twitterHandle !== authorHandle) {\n        await interaction.editReply('❌ You can only submit your own tweets. Admins can submit any tweet.')\n        return\n      }\n      \n      // Validate category\n      let finalCategory = category\n      if (category && !scenarios.categories.includes(category)) {\n        await interaction.editReply(`❌ Invalid category. Available categories for Tier ${connection.tier}: ${scenarios.categories.join(', ')}`)\n        return\n      }\n      \n      if (!finalCategory) {\n        finalCategory = 'General'\n      }\n      \n      // Submit tweet\n      try {\n        const { nanoid } = await import('nanoid')\n        // Try to fetch tweet content from Twitter API\n        let tweetContent = null\n        try {\n          const response = await fetch(`https://api.twitter.com/2/tweets/${tweetId}?tweet.fields=text`, {\n            headers: {\n              'Authorization': `Bearer ${process.env.TWITTER_BEARER_TOKEN}`\n            }\n          })\n          \n          if (response.ok) {\n            const tweetData = await response.json()\n            tweetContent = tweetData.data?.text || null\n            console.log('📝 Fetched tweet content:', tweetContent ? 'Success' : 'No content')\n          }\n        } catch (error) {\n          console.log('⚠️ Could not fetch tweet content:', error.message)\n        }\n\n        const tweet = {\n          id: nanoid(),\n          tweetId,\n          submitterDiscordId: interaction.user.id,\n          submittedAt: new Date(),\n          category: finalCategory,\n          url,\n          authorHandle,\n          content: tweetContent,\n          tier: connection.tier,\n          bonusMultiplier: scenarios.bonusMultiplier\n        }\n        \n        await redis.json.set(`engagement:tweet:${tweet.id}`, '$', tweet)\n        // Store in sorted set for admin panel compatibility\n        await redis.zadd('engagement:tweets:recent', { score: Date.now(), member: tweet.id })\n        await redis.set(`engagement:tweetid:${tweet.tweetId}`, tweet.id)\n        \n        // Increment daily counter\n        await redis.incr(`engagement:daily:${interaction.user.id}:${today}`)\n        await redis.expire(`engagement:daily:${interaction.user.id}:${today}`, 86400) // 24 hours\n        \n        // Send to channel\n        const channel = interaction.guild.channels.cache.find(ch => ch.name === BOT_CHANNEL_NAME)\n        if (channel) {\n          // Debug: Check bot permissions in channel\n          const botMember = interaction.guild.members.cache.get(client.user.id)\n          const perms = channel.permissionsFor(botMember)\n          console.log(`Bot permissions in #${BOT_CHANNEL_NAME}:`, {\n            viewChannel: perms.has('ViewChannel'),\n            sendMessages: perms.has('SendMessages'),\n            embedLinks: perms.has('EmbedLinks'),\n            readMessageHistory: perms.has('ReadMessageHistory'),\n            useExternalEmojis: perms.has('UseExternalEmojis')\n          })\n          try {\n            const messageContent = createTweetEmbed(tweet, interaction.user.username)\n            await channel.send(messageContent)\n            console.log(`✅ Posted tweet preview to #${BOT_CHANNEL_NAME}`)\n          } catch (channelError) {\n            console.error('Error posting to channel:', channelError)\n            console.log('Make sure the bot has permission to send messages in #engagement-tracker')\n            console.log('Required permissions: View Channel, Send Messages, Embed Links')\n            \n            // Try sending without buttons as fallback\n            try {\n              console.log('Attempting to send without buttons...')\n              const simpleEmbed = createTweetEmbed(tweet, interaction.user.username, false)\n              await channel.send(simpleEmbed)\n              console.log('✅ Sent simplified preview without buttons')\n            } catch (fallbackError) {\n              console.error('Even simple embed failed:', fallbackError)\n              console.log('Bot may lack basic permissions in the channel')\n              \n              // Last resort - send plain text\n              try {\n                const plainMessage = `**@${tweet.authorHandle}**\\n` +\n                  `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n                  `💰 Earn ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | ${tweet.category}\\n` +\n                  `🔗 ${tweet.url}`\n                await channel.send(plainMessage)\n                console.log('✅ Sent plain text preview')\n              } catch (textError) {\n                console.error('Cannot send any message to channel:', textError)\n              }\n            }\n          }\n        } else {\n          console.log(`Channel \"${BOT_CHANNEL_NAME}\" not found. Please create it for tweet announcements.`)\n        }\n        \n        await interaction.editReply(`✅ Tweet submitted successfully! (${parseInt(dailySubmissions) + 1}/${scenarios.dailyTweetLimit} today)`)\n      } catch (error) {\n        console.error('Error submitting tweet:', error)\n        await interaction.editReply('❌ An error occurred while submitting the tweet. Please try again.')\n      }\n    }\n    \n    else if (commandName === 'stats') {\n      await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n      \n      const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n      if (!connection) {\n        await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n        return\n      }\n      \n      // Get tier scenarios\n      const scenarios = await getTierScenarios(connection.tier)\n      \n      // Get today's submissions\n      const today = new Date().toISOString().split('T')[0]\n      const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n      \n      // Get recent engagements (skip for now since we don't have logs yet)\n      const logs = []\n      \n      const embed = new EmbedBuilder()\n        .setColor(0x00FF00)\n        .setTitle('📊 Your Engagement Stats')\n        .setDescription(`**Twitter:** @${connection.twitterHandle}\\n**Tier:** ${connection.tier ? connection.tier.toUpperCase() : 'MICRO'}\\n**Total Points:** ${connection.totalPoints || 0}`)\n        .addFields(\n          { name: 'Daily Limit', value: `${dailySubmissions}/${scenarios.dailyTweetLimit}`, inline: true },\n          { name: 'Bonus Multiplier', value: `${scenarios.bonusMultiplier}x`, inline: true },\n          { name: 'Categories', value: scenarios.categories.join(', '), inline: false }\n        )\n        .setTimestamp()\n      \n      if (logs.length > 0) {\n        const recentActivity = logs.map(log => \n          `${log.interactionType === 'like' ? '❤️' : log.interactionType === 'retweet' ? '🔁' : '💬'} +${log.points} points`\n        ).join('\\n')\n        embed.addFields({ name: 'Recent Activity', value: recentActivity })\n      }\n      \n      await interaction.editReply({ embeds: [embed] })\n    }\n    \n    else if (commandName === 'leaderboard') {\n      await interaction.deferReply()\n      \n      // Get leaderboard data\n      const keys = await redis.keys('engagement:connection:*')\n      const entries = []\n      \n      for (const key of keys.slice(0, 50)) {\n        const connection = await redis.json.get(key)\n        if (connection) {\n          entries.push({\n            discordId: connection.discordId,\n            twitterHandle: connection.twitterHandle,\n            totalPoints: connection.totalPoints || 0,\n            tier: connection.tier\n          })\n        }\n      }\n      \n      // Sort by points\n      entries.sort((a, b) => b.totalPoints - a.totalPoints)\n      \n      const embed = new EmbedBuilder()\n        .setColor(0xFFD700) // Gold\n        .setTitle('🏆 Engagement Leaderboard')\n        .setDescription('Top 10 Engagers')\n        .setTimestamp()\n      \n      const top10 = entries.slice(0, 10).map((entry, index) => {\n        const tierEmoji = {\n          'micro': '⚪',\n          'rising': '🟢',\n          'star': '⭐',\n          'legend': '🟠',\n          'hero': '👑'\n        }[entry.tier] || '⚪'\n        return `**${index + 1}.** @${entry.twitterHandle} ${tierEmoji} ${entry.tier ? entry.tier.toUpperCase() : 'MICRO'} - ${entry.totalPoints} points`\n      }).join('\\n')\n      \n      embed.addFields({ name: 'Rankings', value: top10 || 'No data yet' })\n      \n      await interaction.editReply({ embeds: [embed] })\n    }\n    \n    else if (commandName === 'recent') {\n      await interaction.deferReply()\n      \n      try {\n        // Get recent tweets from sorted set\n        const tweetIds = await redis.zrange('engagement:tweets:recent', 0, 9, { rev: true }) // Get last 10\n        const tweets = []\n        \n        for (const id of tweetIds) {\n          const tweet = await redis.json.get(`engagement:tweet:${id}`)\n          if (tweet) tweets.push(tweet)\n        }\n        \n        const embed = new EmbedBuilder()\n          .setColor(0x1DA1F2) // Twitter blue\n          .setTitle('🐦 Recent Tweets for Engagement')\n          .setDescription('Click on any tweet to engage and earn points!')\n          .setTimestamp()\n        \n        if (tweets.length === 0) {\n          embed.addFields({ name: 'No tweets yet', value: 'Be the first to submit a tweet with `/submit`!' })\n        } else {\n          let tweetList = ''\n          tweets.forEach((tweet, index) => {\n            tweetList += `**${index + 1}. @${tweet.authorHandle}**\\n`\n            if (tweet.content) {\n              tweetList += `\"${tweet.content.substring(0, 100)}${tweet.content.length > 100 ? '...' : ''}\"\\n`\n            }\n            tweetList += `💰 ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | [View Tweet](${tweet.url})\\n\\n`\n          })\n          embed.addFields({ name: 'Recent Tweets', value: tweetList || 'No tweets yet' })\n        }\n        \n        await interaction.editReply({ embeds: [embed] })\n      } catch (error) {\n        console.error('Error in /recent command:', error)\n        await interaction.editReply('❌ An error occurred while fetching recent tweets.')\n      }\n    }\n    \n    else if (commandName === 'tier') {\n      // Admin only\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin) {\n        await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n        return\n      }\n      \n      const user = interaction.options.getUser('user')\n      const tier = interaction.options.getString('tier')\n      \n      const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n      if (!validTiers.includes(tier)) {\n        await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n        return\n      }\n      \n      const connection = await redis.json.get(`engagement:connection:${user.id}`)\n      if (!connection) {\n        await interaction.reply({ content: '❌ User has not connected their Twitter account.', flags: 64 })\n        return\n      }\n      \n      await redis.json.set(`engagement:connection:${user.id}`, '$.tier', tier)\n      await interaction.reply({ content: `✅ Updated ${user.username}'s tier to ${tier.toUpperCase()}`, flags: 64 })\n    }\n    \n    else if (commandName === 'scenarios') {\n      // Admin only\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin) {\n        await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n        return\n      }\n      \n      const tier = interaction.options.getString('tier')\n      const dailyLimit = interaction.options.getInteger('daily_limit')\n      const minFollowers = interaction.options.getInteger('min_followers')\n      const bonusMultiplier = interaction.options.getNumber('bonus_multiplier')\n      \n      const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n      if (!validTiers.includes(tier)) {\n        await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n        return\n      }\n      \n      // Get current scenarios\n      const currentScenarios = await getTierScenarios(tier)\n      \n      // Update with new values\n      if (dailyLimit !== null) currentScenarios.dailyTweetLimit = dailyLimit\n      if (minFollowers !== null) currentScenarios.minFollowers = minFollowers\n      if (bonusMultiplier !== null) currentScenarios.bonusMultiplier = bonusMultiplier\n      \n      // Save scenarios\n      await redis.json.set(`engagement:scenarios:${tier}`, '$', currentScenarios)\n      \n      await interaction.reply({ \n        content: `✅ Updated ${tier.toUpperCase()} tier scenarios:\\n` +\n                 `Daily Limit: ${currentScenarios.dailyTweetLimit}\\n` +\n                 `Min Followers: ${currentScenarios.minFollowers}\\n` +\n                 `Bonus Multiplier: ${currentScenarios.bonusMultiplier}x`,\n        flags: 64 \n      })\n    }\n  }\n  \n  // Handle modal submissions\n  else if (interaction.isModalSubmit()) {\n    if (interaction.customId === 'connect-twitter') {\n      const handle = interaction.fields.getTextInputValue('twitter-handle')\n      const cleanHandle = handle.toLowerCase().replace('@', '').trim()\n      \n      // Check if user is approved\n      const { approved, userData, exists } = await isUserApproved(cleanHandle)\n      \n      // If user doesn't exist, create a new profile (pending approval)\n      if (!exists) {\n        try {\n          const newUser = await createUserProfile(cleanHandle, interaction.user.id)\n          console.log(`✅ Created new profile (pending) for @${cleanHandle}`)\n          \n          await interaction.reply({ \n            content: `📝 Your Twitter account @${cleanHandle} has been registered!\\n\\n` +\n                     `⏳ **Your account is pending approval.** An admin will review and approve your account soon.\\n` +\n                     `📢 You'll be notified once approved and can then use the engagement features.`, \n            flags: 64 \n          })\n          return\n        } catch (error) {\n          console.error('Error creating new user profile:', error)\n          await interaction.reply({ \n            content: '❌ An error occurred while creating your profile. Please try again or contact an admin.', \n            flags: 64 \n          })\n          return\n        }\n      }\n      \n      // If user exists but is not approved\n      if (!approved) {\n        await interaction.reply({ \n          content: '❌ Your Twitter account is pending approval. Please wait for an admin to approve your account.', \n          flags: 64 \n        })\n        return\n      }\n      \n      // Check if handle is already connected\n      const existingDiscordId = await redis.get(`engagement:twitter:${cleanHandle}`)\n      if (existingDiscordId && existingDiscordId !== interaction.user.id) {\n        await interaction.reply({ \n          content: '❌ This Twitter account is already connected to another Discord user.', \n          flags: 64 \n        })\n        return\n      }\n      \n      // Get current role from database\n      const currentRole = userData.role || 'user'\n      \n      // Assign KOL role if user doesn't have a higher role\n      let finalRole = currentRole\n      if (ROLE_HIERARCHY[currentRole] < ROLE_HIERARCHY['kol']) {\n        finalRole = 'kol'\n        await updateUserRole(cleanHandle, 'kol')\n        \n        // Also assign Discord role if available\n        try {\n          const member = await interaction.guild.members.fetch(interaction.user.id)\n          const kolRole = interaction.guild.roles.cache.find(role => role.name.toLowerCase() === KOL_ROLE_NAME)\n          \n          if (kolRole) {\n            // Check if bot has permission to manage roles\n            const botMember = interaction.guild.members.cache.get(client.user.id)\n            if (!botMember.permissions.has('ManageRoles')) {\n              console.warn('⚠️  Bot lacks \"Manage Roles\" permission - cannot assign KOL role')\n              console.log('   Please grant the bot \"Manage Roles\" permission in Discord')\n            } \n            // Check if bot's highest role is above the KOL role\n            else if (botMember.roles.highest.position <= kolRole.position) {\n              console.warn('⚠️  Bot\\'s role is not high enough to assign the KOL role')\n              console.log('   Please move the bot\\'s role above the KOL role in Discord settings')\n            }\n            // Try to assign the role\n            else if (!member.roles.cache.has(kolRole.id)) {\n              await member.roles.add(kolRole)\n              console.log(`✅ Assigned KOL role to ${member.user.tag}`)\n            }\n          } else {\n            console.warn(`⚠️  No role found with name \"${KOL_ROLE_NAME}\" (case-insensitive)`)\n            console.log('   Please create a role named \"kol\" in your Discord server')\n          }\n        } catch (error) {\n          console.error('❌ Error assigning Discord role:', error.message)\n          if (error.code === 50013) {\n            console.log('   This is a permissions issue. Please check:')\n            console.log('   1. Bot has \"Manage Roles\" permission')\n            console.log('   2. Bot\\'s role is above the KOL role in the hierarchy')\n          }\n        }\n      }\n      \n      // Create connection - get tier from user profile\n      const userTier = userData.tier || 'micro'  // Default to micro if no tier\n      const connection = {\n        discordId: interaction.user.id,\n        twitterHandle: cleanHandle,\n        tier: userTier,\n        connectedAt: new Date(),\n        totalPoints: 0,\n        role: finalRole\n      }\n      \n      await redis.json.set(`engagement:connection:${interaction.user.id}`, '$', connection)\n      await redis.set(`engagement:twitter:${cleanHandle}`, interaction.user.id)\n      \n      let message = `✅ Successfully connected Twitter account @${cleanHandle}!`\n      if (finalRole === 'kol' && currentRole !== 'kol') {\n        message += '\\n🎉 You\\'ve been assigned the KOL role!'\n      }\n      \n      await interaction.reply({ \n        content: message, \n        flags: 64 \n      })\n    }\n  }\n})\n\n// Error handling\nclient.on('error', console.error)\n\n// Handle regular messages (for ping/pong)\nclient.on('messageCreate', async (message) => {\n  // Ignore messages from bots\n  if (message.author.bot) return\n  \n  // Simple ping/pong response\n  if (message.content.toLowerCase() === 'ping' || message.content.toLowerCase() === '!ping') {\n    try {\n      await message.reply('pong! 🏓')\n      console.log(`Replied to ping from ${message.author.tag}`)\n    } catch (error) {\n      console.error('Error replying to ping:', error)\n    }\n  }\n})\n\n// Login\nconst botToken = process.env.DISCORD_ENGAGEMENT_BOT_TOKEN || process.env.DISCORD_BOT_TOKEN\nif (!botToken) {\n  console.error('❌ No bot token found! Please set DISCORD_ENGAGEMENT_BOT_TOKEN in your .env.local file')\n  console.error('   You need to create a separate Discord bot for the engagement bot')\n  process.exit(1)\n}\n\nclient.login(botToken)\n  .then(() => console.log('🚀 Engagement bot starting...'))\n  .catch((error) => {\n    console.error('❌ Failed to login:', error)\n    console.error('   Make sure DISCORD_ENGAGEMENT_BOT_TOKEN is set correctly in .env.local')\n  }) "
  },
  {
    "file": "discord-bots/engagement-bot-working.js",
    "original": "const { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle, REST, Routes } = require('discord.js')\nconst { config } = require('dotenv')\nconst { Redis } = require('@upstash/redis')\nconst { GoogleGenerativeAI } = require('@google/generative-ai')\nconst path = require('path')\nconst { nanoid } = require('nanoid')\n\n// Load environment variables from parent directory\nconst envPath = path.join(__dirname, '..', '.env.local')\nconsole.log('🔍 Loading environment from:', envPath)\nconfig({ path: envPath })\n\n// Check required environment variables\nconst requiredVars = ['UPSTASH_REDIS_REST_URL', 'UPSTASH_REDIS_REST_TOKEN', 'DISCORD_BOT_TOKEN']\nconst optionalVars = ['GEMINI_API_KEY', 'GOOGLE_AI_API_KEY'] // Try both for compatibility\nconst missingVars = requiredVars.filter(v => !process.env[v])\n\n// Check for Gemini/Google AI key\nconst hasAiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n\nif (missingVars.length > 0) {\n  console.error('❌ Missing required environment variables:', missingVars.join(', '))\n  console.error('🔍 Please check your .env.local file contains:')\n  missingVars.forEach(v => console.error(`   ${v}=your_value_here`))\n  process.exit(1)\n}\n\nif (!hasAiKey) {\n  console.warn('⚠️  No AI API key found (GEMINI_API_KEY or GOOGLE_AI_API_KEY)')\n  console.warn('   Sentiment analysis will be disabled')\n}\n\n// Initialize Redis\nconst redis = new Redis({\n  url: process.env.UPSTASH_REDIS_REST_URL,\n  token: process.env.UPSTASH_REDIS_REST_TOKEN\n})\n\n// Initialize Gemini for sentiment analysis (if available)\nlet genAI = null\nlet model = null\n\nif (hasAiKey) {\n  const apiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n  genAI = new GoogleGenerativeAI(apiKey)\n  model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' })\n  console.log('✅ AI model initialized for sentiment analysis')\n}\n\n// Initialize Discord client\nconst client = new Client({\n  intents: [\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildMessages,\n    GatewayIntentBits.MessageContent,\n    GatewayIntentBits.GuildMessageReactions,\n    GatewayIntentBits.GuildMembers\n  ]\n})\n\n// Tweet URL regex\nconst TWEET_REGEX = /https?:\\/\\/(twitter\\.com|x\\.com)\\/[\\w]+\\/status\\/(\\d+)/i\n\n// Bot configuration\nconst BOT_CHANNEL_NAME = 'engagement-tracker'\nconst ADMIN_ROLE_NAME = 'admin'\nconst KOL_ROLE_NAME = 'kol'\n\n// Role hierarchy (higher number = higher priority)\nconst ROLE_HIERARCHY = {\n  'admin': 4,\n  'core': 3,\n  'team': 2,\n  'kol': 1,\n  'user': 0\n}\n\n// Helper function to extract tweet ID from URL\nfunction extractTweetId(url) {\n  const match = url.match(TWEET_REGEX)\n  return match ? match[2] : null\n}\n\n// Helper function to extract Twitter handle from URL\nfunction extractTwitterHandle(url) {\n  const match = url.match(/https?:\\/\\/(twitter\\.com|x\\.com)\\/([\\w]+)\\/status/)\n  return match ? match[2] : null\n}\n\n// Check if user is approved in the database\nasync function isUserApproved(twitterHandle) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    \n    // Check if user exists via username index\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    if (!userIds || userIds.length === 0) {\n      return { approved: false, userData: null }\n    }\n    \n    // Get user data\n    const userData = await redis.json.get(`user:${userIds[0]}`)\n    if (!userData) {\n      return { approved: false, userData: null }\n    }\n    \n    // Check approval status\n    const isApproved = userData.approvalStatus === 'approved'\n    return { approved: isApproved, userData }\n  } catch (error) {\n    console.error('Error checking user approval:', error)\n    return { approved: false, userData: null }\n  }\n}\n\n// Get user's current role from database\nasync function getUserRole(twitterHandle) {\n  try {\n    const { approved, userData } = await isUserApproved(twitterHandle)\n    if (!approved || !userData) return 'user'\n    \n    return userData.role || 'user'\n  } catch (error) {\n    console.error('Error getting user role:', error)\n    return 'user'\n  }\n}\n\n// Update user's role in database\nasync function updateUserRole(twitterHandle, newRole) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    \n    if (userIds && userIds.length > 0) {\n      await redis.json.set(`user:${userIds[0]}`, '$.role', newRole)\n      return true\n    }\n    return false\n  } catch (error) {\n    console.error('Error updating user role:', error)\n    return false\n  }\n}\n\n// Get tier-based scenarios\nasync function getTierScenarios(tier) {\n  try {\n    const safeTier = tier || 'micro' // Default to micro if tier is null/undefined\n    const scenarios = await redis.json.get(`engagement:scenarios:${safeTier}`)\n    return scenarios || getDefaultScenarios(safeTier)\n  } catch (error) {\n    console.error('Error getting tier scenarios:', error)\n    return getDefaultScenarios(tier || 'micro')\n  }\n}\n\n// Default scenarios by tier\nfunction getDefaultScenarios(tier) {\n  const scenarios = {\n    'micro': {\n      dailyTweetLimit: 5,\n      categories: ['General', 'DeFi', 'NFT'],\n      minFollowers: 100,\n      bonusMultiplier: 1.0\n    },\n    'rising': {\n      dailyTweetLimit: 10,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech'],\n      minFollowers: 500,\n      bonusMultiplier: 1.5\n    },\n    'star': {\n      dailyTweetLimit: 20,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News'],\n      minFollowers: 1000,\n      bonusMultiplier: 2.0\n    },\n    'legend': {\n      dailyTweetLimit: 30,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special'],\n      minFollowers: 5000,\n      bonusMultiplier: 2.5\n    },\n    'hero': {\n      dailyTweetLimit: 50,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special', 'VIP'],\n      minFollowers: 10000,\n      bonusMultiplier: 3.0\n    }\n  }\n  \n  return scenarios[tier] || scenarios['micro']\n}\n\n// Create minimal tweet embed with preview\nfunction createTweetEmbed(tweet, submitterName, includeButtons = true) {\n  // Choose color based on tier\n  const tierColors = {\n    'micro': 0x6B7280,  // Gray\n    'rising': 0x3BA55D, // Green\n    'star': 0x5865F2,   // Blue\n    'legend': 0xEA580C, // Orange\n    'hero': 0x9333EA    // Purple\n  }\n  \n  // Calculate potential points\n  const likePoints = Math.floor(10 * tweet.bonusMultiplier)\n  const retweetPoints = Math.floor(20 * tweet.bonusMultiplier)\n  const replyPoints = Math.floor(30 * tweet.bonusMultiplier)\n  \n  const embed = new EmbedBuilder()\n    .setColor(tierColors[tweet.tier] || 0x1DA1F2)\n    .setAuthor({ \n      name: `@${tweet.authorHandle}`, \n      url: `https://twitter.com/${tweet.authorHandle}`,\n      iconURL: 'https://abs.twimg.com/icons/apple-touch-icon-192x192.png'\n    })\n    .setDescription(\n      `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n      `**💰 Earn ${tweet.bonusMultiplier}x points:**\\n` +\n      `❤️ Like: ${likePoints} pts | 🔁 RT: ${retweetPoints} pts | 💬 Reply: ${replyPoints} pts`\n    )\n    .addFields(\n      { name: 'Tier', value: `⭐ ${tweet.tier}`, inline: true },\n      { name: 'Category', value: `${tweet.category}`, inline: true },\n      { name: 'Submitted', value: `<t:${Math.floor(new Date(tweet.submittedAt).getTime() / 1000)}:R>`, inline: true }\n    )\n    .setFooter({ text: `Submitted by ${submitterName}` })\n  \n  if (includeButtons) {\n    // Create clickable button for the tweet\n    const row = new ActionRowBuilder()\n      .addComponents(\n        new ButtonBuilder()\n          .setLabel('View & Engage')\n          .setStyle(ButtonStyle.Link)\n          .setURL(tweet.url)\n          .setEmoji('🐦')\n      )\n    \n    return { embeds: [embed], components: [row] }\n  }\n  \n  return { embeds: [embed] }\n}\n\n// Handle slash commands\nclient.on('ready', async () => {\n  console.log(`✅ Engagement bot logged in as ${client.user.tag}`)\n  console.log(`📍 Bot ID: ${client.user.id}`)\n  console.log(`🏠 Guilds: ${client.guilds.cache.map(g => `${g.name} (${g.id})`).join(', ')}`)\n  \n  // Register slash commands\n  const commands = [\n    {\n      name: 'connect',\n      description: 'Connect your Twitter account (must be approved)'\n    },\n    {\n      name: 'test',\n      description: 'Test if the bot is working'\n    },\n    {\n      name: 'submit',\n      description: 'Submit a tweet for engagement tracking',\n      options: [{\n        name: 'url',\n        type: 3, // STRING\n        description: 'The tweet URL',\n        required: true\n      }, {\n        name: 'category',\n        type: 3,\n        description: 'Tweet category (optional)',\n        required: false\n      }]\n    },\n    {\n      name: 'stats',\n      description: 'View your engagement stats'\n    },\n    {\n      name: 'leaderboard',\n      description: 'View the engagement leaderboard'\n    },\n    {\n      name: 'recent',\n      description: 'View recently submitted tweets'\n    },\n    {\n      name: 'tier',\n      description: 'Admin: Set user tier',\n      options: [{\n        name: 'user',\n        type: 6, // USER\n        description: 'The user to update',\n        required: true\n      }, {\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }]\n    },\n    {\n      name: 'scenarios',\n      description: 'Admin: Configure tier scenarios',\n      options: [{\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }, {\n        name: 'daily_limit',\n        type: 4,\n        description: 'Daily tweet limit',\n        required: false\n      }, {\n        name: 'min_followers',\n        type: 4,\n        description: 'Minimum followers required',\n        required: false\n      }, {\n        name: 'bonus_multiplier',\n        type: 10, // DOUBLE\n        description: 'Points bonus multiplier',\n        required: false\n      }]\n    }\n  ]\n  \n  try {\n    // Use REST API for proper command registration\n    const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_ENGAGEMENT_BOT_TOKEN || process.env.DISCORD_BOT_TOKEN)\n    \n    // Register commands to each guild for instant update\n    for (const guild of client.guilds.cache.values()) {\n      await rest.put(\n        Routes.applicationGuildCommands(client.user.id, guild.id),\n        { body: commands }\n      )\n      console.log(`✅ Registered commands to guild: ${guild.name}`)\n    }\n    \n    console.log('✅ Slash commands registered')\n  } catch (error) {\n    console.error('Error registering commands:', error)\n  }\n})\n\n// Handle interactions\nclient.on('interactionCreate', async (interaction) => {\n  try {\n    console.log(`📥 Received interaction: ${interaction.type} - ${interaction.commandName || 'N/A'} from ${interaction.user.tag}`)\n    \n    // Handle slash commands\n    if (interaction.isCommand()) {\n      const { commandName } = interaction\n      console.log(`🔧 Processing command: ${commandName}`)\n      \n      if (commandName === 'connect') {\n        console.log('📱 /connect command triggered')\n        await interaction.deferReply({ flags: 64 })\n        \n        try {\n          // Generate a unique verification session\n          const sessionId = `verify-${interaction.user.id}-${Date.now()}`\n          const sessionKey = `discord:verify:${sessionId}`\n          \n          // Store session data\n          await redis.set(sessionKey, JSON.stringify({\n            discordId: interaction.user.id,\n            discordUsername: interaction.user.username,\n            discordTag: interaction.user.tag,\n            timestamp: Date.now()\n          }), { EX: 600 }) // Expires in 10 minutes\n          \n          // Create verification URL that will use the website's Twitter OAuth\n          const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://www.nabulines.com'\n          const verificationUrl = `${baseUrl}/auth/discord-link?session=${sessionId}`\n          \n          console.log('🔗 Generated OAuth URL:', verificationUrl)\n          \n          const embed = new EmbedBuilder()\n            .setColor(0x1DA1F2) // Twitter blue\n            .setTitle('🔐 Secure Twitter Connection')\n            .setDescription(\n              'To connect your Twitter account, you need to verify ownership through Twitter OAuth.\\n\\n' +\n              '**Click the button below to:**\\n' +\n              '1. Sign in with Twitter (OAuth)\\n' +\n              '2. Authorize the connection\\n' +\n              '3. Your accounts will be linked automatically'\n            )\n            .addFields(\n              { name: '⏱️ Expires In', value: '10 minutes', inline: true },\n              { name: '🔒 Security', value: 'OAuth 2.0', inline: true }\n            )\n            .setFooter({ text: 'Only you can complete this verification' })\n          \n          const row = new ActionRowBuilder()\n            .addComponents(\n              new ButtonBuilder()\n                .setLabel('Verify Twitter Account')\n                .setStyle(ButtonStyle.Link)\n                .setURL(verificationUrl)\n                .setEmoji('🐦')\n            )\n          \n          await interaction.editReply({\n            embeds: [embed],\n            components: [row],\n            flags: 64\n          })\n        } catch (error) {\n          console.error('Error in connect command:', error)\n          await interaction.editReply('❌ An error occurred. Please try again.')\n        }\n      }\n      \n      else if (commandName === 'test') {\n        console.log('🧪 /test command triggered')\n        await interaction.reply({ \n          content: '✅ Bot is working! The /connect command should also work now.', \n          flags: 64 \n        })\n      }\n      \n      else if (commandName === 'submit') {\n        await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n        \n        const url = interaction.options.getString('url')\n        const category = interaction.options.getString('category')\n        \n        // Validate URL\n        const tweetId = extractTweetId(url)\n        if (!tweetId) {\n          await interaction.editReply('❌ Invalid tweet URL. Please provide a valid Twitter/X URL.')\n          return\n        }\n        \n        // Check if user is connected\n        const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n        if (!connection) {\n          await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n          return\n        }\n        \n        // Check if user is still approved\n        const { approved } = await isUserApproved(connection.twitterHandle)\n        if (!approved) {\n          await interaction.editReply('❌ Your Twitter account is no longer approved. Please contact an admin.')\n          return\n        }\n        \n        // Check tier scenarios\n        const scenarios = await getTierScenarios(connection.tier)\n        \n        // Check daily limit\n        const today = new Date().toISOString().split('T')[0]\n        const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n        \n        if (dailySubmissions >= scenarios.dailyTweetLimit) {\n          await interaction.editReply(`❌ You've reached your daily limit of ${scenarios.dailyTweetLimit} tweets for Tier ${connection.tier}.`)\n          return\n        }\n        \n        // Check for duplicate\n        const isDuplicate = await redis.exists(`engagement:tweetid:${tweetId}`)\n        if (isDuplicate) {\n          await interaction.editReply('❌ This tweet has already been submitted.')\n          return\n        }\n        \n        // Extract author handle\n        const authorHandle = extractTwitterHandle(url)\n        \n        // Check if submitter is author or admin\n        const member = interaction.guild.members.cache.get(interaction.user.id)\n        const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n        \n        if (!isAdmin && connection.twitterHandle !== authorHandle) {\n          await interaction.editReply('❌ You can only submit your own tweets. Admins can submit any tweet.')\n          return\n        }\n        \n        // Validate category\n        let finalCategory = category\n        if (category && !scenarios.categories.includes(category)) {\n          await interaction.editReply(`❌ Invalid category. Available categories for Tier ${connection.tier}: ${scenarios.categories.join(', ')}`)\n          return\n        }\n        \n        if (!finalCategory) {\n          finalCategory = 'General'\n        }\n        \n        // Submit tweet\n        try {\n          const { nanoid } = await import('nanoid')\n          // Try to fetch tweet content from Twitter API\n          let tweetContent = null\n          try {\n            const response = await fetch(`https://api.twitter.com/2/tweets/${tweetId}?tweet.fields=text`, {\n              headers: {\n                'Authorization': `Bearer ${process.env.TWITTER_BEARER_TOKEN}`\n              }\n            })\n            \n            if (response.ok) {\n              const tweetData = await response.json()\n              tweetContent = tweetData.data?.text || null\n              console.log('📝 Fetched tweet content:', tweetContent ? 'Success' : 'No content')\n            }\n          } catch (error) {\n            console.log('⚠️ Could not fetch tweet content:', error.message)\n          }\n\n          const tweet = {\n            id: nanoid(),\n            tweetId,\n            submitterDiscordId: interaction.user.id,\n            submittedAt: new Date(),\n            category: finalCategory,\n            url,\n            authorHandle,\n            content: tweetContent,\n            tier: connection.tier,\n            bonusMultiplier: scenarios.bonusMultiplier\n          }\n          \n          await redis.json.set(`engagement:tweet:${tweet.id}`, '$', tweet)\n          // Store in sorted set for admin panel compatibility\n          await redis.zadd('engagement:tweets:recent', { score: Date.now(), member: tweet.id })\n          await redis.set(`engagement:tweetid:${tweet.tweetId}`, tweet.id)\n          \n          // Increment daily counter\n          await redis.incr(`engagement:daily:${interaction.user.id}:${today}`)\n          await redis.expire(`engagement:daily:${interaction.user.id}:${today}`, 86400) // 24 hours\n          \n          // Send to channel\n          const channel = interaction.guild.channels.cache.find(ch => ch.name === BOT_CHANNEL_NAME)\n          if (channel) {\n            // Debug: Check bot permissions in channel\n            const botMember = interaction.guild.members.cache.get(client.user.id)\n            const perms = channel.permissionsFor(botMember)\n            console.log(`Bot permissions in #${BOT_CHANNEL_NAME}:`, {\n              viewChannel: perms.has('ViewChannel'),\n              sendMessages: perms.has('SendMessages'),\n              embedLinks: perms.has('EmbedLinks'),\n              readMessageHistory: perms.has('ReadMessageHistory'),\n              useExternalEmojis: perms.has('UseExternalEmojis')\n            })\n            try {\n              const messageContent = createTweetEmbed(tweet, interaction.user.username)\n              await channel.send(messageContent)\n              console.log(`✅ Posted tweet preview to #${BOT_CHANNEL_NAME}`)\n            } catch (channelError) {\n              console.error('Error posting to channel:', channelError)\n              console.log('Make sure the bot has permission to send messages in #engagement-tracker')\n              console.log('Required permissions: View Channel, Send Messages, Embed Links')\n              \n              // Try sending without buttons as fallback\n              try {\n                console.log('Attempting to send without buttons...')\n                const simpleEmbed = createTweetEmbed(tweet, interaction.user.username, false)\n                await channel.send(simpleEmbed)\n                console.log('✅ Sent simplified preview without buttons')\n              } catch (fallbackError) {\n                console.error('Even simple embed failed:', fallbackError)\n                console.log('Bot may lack basic permissions in the channel')\n                \n                // Last resort - send plain text\n                try {\n                  const plainMessage = `**@${tweet.authorHandle}**\\n` +\n                    `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n                    `💰 Earn ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | ${tweet.category}\\n` +\n                    `🔗 ${tweet.url}`\n                  await channel.send(plainMessage)\n                  console.log('✅ Sent plain text preview')\n                } catch (textError) {\n                  console.error('Cannot send any message to channel:', textError)\n                }\n              }\n            }\n          } else {\n            console.log(`Channel \"${BOT_CHANNEL_NAME}\" not found. Please create it for tweet announcements.`)\n          }\n          \n          await interaction.editReply(`✅ Tweet submitted successfully! (${parseInt(dailySubmissions) + 1}/${scenarios.dailyTweetLimit} today)`)\n        } catch (error) {\n          console.error('Error submitting tweet:', error)\n          await interaction.editReply('❌ An error occurred while submitting the tweet. Please try again.')\n        }\n      }\n      \n      else if (commandName === 'stats') {\n        await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n        \n        const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n        if (!connection) {\n          await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n          return\n        }\n        \n        // Get tier scenarios\n        const scenarios = await getTierScenarios(connection.tier)\n        \n        // Get today's submissions\n        const today = new Date().toISOString().split('T')[0]\n        const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n        \n        // Get recent engagements (skip for now since we don't have logs yet)\n        const logs = []\n        \n        const embed = new EmbedBuilder()\n          .setColor(0x00FF00)\n          .setTitle('📊 Your Engagement Stats')\n          .setDescription(`**Twitter:** @${connection.twitterHandle}\\n**Tier:** ${connection.tier ? connection.tier.toUpperCase() : 'MICRO'}\\n**Total Points:** ${connection.totalPoints || 0}`)\n          .addFields(\n            { name: 'Daily Limit', value: `${dailySubmissions}/${scenarios.dailyTweetLimit}`, inline: true },\n            { name: 'Bonus Multiplier', value: `${scenarios.bonusMultiplier}x`, inline: true },\n            { name: 'Categories', value: scenarios.categories.join(', '), inline: false }\n          )\n          .setTimestamp()\n        \n        if (logs.length > 0) {\n          const recentActivity = logs.map(log => \n            `${log.interactionType === 'like' ? '❤️' : log.interactionType === 'retweet' ? '🔁' : '💬'} +${log.points} points`\n          ).join('\\n')\n          embed.addFields({ name: 'Recent Activity', value: recentActivity })\n        }\n        \n        await interaction.editReply({ embeds: [embed] })\n      }\n      \n      else if (commandName === 'leaderboard') {\n        await interaction.deferReply()\n        \n        // Get leaderboard data\n        const keys = await redis.keys('engagement:connection:*')\n        const entries = []\n        \n        for (const key of keys.slice(0, 50)) {\n          const connection = await redis.json.get(key)\n          if (connection) {\n            entries.push({\n              discordId: connection.discordId,\n              twitterHandle: connection.twitterHandle,\n              totalPoints: connection.totalPoints || 0,\n              tier: connection.tier\n            })\n          }\n        }\n        \n        // Sort by points\n        entries.sort((a, b) => b.totalPoints - a.totalPoints)\n        \n        const embed = new EmbedBuilder()\n          .setColor(0xFFD700) // Gold\n          .setTitle('🏆 Engagement Leaderboard')\n          .setDescription('Top 10 Engagers')\n          .setTimestamp()\n        \n        const top10 = entries.slice(0, 10).map((entry, index) => {\n          const tierEmoji = {\n            'micro': '⚪',\n            'rising': '🟢',\n            'star': '⭐',\n            'legend': '🟠',\n            'hero': '👑'\n          }[entry.tier] || '⚪'\n          return `**${index + 1}.** @${entry.twitterHandle} ${tierEmoji} ${entry.tier ? entry.tier.toUpperCase() : 'MICRO'} - ${entry.totalPoints} points`\n        }).join('\\n')\n        \n        embed.addFields({ name: 'Rankings', value: top10 || 'No data yet' })\n        \n        await interaction.editReply({ embeds: [embed] })\n      }\n      \n      else if (commandName === 'recent') {\n        await interaction.deferReply()\n        \n        try {\n          // Get recent tweets from sorted set\n          const tweetIds = await redis.zrange('engagement:tweets:recent', 0, 9, { rev: true }) // Get last 10\n          const tweets = []\n          \n          for (const id of tweetIds) {\n            const tweet = await redis.json.get(`engagement:tweet:${id}`)\n            if (tweet) tweets.push(tweet)\n          }\n          \n          const embed = new EmbedBuilder()\n            .setColor(0x1DA1F2) // Twitter blue\n            .setTitle('🐦 Recent Tweets for Engagement')\n            .setDescription('Click on any tweet to engage and earn points!')\n            .setTimestamp()\n          \n          if (tweets.length === 0) {\n            embed.addFields({ name: 'No tweets yet', value: 'Be the first to submit a tweet with `/submit`!' })\n          } else {\n            let tweetList = ''\n            tweets.forEach((tweet, index) => {\n              tweetList += `**${index + 1}. @${tweet.authorHandle}**\\n`\n              if (tweet.content) {\n                tweetList += `\"${tweet.content.substring(0, 100)}${tweet.content.length > 100 ? '...' : ''}\"\\n`\n              }\n              tweetList += `💰 ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | [View Tweet](${tweet.url})\\n\\n`\n            })\n            embed.addFields({ name: 'Recent Tweets', value: tweetList || 'No tweets yet' })\n          }\n          \n          await interaction.editReply({ embeds: [embed] })\n        } catch (error) {\n          console.error('Error in /recent command:', error)\n          await interaction.editReply('❌ An error occurred while fetching recent tweets.')\n        }\n      }\n      \n      else if (commandName === 'tier') {\n        // Admin only\n        const member = interaction.guild.members.cache.get(interaction.user.id)\n        const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n        \n        if (!isAdmin) {\n          await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n          return\n        }\n        \n        const user = interaction.options.getUser('user')\n        const tier = interaction.options.getString('tier')\n        \n        const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n        if (!validTiers.includes(tier)) {\n          await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n          return\n        }\n        \n        const connection = await redis.json.get(`engagement:connection:${user.id}`)\n        if (!connection) {\n          await interaction.reply({ content: '❌ User has not connected their Twitter account.', flags: 64 })\n          return\n        }\n        \n        await redis.json.set(`engagement:connection:${user.id}`, '$.tier', tier)\n        await interaction.reply({ content: `✅ Updated ${user.username}'s tier to ${tier.toUpperCase()}`, flags: 64 })\n      }\n      \n      else if (commandName === 'scenarios') {\n        // Admin only\n        const member = interaction.guild.members.cache.get(interaction.user.id)\n        const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n        \n        if (!isAdmin) {\n          await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n          return\n        }\n        \n        const tier = interaction.options.getString('tier')\n        const dailyLimit = interaction.options.getInteger('daily_limit')\n        const minFollowers = interaction.options.getInteger('min_followers')\n        const bonusMultiplier = interaction.options.getNumber('bonus_multiplier')\n        \n        const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n        if (!validTiers.includes(tier)) {\n          await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n          return\n        }\n        \n        // Get current scenarios\n        const currentScenarios = await getTierScenarios(tier)\n        \n        // Update with new values\n        if (dailyLimit !== null) currentScenarios.dailyTweetLimit = dailyLimit\n        if (minFollowers !== null) currentScenarios.minFollowers = minFollowers\n        if (bonusMultiplier !== null) currentScenarios.bonusMultiplier = bonusMultiplier\n        \n        // Save scenarios\n        await redis.json.set(`engagement:scenarios:${tier}`, '$', currentScenarios)\n        \n        await interaction.reply({ \n          content: `✅ Updated ${tier.toUpperCase()} tier scenarios:\\n` +\n                   `Daily Limit: ${currentScenarios.dailyTweetLimit}\\n` +\n                   `Min Followers: ${currentScenarios.minFollowers}\\n` +\n                   `Bonus Multiplier: ${currentScenarios.bonusMultiplier}x`,\n          flags: 64 \n        })\n      }\n    }\n    \n    // Handle modal submissions\n    else if (interaction.isModalSubmit()) {\n      if (interaction.customId === 'connect-twitter') {\n        const handle = interaction.fields.getTextInputValue('twitter-handle')\n        const cleanHandle = handle.toLowerCase().replace('@', '').trim()\n        \n        // Check if user is approved\n        const { approved, userData } = await isUserApproved(cleanHandle)\n        if (!approved) {\n          await interaction.reply({ \n            content: '❌ Your Twitter account is not approved. Please apply through the website first.', \n            flags: 64 \n          })\n          return\n        }\n        \n        // Check if handle is already connected\n        const existingDiscordId = await redis.get(`engagement:twitter:${cleanHandle}`)\n        if (existingDiscordId && existingDiscordId !== interaction.user.id) {\n          await interaction.reply({ \n            content: '❌ This Twitter account is already connected to another Discord user.', \n            flags: 64 \n          })\n          return\n        }\n        \n        // Get current role from database\n        const currentRole = userData.role || 'user'\n        \n        // Assign KOL role if user doesn't have a higher role\n        let finalRole = currentRole\n        if (ROLE_HIERARCHY[currentRole] < ROLE_HIERARCHY['kol']) {\n          finalRole = 'kol'\n          await updateUserRole(cleanHandle, 'kol')\n          \n          // Also assign Discord role if available\n          try {\n            const member = await interaction.guild.members.fetch(interaction.user.id)\n            const kolRole = interaction.guild.roles.cache.find(role => role.name.toLowerCase() === KOL_ROLE_NAME)\n            \n            if (kolRole) {\n              // Check if bot has permission to manage roles\n              const botMember = interaction.guild.members.cache.get(client.user.id)\n              if (!botMember.permissions.has('ManageRoles')) {\n                console.warn('⚠️  Bot lacks \"Manage Roles\" permission - cannot assign KOL role')\n                console.log('   Please grant the bot \"Manage Roles\" permission in Discord')\n              } \n              // Check if bot's highest role is above the KOL role\n              else if (botMember.roles.highest.position <= kolRole.position) {\n                console.warn('⚠️  Bot\\'s role is not high enough to assign the KOL role')\n                console.log('   Please move the bot\\'s role above the KOL role in Discord settings')\n              }\n              // Try to assign the role\n              else if (!member.roles.cache.has(kolRole.id)) {\n                await member.roles.add(kolRole)\n                console.log(`✅ Assigned KOL role to ${member.user.tag}`)\n              }\n            } else {\n              console.warn(`⚠️  No role found with name \"${KOL_ROLE_NAME}\" (case-insensitive)`)\n              console.log('   Please create a role named \"kol\" in your Discord server')\n            }\n          } catch (error) {\n            console.error('❌ Error assigning Discord role:', error.message)\n            if (error.code === 50013) {\n              console.log('   This is a permissions issue. Please check:')\n              console.log('   1. Bot has \"Manage Roles\" permission')\n              console.log('   2. Bot\\'s role is above the KOL role in the hierarchy')\n            }\n          }\n        }\n        \n        // Create connection - get tier from user profile\n        const userTier = userData.tier || 'micro'  // Default to micro if no tier\n        const connection = {\n          discordId: interaction.user.id,\n          twitterHandle: cleanHandle,\n          tier: userTier,\n          connectedAt: new Date(),\n          totalPoints: 0,\n          role: finalRole\n        }\n        \n        await redis.json.set(`engagement:connection:${interaction.user.id}`, '$', connection)\n        await redis.set(`engagement:twitter:${cleanHandle}`, interaction.user.id)\n        \n        await interaction.reply({ \n          content: `📝 Your Twitter account @${cleanHandle} has been registered!\\n\\n` +\n                   `⏳ **Your account is pending approval.** An admin will review and approve your account.\\n` +\n                   `📢 You'll be notified once approved and can then use the engagement features.`, \n          flags: 64 \n        })\n      }\n    }\n  } catch (error) {\n    console.error('Error handling interaction:', error)\n    try {\n      if (interaction.replied || interaction.deferred) {\n        await interaction.editReply('❌ An error occurred while processing the interaction. Please try again later.')\n      } else {\n        await interaction.reply({ content: '❌ An error occurred while processing the interaction. Please try again later.', flags: 64 })\n      }\n    } catch (replyError) {\n      console.error('Error sending error message:', replyError)\n    }\n  }\n})\n\n// Error handling\nclient.on('error', console.error)\n\n// Handle regular messages (for ping/pong)\nclient.on('messageCreate', async (message) => {\n  // Log all messages for debugging\n  console.log(`📨 Message received: \"${message.content}\" from ${message.author.tag} in #${message.channel.name}`)\n  \n  // Ignore messages from bots\n  if (message.author.bot) return\n  \n  // Simple ping/pong response\n  if (message.content.toLowerCase() === 'ping' || message.content.toLowerCase() === '!ping') {\n    try {\n      await message.reply('pong! 🏓')\n      console.log(`Replied to ping from ${message.author.tag}`)\n    } catch (error) {\n      console.error('Error replying to ping:', error)\n    }\n  }\n  \n  // Test command\n  if (message.content.toLowerCase() === '!test') {\n    try {\n      await message.reply('Bot is working! Try `/connect` to link your Twitter account.')\n      console.log(`Replied to test from ${message.author.tag}`)\n    } catch (error) {\n      console.error('Error replying to test:', error)\n    }\n  }\n})\n\n// Debug: Log all events\nclient.on('debug', (info) => {\n  if (info.includes('heartbeat') || info.includes('Heartbeat')) return // Skip heartbeat spam\n  console.log(`[DEBUG] ${info}`)\n})\n\n// Login\nconst botToken = process.env.DISCORD_ENGAGEMENT_BOT_TOKEN || process.env.DISCORD_BOT_TOKEN\nif (!botToken) {\n  console.error('❌ No bot token found! Please set DISCORD_ENGAGEMENT_BOT_TOKEN in your .env.local file')\n  process.exit(1)\n}\n\nclient.login(botToken)\n  .then(() => console.log('🚀 Engagement bot starting...'))\n  .catch(console.error)\n\n// Create a new user profile (pending approval)\nasync function createUserProfile(twitterHandle, discordId) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userId = `user:${nanoid()}`\n    \n    const newUser = {\n      id: userId,\n      twitterHandle: `@${normalizedHandle}`,\n      name: normalizedHandle, // Use handle as name initially\n      approvalStatus: 'pending', // Requires admin approval\n      role: 'user', // Default to user role\n      tier: 'micro', // Default tier\n      discordId: discordId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      socialAccounts: {\n        twitter: {\n          handle: normalizedHandle,\n          connected: true\n        }\n      }\n    }\n    \n    // Save to Redis\n    await redis.json.set(userId, '$', newUser)\n    \n    // Create username index\n    await redis.sadd(`idx:username:${normalizedHandle}`, userId)\n    \n    // Add to pending users set (not approved)\n    await redis.sadd('users:pending', userId)\n    \n    console.log(`✅ Created new user profile (pending) for @${normalizedHandle}`)\n    return newUser\n  } catch (error) {\n    console.error('Error creating user profile:', error)\n    throw error\n  }\n} ",
    "fixed": "const { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle, REST, Routes } = require('discord.js')\nconst { config } = require('dotenv')\nconst { Redis } = require('@upstash/redis')\nconst { GoogleGenerativeAI } = require('@google/generative-ai')\nconst path = require('path')\nconst { nanoid } = require('nanoid')\n\n// Load environment variables from parent directory\nconst envPath = path.join(__dirname, '..', '.env.local')\nconsole.log('🔍 Loading environment from:', envPath)\nconfig({ path: envPath })\n\n// Check required environment variables\nconst requiredVars = ['UPSTASH_REDIS_REST_URL', 'UPSTASH_REDIS_REST_TOKEN', 'DISCORD_BOT_TOKEN']\nconst optionalVars = ['GEMINI_API_KEY', 'GOOGLE_AI_API_KEY'] // Try both for compatibility\nconst missingVars = requiredVars.filter(v => !process.env[v])\n\n// Check for Gemini/Google AI key\nconst hasAiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n\nif (missingVars.length > 0) {\n  console.error('❌ Missing required environment variables:', missingVars.join(', '))\n  console.error('🔍 Please check your .env.local file contains:')\n  missingVars.forEach(v => console.error(`   ${v}=your_value_here`))\n  process.exit(1)\n}\n\nif (!hasAiKey) {\n  console.warn('⚠️  No AI API key found (GEMINI_API_KEY or GOOGLE_AI_API_KEY)')\n  console.warn('   Sentiment analysis will be disabled')\n}\n\n// Initialize Redis\nconst redis = new Redis({\n  url: process.env.UPSTASH_REDIS_REST_URL,\n  token: process.env.UPSTASH_REDIS_REST_TOKEN\n})\n\n// Initialize Gemini for sentiment analysis (if available)\nlet genAI = null\nlet model = null\n\nif (hasAiKey) {\n  const apiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n  genAI = new GoogleGenerativeAI(apiKey)\n  model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' })\n  console.log('✅ AI model initialized for sentiment analysis')\n}\n\n// Initialize Discord client\nconst client = new Client({\n  intents: [\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildMessages,\n    GatewayIntentBits.MessageContent,\n    GatewayIntentBits.GuildMessageReactions,\n    GatewayIntentBits.GuildMembers\n  ]\n})\n\n// Tweet URL regex\nconst TWEET_REGEX = /https?:\\/\\/(twitter\\.com|x\\.com)\\/[\\w]+\\/status\\/(\\d+)/i\n\n// Bot configuration\nconst BOT_CHANNEL_NAME = 'engagement-tracker'\nconst ADMIN_ROLE_NAME = 'admin'\nconst KOL_ROLE_NAME = 'kol'\n\n// Role hierarchy (higher number = higher priority)\nconst ROLE_HIERARCHY = {\n  'admin': 4,\n  'core': 3,\n  'team': 2,\n  'kol': 1,\n  'user': 0\n}\n\n// Helper function to extract tweet ID from URL\nfunction extractTweetId(url) {\n  const match = url.match(TWEET_REGEX)\n  return match ? match[2] : null\n}\n\n// Helper function to extract Twitter handle from URL\nfunction extractTwitterHandle(url) {\n  const match = url.match(/https?:\\/\\/(twitter\\.com|x\\.com)\\/([\\w]+)\\/status/)\n  return match ? match[2] : null\n}\n\n// Check if user is approved in the database\nasync function isUserApproved(twitterHandle) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    \n    // Check if user exists via username index\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    if (!userIds || userIds.length === 0) {\n      return { approved: false, userData: null }\n    }\n    \n    // Get user data\n    const userData = await redis.json.get(`user:${userIds[0]}`)\n    if (!userData) {\n      return { approved: false, userData: null }\n    }\n    \n    // Check approval status\n    const isApproved = userData.approvalStatus === 'approved'\n    return { approved: isApproved, userData }\n  } catch (error) {\n    console.error('Error checking user approval:', error)\n    return { approved: false, userData: null }\n  }\n}\n\n// Get user's current role from database\nasync function getUserRole(twitterHandle) {\n  try {\n    const { approved, userData } = await isUserApproved(twitterHandle)\n    if (!approved || !userData) return 'user'\n    \n    return userData.role || 'user'\n  } catch (error) {\n    console.error('Error getting user role:', error)\n    return 'user'\n  }\n}\n\n// Update user's role in database\nasync function updateUserRole(twitterHandle, newRole) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    \n    if (userIds && userIds.length > 0) {\n      await redis.json.set(`user:${userIds[0]}`, '$.role', newRole)\n      return true\n    }\n    return false\n  } catch (error) {\n    console.error('Error updating user role:', error)\n    return false\n  }\n}\n\n// Get tier-based scenarios\nasync function getTierScenarios(tier) {\n  try {\n    const safeTier = tier || 'micro' // Default to micro if tier is null/undefined\n    const scenarios = await redis.json.get(`engagement:scenarios:${safeTier}`)\n    return scenarios || getDefaultScenarios(safeTier)\n  } catch (error) {\n    console.error('Error getting tier scenarios:', error)\n    return getDefaultScenarios(tier || 'micro')\n  }\n}\n\n// Default scenarios by tier\nfunction getDefaultScenarios(tier) {\n  const scenarios = {\n    'micro': {\n      dailyTweetLimit: 5,\n      categories: ['General', 'DeFi', 'NFT'],\n      minFollowers: 100,\n      bonusMultiplier: 1.0\n    },\n    'rising': {\n      dailyTweetLimit: 10,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech'],\n      minFollowers: 500,\n      bonusMultiplier: 1.5\n    },\n    'star': {\n      dailyTweetLimit: 20,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News'],\n      minFollowers: 1000,\n      bonusMultiplier: 2.0\n    },\n    'legend': {\n      dailyTweetLimit: 30,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special'],\n      minFollowers: 5000,\n      bonusMultiplier: 2.5\n    },\n    'hero': {\n      dailyTweetLimit: 50,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special', 'VIP'],\n      minFollowers: 10000,\n      bonusMultiplier: 3.0\n    }\n  }\n  \n  return scenarios[tier] || scenarios['micro']\n}\n\n// Create minimal tweet embed with preview\nfunction createTweetEmbed(tweet, submitterName, includeButtons = true) {\n  // Choose color based on tier\n  const tierColors = {\n    'micro': 0x6B7280,  // Gray\n    'rising': 0x3BA55D, // Green\n    'star': 0x5865F2,   // Blue\n    'legend': 0xEA580C, // Orange\n    'hero': 0x9333EA    // Purple\n  }\n  \n  // Calculate potential points\n  const likePoints = Math.floor(10 * tweet.bonusMultiplier)\n  const retweetPoints = Math.floor(20 * tweet.bonusMultiplier)\n  const replyPoints = Math.floor(30 * tweet.bonusMultiplier)\n  \n  const embed = new EmbedBuilder()\n    .setColor(tierColors[tweet.tier] || 0x1DA1F2)\n    .setAuthor({ \n      name: `@${tweet.authorHandle}`, \n      url: `https://twitter.com/${tweet.authorHandle}`,\n      iconURL: 'https://abs.twimg.com/icons/apple-touch-icon-192x192.png'\n    })\n    .setDescription(\n      `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n      `**💰 Earn ${tweet.bonusMultiplier}x points:**\\n` +\n      `❤️ Like: ${likePoints} pts | 🔁 RT: ${retweetPoints} pts | 💬 Reply: ${replyPoints} pts`\n    )\n    .addFields(\n      { name: 'Tier', value: `⭐ ${tweet.tier}`, inline: true },\n      { name: 'Category', value: `${tweet.category}`, inline: true },\n      { name: 'Submitted', value: `<t:${Math.floor(new Date(tweet.submittedAt).getTime() / 1000)}:R>`, inline: true }\n    )\n    .setFooter({ text: `Submitted by ${submitterName}` })\n  \n  if (includeButtons) {\n    // Create clickable button for the tweet\n    const row = new ActionRowBuilder()\n      .addComponents(\n        new ButtonBuilder()\n          .setLabel('View & Engage')\n          .setStyle(ButtonStyle.Link)\n          .setURL(tweet.url)\n          .setEmoji('🐦')\n      )\n    \n    return { embeds: [embed], components: [row] }\n  }\n  \n  return { embeds: [embed] }\n}\n\n// Handle slash commands\nclient.on('ready', async () => {\n  console.log(`✅ Engagement bot logged in as ${client.user.tag}`)\n  console.log(`📍 Bot ID: ${client.user.id}`)\n  console.log(`🏠 Guilds: ${client.guilds.cache.map(g => `${g.name} (${g.id})`).join(', ')}`)\n  \n  // Register slash commands\n  const commands = [\n    {\n      name: 'connect',\n      description: 'Connect your Twitter account (must be approved)'\n    },\n    {\n      name: 'test',\n      description: 'Test if the bot is working'\n    },\n    {\n      name: 'submit',\n      description: 'Submit a tweet for engagement tracking',\n      options: [{\n        name: 'url',\n        type: 3, // STRING\n        description: 'The tweet URL',\n        required: true\n      }, {\n        name: 'category',\n        type: 3,\n        description: 'Tweet category (optional)',\n        required: false\n      }]\n    },\n    {\n      name: 'stats',\n      description: 'View your engagement stats'\n    },\n    {\n      name: 'leaderboard',\n      description: 'View the engagement leaderboard'\n    },\n    {\n      name: 'recent',\n      description: 'View recently submitted tweets'\n    },\n    {\n      name: 'tier',\n      description: 'Admin: Set user tier',\n      options: [{\n        name: 'user',\n        type: 6, // USER\n        description: 'The user to update',\n        required: true\n      }, {\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }]\n    },\n    {\n      name: 'scenarios',\n      description: 'Admin: Configure tier scenarios',\n      options: [{\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }, {\n        name: 'daily_limit',\n        type: 4,\n        description: 'Daily tweet limit',\n        required: false\n      }, {\n        name: 'min_followers',\n        type: 4,\n        description: 'Minimum followers required',\n        required: false\n      }, {\n        name: 'bonus_multiplier',\n        type: 10, // DOUBLE\n        description: 'Points bonus multiplier',\n        required: false\n      }]\n    }\n  ]\n  \n  try {\n    // Use REST API for proper command registration\n    const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_ENGAGEMENT_BOT_TOKEN || process.env.DISCORD_BOT_TOKEN)\n    \n    // Register commands to each guild for instant update\n    for (const guild of client.guilds.cache.values()) {\n      await rest.put(\n        Routes.applicationGuildCommands(client.user.id, guild.id),\n        { body: commands }\n      )\n      console.log(`✅ Registered commands to guild: ${guild.name}`)\n    }\n    \n    console.log('✅ Slash commands registered')\n  } catch (error) {\n    console.error('Error registering commands:', error)\n  }\n})\n\n// Handle interactions\nclient.on('interactionCreate', async (interaction) => {\n  try {\n    console.log(`📥 Received interaction: ${interaction.type} - ${interaction.commandName || 'N/A'} from ${interaction.user.tag}`)\n    \n    // Handle slash commands\n    if (interaction.isCommand()) {\n      const { commandName } = interaction\n      console.log(`🔧 Processing command: ${commandName}`)\n      \n      if (commandName === 'connect') {\n        console.log('📱 /connect command triggered')\n        await interaction.deferReply({ flags: 64 })\n        \n        try {\n          // Generate a unique verification session\n          const sessionId = `verify-${interaction.user.id}-${Date.now()}`\n          const sessionKey = `discord:verify:${sessionId}`\n          \n          // Store session data\n          await redis.set(sessionKey, JSON.stringify({\n            discordId: interaction.user.id,\n            discordUsername: interaction.user.username,\n            discordTag: interaction.user.tag,\n            timestamp: Date.now()\n          }), { EX: 600 }) // Expires in 10 minutes\n          \n          // Create verification URL that will use the website's Twitter OAuth\n          const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://www.nabulines.com'\n          const verificationUrl = `${baseUrl}/auth/discord-link?session=${sessionId}`\n          \n          console.log('🔗 Generated OAuth URL:', verificationUrl)\n          \n          const embed = new EmbedBuilder()\n            .setColor(0x1DA1F2) // Twitter blue\n            .setTitle('🔐 Secure Twitter Connection')\n            .setDescription(\n              'To connect your Twitter account, you need to verify ownership through Twitter OAuth.\\n\\n' +\n              '**Click the button below to:**\\n' +\n              '1. Sign in with Twitter (OAuth)\\n' +\n              '2. Authorize the connection\\n' +\n              '3. Your accounts will be linked automatically'\n            )\n            .addFields(\n              { name: '⏱️ Expires In', value: '10 minutes', inline: true },\n              { name: '🔒 Security', value: 'OAuth 2.0', inline: true }\n            )\n            .setFooter({ text: 'Only you can complete this verification' })\n          \n          const row = new ActionRowBuilder()\n            .addComponents(\n              new ButtonBuilder()\n                .setLabel('Verify Twitter Account')\n                .setStyle(ButtonStyle.Link)\n                .setURL(verificationUrl)\n                .setEmoji('🐦')\n            )\n          \n          await interaction.editReply({\n            embeds: [embed],\n            components: [row],\n            flags: 64\n          })\n        } catch (error) {\n          console.error('Error in connect command:', error)\n          await interaction.editReply('❌ An error occurred. Please try again.')\n        }\n      }\n      \n      else if (commandName === 'test') {\n        console.log('🧪 /test command triggered')\n        await interaction.reply({ \n          content: '✅ Bot is working! The /connect command should also work now.', \n          flags: 64 \n        })\n      }\n      \n      else if (commandName === 'submit') {\n        await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n        \n        const url = interaction.options.getString('url')\n        const category = interaction.options.getString('category')\n        \n        // Validate URL\n        const tweetId = extractTweetId(url)\n        if (!tweetId) {\n          await interaction.editReply('❌ Invalid tweet URL. Please provide a valid Twitter/X URL.')\n          return\n        }\n        \n        // Check if user is connected\n        const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n        if (!connection) {\n          await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n          return\n        }\n        \n        // Check if user is still approved\n        const { approved } = await isUserApproved(connection.twitterHandle)\n        if (!approved) {\n          await interaction.editReply('❌ Your Twitter account is no longer approved. Please contact an admin.')\n          return\n        }\n        \n        // Check tier scenarios\n        const scenarios = await getTierScenarios(connection.tier)\n        \n        // Check daily limit\n        const today = new Date().toISOString().split('T')[0]\n        const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n        \n        if (dailySubmissions >= scenarios.dailyTweetLimit) {\n          await interaction.editReply(`❌ You've reached your daily limit of ${scenarios.dailyTweetLimit} tweets for Tier ${connection.tier}.`)\n          return\n        }\n        \n        // Check for duplicate\n        const isDuplicate = await redis.exists(`engagement:tweetid:${tweetId}`)\n        if (isDuplicate) {\n          await interaction.editReply('❌ This tweet has already been submitted.')\n          return\n        }\n        \n        // Extract author handle\n        const authorHandle = extractTwitterHandle(url)\n        \n        // Check if submitter is author or admin\n        const member = interaction.guild.members.cache.get(interaction.user.id)\n        const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n        \n        if (!isAdmin && connection.twitterHandle !== authorHandle) {\n          await interaction.editReply('❌ You can only submit your own tweets. Admins can submit any tweet.')\n          return\n        }\n        \n        // Validate category\n        let finalCategory = category\n        if (category && !scenarios.categories.includes(category)) {\n          await interaction.editReply(`❌ Invalid category. Available categories for Tier ${connection.tier}: ${scenarios.categories.join(', ')}`)\n          return\n        }\n        \n        if (!finalCategory) {\n          finalCategory = 'General'\n        }\n        \n        // Submit tweet\n        try {\n          const { nanoid } = await import('nanoid')\n          // Try to fetch tweet content from Twitter API\n          let tweetContent = null\n          try {\n            const response = await fetch(`https://api.twitter.com/2/tweets/${tweetId}?tweet.fields=text`, {\n              headers: {\n                'Authorization': `Bearer ${process.env.TWITTER_BEARER_TOKEN}`\n              }\n            })\n            \n            if (response.ok) {\n              const tweetData = await response.json()\n              tweetContent = tweetData.data?.text || null\n              console.log('📝 Fetched tweet content:', tweetContent ? 'Success' : 'No content')\n            }\n          } catch (error) {\n            console.log('⚠️ Could not fetch tweet content:', error.message)\n          }\n\n          const tweet = {\n            id: nanoid(),\n            tweetId,\n            submitterDiscordId: interaction.user.id,\n            submittedAt: new Date(),\n            category: finalCategory,\n            url,\n            authorHandle,\n            content: tweetContent,\n            tier: connection.tier,\n            bonusMultiplier: scenarios.bonusMultiplier\n          }\n          \n          await redis.json.set(`engagement:tweet:${tweet.id}`, '$', tweet)\n          // Store in sorted set for admin panel compatibility\n          await redis.zadd('engagement:tweets:recent', { score: Date.now(), member: tweet.id })\n          await redis.set(`engagement:tweetid:${tweet.tweetId}`, tweet.id)\n          \n          // Increment daily counter\n          await redis.incr(`engagement:daily:${interaction.user.id}:${today}`)\n          await redis.expire(`engagement:daily:${interaction.user.id}:${today}`, 86400) // 24 hours\n          \n          // Send to channel\n          const channel = interaction.guild.channels.cache.find(ch => ch.name === BOT_CHANNEL_NAME)\n          if (channel) {\n            // Debug: Check bot permissions in channel\n            const botMember = interaction.guild.members.cache.get(client.user.id)\n            const perms = channel.permissionsFor(botMember)\n            console.log(`Bot permissions in #${BOT_CHANNEL_NAME}:`, {\n              viewChannel: perms.has('ViewChannel'),\n              sendMessages: perms.has('SendMessages'),\n              embedLinks: perms.has('EmbedLinks'),\n              readMessageHistory: perms.has('ReadMessageHistory'),\n              useExternalEmojis: perms.has('UseExternalEmojis')\n            })\n            try {\n              const messageContent = createTweetEmbed(tweet, interaction.user.username)\n              await channel.send(messageContent)\n              console.log(`✅ Posted tweet preview to #${BOT_CHANNEL_NAME}`)\n            } catch (channelError) {\n              console.error('Error posting to channel:', channelError)\n              console.log('Make sure the bot has permission to send messages in #engagement-tracker')\n              console.log('Required permissions: View Channel, Send Messages, Embed Links')\n              \n              // Try sending without buttons as fallback\n              try {\n                console.log('Attempting to send without buttons...')\n                const simpleEmbed = createTweetEmbed(tweet, interaction.user.username, false)\n                await channel.send(simpleEmbed)\n                console.log('✅ Sent simplified preview without buttons')\n              } catch (fallbackError) {\n                console.error('Even simple embed failed:', fallbackError)\n                console.log('Bot may lack basic permissions in the channel')\n                \n                // Last resort - send plain text\n                try {\n                  const plainMessage = `**@${tweet.authorHandle}**\\n` +\n                    `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n                    `💰 Earn ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | ${tweet.category}\\n` +\n                    `🔗 ${tweet.url}`\n                  await channel.send(plainMessage)\n                  console.log('✅ Sent plain text preview')\n                } catch (textError) {\n                  console.error('Cannot send any message to channel:', textError)\n                }\n              }\n            }\n          } else {\n            console.log(`Channel \"${BOT_CHANNEL_NAME}\" not found. Please create it for tweet announcements.`)\n          }\n          \n          await interaction.editReply(`✅ Tweet submitted successfully! (${parseInt(dailySubmissions) + 1}/${scenarios.dailyTweetLimit} today)`)\n        } catch (error) {\n          console.error('Error submitting tweet:', error)\n          await interaction.editReply('❌ An error occurred while submitting the tweet. Please try again.')\n        }\n      }\n      \n      else if (commandName === 'stats') {\n        await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n        \n        const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n        if (!connection) {\n          await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n          return\n        }\n        \n        // Get tier scenarios\n        const scenarios = await getTierScenarios(connection.tier)\n        \n        // Get today's submissions\n        const today = new Date().toISOString().split('T')[0]\n        const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n        \n        // Get recent engagements (skip for now since we don't have logs yet)\n        const logs = []\n        \n        const embed = new EmbedBuilder()\n          .setColor(0x00FF00)\n          .setTitle('📊 Your Engagement Stats')\n          .setDescription(`**Twitter:** @${connection.twitterHandle}\\n**Tier:** ${connection.tier ? connection.tier.toUpperCase() : 'MICRO'}\\n**Total Points:** ${connection.totalPoints || 0}`)\n          .addFields(\n            { name: 'Daily Limit', value: `${dailySubmissions}/${scenarios.dailyTweetLimit}`, inline: true },\n            { name: 'Bonus Multiplier', value: `${scenarios.bonusMultiplier}x`, inline: true },\n            { name: 'Categories', value: scenarios.categories.join(', '), inline: false }\n          )\n          .setTimestamp()\n        \n        if (logs.length > 0) {\n          const recentActivity = logs.map(log => \n            `${log.interactionType === 'like' ? '❤️' : log.interactionType === 'retweet' ? '🔁' : '💬'} +${log.points} points`\n          ).join('\\n')\n          embed.addFields({ name: 'Recent Activity', value: recentActivity })\n        }\n        \n        await interaction.editReply({ embeds: [embed] })\n      }\n      \n      else if (commandName === 'leaderboard') {\n        await interaction.deferReply()\n        \n        // Get leaderboard data\n        const keys = await redis.keys('engagement:connection:*')\n        const entries = []\n        \n        for (const key of keys.slice(0, 50)) {\n          const connection = await redis.json.get(key)\n          if (connection) {\n            entries.push({\n              discordId: connection.discordId,\n              twitterHandle: connection.twitterHandle,\n              totalPoints: connection.totalPoints || 0,\n              tier: connection.tier\n            })\n          }\n        }\n        \n        // Sort by points\n        entries.sort((a, b) => b.totalPoints - a.totalPoints)\n        \n        const embed = new EmbedBuilder()\n          .setColor(0xFFD700) // Gold\n          .setTitle('🏆 Engagement Leaderboard')\n          .setDescription('Top 10 Engagers')\n          .setTimestamp()\n        \n        const top10 = entries.slice(0, 10).map((entry, index) => {\n          const tierEmoji = {\n            'micro': '⚪',\n            'rising': '🟢',\n            'star': '⭐',\n            'legend': '🟠',\n            'hero': '👑'\n          }[entry.tier] || '⚪'\n          return `**${index + 1}.** @${entry.twitterHandle} ${tierEmoji} ${entry.tier ? entry.tier.toUpperCase() : 'MICRO'} - ${entry.totalPoints} points`\n        }).join('\\n')\n        \n        embed.addFields({ name: 'Rankings', value: top10 || 'No data yet' })\n        \n        await interaction.editReply({ embeds: [embed] })\n      }\n      \n      else if (commandName === 'recent') {\n        await interaction.deferReply()\n        \n        try {\n          // Get recent tweets from sorted set\n          const tweetIds = await redis.zrange('engagement:tweets:recent', 0, 9, { rev: true }) // Get last 10\n          const tweets = []\n          \n          for (const id of tweetIds) {\n            const tweet = await redis.json.get(`engagement:tweet:${id}`)\n            if (tweet) tweets.push(tweet)\n          }\n          \n          const embed = new EmbedBuilder()\n            .setColor(0x1DA1F2) // Twitter blue\n            .setTitle('🐦 Recent Tweets for Engagement')\n            .setDescription('Click on any tweet to engage and earn points!')\n            .setTimestamp()\n          \n          if (tweets.length === 0) {\n            embed.addFields({ name: 'No tweets yet', value: 'Be the first to submit a tweet with `/submit`!' })\n          } else {\n            let tweetList = ''\n            tweets.forEach((tweet, index) => {\n              tweetList += `**${index + 1}. @${tweet.authorHandle}**\\n`\n              if (tweet.content) {\n                tweetList += `\"${tweet.content.substring(0, 100)}${tweet.content.length > 100 ? '...' : ''}\"\\n`\n              }\n              tweetList += `💰 ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | [View Tweet](${tweet.url})\\n\\n`\n            })\n            embed.addFields({ name: 'Recent Tweets', value: tweetList || 'No tweets yet' })\n          }\n          \n          await interaction.editReply({ embeds: [embed] })\n        } catch (error) {\n          console.error('Error in /recent command:', error)\n          await interaction.editReply('❌ An error occurred while fetching recent tweets.')\n        }\n      }\n      \n      else if (commandName === 'tier') {\n        // Admin only\n        const member = interaction.guild.members.cache.get(interaction.user.id)\n        const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n        \n        if (!isAdmin) {\n          await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n          return\n        }\n        \n        const user = interaction.options.getUser('user')\n        const tier = interaction.options.getString('tier')\n        \n        const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n        if (!validTiers.includes(tier)) {\n          await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n          return\n        }\n        \n        const connection = await redis.json.get(`engagement:connection:${user.id}`)\n        if (!connection) {\n          await interaction.reply({ content: '❌ User has not connected their Twitter account.', flags: 64 })\n          return\n        }\n        \n        await redis.json.set(`engagement:connection:${user.id}`, '$.tier', tier)\n        await interaction.reply({ content: `✅ Updated ${user.username}'s tier to ${tier.toUpperCase()}`, flags: 64 })\n      }\n      \n      else if (commandName === 'scenarios') {\n        // Admin only\n        const member = interaction.guild.members.cache.get(interaction.user.id)\n        const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n        \n        if (!isAdmin) {\n          await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n          return\n        }\n        \n        const tier = interaction.options.getString('tier')\n        const dailyLimit = interaction.options.getInteger('daily_limit')\n        const minFollowers = interaction.options.getInteger('min_followers')\n        const bonusMultiplier = interaction.options.getNumber('bonus_multiplier')\n        \n        const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n        if (!validTiers.includes(tier)) {\n          await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n          return\n        }\n        \n        // Get current scenarios\n        const currentScenarios = await getTierScenarios(tier)\n        \n        // Update with new values\n        if (dailyLimit !== null) currentScenarios.dailyTweetLimit = dailyLimit\n        if (minFollowers !== null) currentScenarios.minFollowers = minFollowers\n        if (bonusMultiplier !== null) currentScenarios.bonusMultiplier = bonusMultiplier\n        \n        // Save scenarios\n        await redis.json.set(`engagement:scenarios:${tier}`, '$', currentScenarios)\n        \n        await interaction.reply({ \n          content: `✅ Updated ${tier.toUpperCase()} tier scenarios:\\n` +\n                   `Daily Limit: ${currentScenarios.dailyTweetLimit}\\n` +\n                   `Min Followers: ${currentScenarios.minFollowers}\\n` +\n                   `Bonus Multiplier: ${currentScenarios.bonusMultiplier}x`,\n          flags: 64 \n        })\n      }\n    }\n    \n    // Handle modal submissions\n    else if (interaction.isModalSubmit()) {\n      if (interaction.customId === 'connect-twitter') {\n        const handle = interaction.fields.getTextInputValue('twitter-handle')\n        const cleanHandle = handle.toLowerCase().replace('@', '').trim()\n        \n        // Check if user is approved\n        const { approved, userData } = await isUserApproved(cleanHandle)\n        if (!approved) {\n          await interaction.reply({ \n            content: '❌ Your Twitter account is not approved. Please apply through the website first.', \n            flags: 64 \n          })\n          return\n        }\n        \n        // Check if handle is already connected\n        const existingDiscordId = await redis.get(`engagement:twitter:${cleanHandle}`)\n        if (existingDiscordId && existingDiscordId !== interaction.user.id) {\n          await interaction.reply({ \n            content: '❌ This Twitter account is already connected to another Discord user.', \n            flags: 64 \n          })\n          return\n        }\n        \n        // Get current role from database\n        const currentRole = userData.role || 'user'\n        \n        // Assign KOL role if user doesn't have a higher role\n        let finalRole = currentRole\n        if (ROLE_HIERARCHY[currentRole] < ROLE_HIERARCHY['kol']) {\n          finalRole = 'kol'\n          await updateUserRole(cleanHandle, 'kol')\n          \n          // Also assign Discord role if available\n          try {\n            const member = await interaction.guild.members.fetch(interaction.user.id)\n            const kolRole = interaction.guild.roles.cache.find(role => role.name.toLowerCase() === KOL_ROLE_NAME)\n            \n            if (kolRole) {\n              // Check if bot has permission to manage roles\n              const botMember = interaction.guild.members.cache.get(client.user.id)\n              if (!botMember.permissions.has('ManageRoles')) {\n                console.warn('⚠️  Bot lacks \"Manage Roles\" permission - cannot assign KOL role')\n                console.log('   Please grant the bot \"Manage Roles\" permission in Discord')\n              } \n              // Check if bot's highest role is above the KOL role\n              else if (botMember.roles.highest.position <= kolRole.position) {\n                console.warn('⚠️  Bot\\'s role is not high enough to assign the KOL role')\n                console.log('   Please move the bot\\'s role above the KOL role in Discord settings')\n              }\n              // Try to assign the role\n              else if (!member.roles.cache.has(kolRole.id)) {\n                await member.roles.add(kolRole)\n                console.log(`✅ Assigned KOL role to ${member.user.tag}`)\n              }\n            } else {\n              console.warn(`⚠️  No role found with name \"${KOL_ROLE_NAME}\" (case-insensitive)`)\n              console.log('   Please create a role named \"kol\" in your Discord server')\n            }\n          } catch (error) {\n            console.error('❌ Error assigning Discord role:', error.message)\n            if (error.code === 50013) {\n              console.log('   This is a permissions issue. Please check:')\n              console.log('   1. Bot has \"Manage Roles\" permission')\n              console.log('   2. Bot\\'s role is above the KOL role in the hierarchy')\n            }\n          }\n        }\n        \n        // Create connection - get tier from user profile\n        const userTier = userData.tier || 'micro'  // Default to micro if no tier\n        const connection = {\n          discordId: interaction.user.id,\n          twitterHandle: cleanHandle,\n          tier: userTier,\n          connectedAt: new Date(),\n          totalPoints: 0,\n          role: finalRole\n        }\n        \n        await redis.json.set(`engagement:connection:${interaction.user.id}`, '$', connection)\n        await redis.set(`engagement:twitter:${cleanHandle}`, interaction.user.id)\n        \n        await interaction.reply({ \n          content: `📝 Your Twitter account @${cleanHandle} has been registered!\\n\\n` +\n                   `⏳ **Your account is pending approval.** An admin will review and approve your account.\\n` +\n                   `📢 You'll be notified once approved and can then use the engagement features.`, \n          flags: 64 \n        })\n      }\n    }\n  } catch (error) {\n    console.error('Error handling interaction:', error)\n    try {\n      if (interaction.replied || interaction.deferred) {\n        await interaction.editReply('❌ An error occurred while processing the interaction. Please try again later.')\n      } else {\n        await interaction.reply({ content: '❌ An error occurred while processing the interaction. Please try again later.', flags: 64 })\n      }\n    } catch (replyError) {\n      console.error('Error sending error message:', replyError)\n    }\n  }\n})\n\n// Error handling\nclient.on('error', console.error)\n\n// Handle regular messages (for ping/pong)\nclient.on('messageCreate', async (message) => {\n  // Log all messages for debugging\n  console.log(`📨 Message received: \"${message.content}\" from ${message.author.tag} in #${message.channel.name}`)\n  \n  // Ignore messages from bots\n  if (message.author.bot) return\n  \n  // Simple ping/pong response\n  if (message.content.toLowerCase() === 'ping' || message.content.toLowerCase() === '!ping') {\n    try {\n      await message.reply('pong! 🏓')\n      console.log(`Replied to ping from ${message.author.tag}`)\n    } catch (error) {\n      console.error('Error replying to ping:', error)\n    }\n  }\n  \n  // Test command\n  if (message.content.toLowerCase() === '!test') {\n    try {\n      await message.reply('Bot is working! Try `/connect` to link your Twitter account.')\n      console.log(`Replied to test from ${message.author.tag}`)\n    } catch (error) {\n      console.error('Error replying to test:', error)\n    }\n  }\n})\n\n// Debug: Log all events\nclient.on('debug', (info) => {\n  if (info.includes('heartbeat') || info.includes('Heartbeat')) return // Skip heartbeat spam\n  console.log(`[DEBUG] ${info}`)\n})\n\n// Login\nconst botToken = process.env.DISCORD_ENGAGEMENT_BOT_TOKEN || process.env.DISCORD_BOT_TOKEN\nif (!botToken) {\n  console.error('❌ No bot token found! Please set DISCORD_ENGAGEMENT_BOT_TOKEN in your .env.local file')\n  process.exit(1)\n}\n\nclient.login(botToken)\n  .then(() => console.log('🚀 Engagement bot starting...'))\n  .catch(console.error)\n\n// Create a new user profile (pending approval)\nasync function createUserProfile(twitterHandle, discordId) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userId = `user_${normalizedHandle}`\n    \n    const newUser = {\n      id: userId,\n      twitterHandle: `@${normalizedHandle}`,\n      name: normalizedHandle, // Use handle as name initially\n      approvalStatus: 'pending', // Requires admin approval\n      role: 'user', // Default to user role\n      tier: 'micro', // Default tier\n      discordId: discordId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      socialAccounts: {\n        twitter: {\n          handle: normalizedHandle,\n          connected: true\n        }\n      }\n    }\n    \n    // Save to Redis\n    await redis.json.set(userId, '$', newUser)\n    \n    // Create username index\n    await redis.sadd(`idx:username:${normalizedHandle}`, userId)\n    \n    // Add to pending users set (not approved)\n    await redis.sadd('users:pending', userId)\n    \n    console.log(`✅ Created new user profile (pending) for @${normalizedHandle}`)\n    return newUser\n  } catch (error) {\n    console.error('Error creating user profile:', error)\n    throw error\n  }\n} "
  },
  {
    "file": "discord-bots/engagement-bot-presecure.js",
    "original": "const { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle } = require('discord.js')\nconst { config } = require('dotenv')\nconst { Redis } = require('@upstash/redis')\nconst { GoogleGenerativeAI } = require('@google/generative-ai')\nconst path = require('path')\nconst { nanoid } = require('nanoid')\n\n// Load environment variables from parent directory\nconst envPath = path.join(__dirname, '..', '.env.local')\nconsole.log('🔍 Loading environment from:', envPath)\nconfig({ path: envPath })\n\n// Check required environment variables\nconst requiredVars = ['UPSTASH_REDIS_REST_URL', 'UPSTASH_REDIS_REST_TOKEN', 'DISCORD_BOT_TOKEN']\nconst optionalVars = ['GEMINI_API_KEY', 'GOOGLE_AI_API_KEY'] // Try both for compatibility\nconst missingVars = requiredVars.filter(v => !process.env[v])\n\n// Check for Gemini/Google AI key\nconst hasAiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n\nif (missingVars.length > 0) {\n  console.error('❌ Missing required environment variables:', missingVars.join(', '))\n  console.error('🔍 Please check your .env.local file contains:')\n  missingVars.forEach(v => console.error(`   ${v}=your_value_here`))\n  process.exit(1)\n}\n\nif (!hasAiKey) {\n  console.warn('⚠️  No AI API key found (GEMINI_API_KEY or GOOGLE_AI_API_KEY)')\n  console.warn('   Sentiment analysis will be disabled')\n}\n\n// Initialize Redis\nconst redis = new Redis({\n  url: process.env.UPSTASH_REDIS_REST_URL,\n  token: process.env.UPSTASH_REDIS_REST_TOKEN\n})\n\n// Initialize Gemini for sentiment analysis (if available)\nlet genAI = null\nlet model = null\n\nif (hasAiKey) {\n  const apiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n  genAI = new GoogleGenerativeAI(apiKey)\n  model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' })\n  console.log('✅ AI model initialized for sentiment analysis')\n}\n\n// Initialize Discord client\nconst client = new Client({\n  intents: [\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildMessages,\n    GatewayIntentBits.MessageContent,\n    GatewayIntentBits.GuildMessageReactions,\n    GatewayIntentBits.GuildMembers\n  ]\n})\n\n// Tweet URL regex\nconst TWEET_REGEX = /https?:\\/\\/(twitter\\.com|x\\.com)\\/[\\w]+\\/status\\/(\\d+)/i\n\n// Bot configuration\nconst BOT_CHANNEL_NAME = 'engagement-tracker'\nconst ADMIN_ROLE_NAME = 'admin'\nconst KOL_ROLE_NAME = 'kol'\n\n// Role hierarchy (higher number = higher priority)\nconst ROLE_HIERARCHY = {\n  'admin': 4,\n  'core': 3,\n  'team': 2,\n  'kol': 1,\n  'user': 0\n}\n\n// Helper function to extract tweet ID from URL\nfunction extractTweetId(url) {\n  const match = url.match(TWEET_REGEX)\n  return match ? match[2] : null\n}\n\n// Helper function to extract Twitter handle from URL\nfunction extractTwitterHandle(url) {\n  const match = url.match(/https?:\\/\\/(twitter\\.com|x\\.com)\\/([\\w]+)\\/status/)\n  return match ? match[2] : null\n}\n\n// Create a new user profile (pending approval)\nasync function createUserProfile(twitterHandle, discordId) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userId = `user:${nanoid()}`\n    \n    const newUser = {\n      id: userId,\n      twitterHandle: `@${normalizedHandle}`,\n      name: normalizedHandle, // Use handle as name initially\n      approvalStatus: 'pending', // Set to pending, requiring admin approval\n      role: 'user', // Default to user role\n      tier: 'micro', // Default tier\n      discordId: discordId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      socialAccounts: {\n        twitter: {\n          handle: normalizedHandle,\n          connected: true\n        }\n      }\n    }\n    \n    // Save to Redis\n    await redis.json.set(userId, '$', newUser)\n    \n    // Create username index\n    await redis.sadd(`idx:username:${normalizedHandle}`, userId)\n    \n    // Add to pending users set (not approved)\n    await redis.sadd('users:pending', userId)\n    \n    console.log(`✅ Created new user profile (pending) for @${normalizedHandle}`)\n    return newUser\n  } catch (error) {\n    console.error('Error creating user profile:', error)\n    throw error\n  }\n}\n\n\n// Check if user is approved in the database\nasync function isUserApproved(twitterHandle) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    \n    // Check if user exists via username index\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    if (!userIds || userIds.length === 0) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Get user data\n    const userData = await redis.json.get(`user:${userIds[0]}`)\n    if (!userData) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Check approval status\n    const isApproved = userData.approvalStatus === 'approved'\n    return { approved: isApproved, userData, exists: true }\n  } catch (error) {\n    console.error('Error checking user approval:', error)\n    return { approved: false, userData: null, exists: false }\n  }\n}\n\n// Get user's current role from database\nasync function getUserRole(twitterHandle) {\n  try {\n    const { approved, userData } = await isUserApproved(twitterHandle)\n    if (!approved || !userData) return 'user'\n    \n    return userData.role || 'user'\n  } catch (error) {\n    console.error('Error getting user role:', error)\n    return 'user'\n  }\n}\n\n// Update user's role in database\nasync function updateUserRole(twitterHandle, newRole) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    \n    if (userIds && userIds.length > 0) {\n      await redis.json.set(`user:${userIds[0]}`, '$.role', newRole)\n      return true\n    }\n    return false\n  } catch (error) {\n    console.error('Error updating user role:', error)\n    return false\n  }\n}\n\n// Get tier-based scenarios\nasync function getTierScenarios(tier) {\n  try {\n    const safeTier = tier || 'micro' // Default to micro if tier is null/undefined\n    const scenarios = await redis.json.get(`engagement:scenarios:${safeTier}`)\n    return scenarios || getDefaultScenarios(safeTier)\n  } catch (error) {\n    console.error('Error getting tier scenarios:', error)\n    return getDefaultScenarios(tier || 'micro')\n  }\n}\n\n// Default scenarios by tier\nfunction getDefaultScenarios(tier) {\n  const scenarios = {\n    'micro': {\n      dailyTweetLimit: 5,\n      categories: ['General', 'DeFi', 'NFT'],\n      minFollowers: 100,\n      bonusMultiplier: 1.0\n    },\n    'rising': {\n      dailyTweetLimit: 10,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech'],\n      minFollowers: 500,\n      bonusMultiplier: 1.5\n    },\n    'star': {\n      dailyTweetLimit: 20,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News'],\n      minFollowers: 1000,\n      bonusMultiplier: 2.0\n    },\n    'legend': {\n      dailyTweetLimit: 30,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special'],\n      minFollowers: 5000,\n      bonusMultiplier: 2.5\n    },\n    'hero': {\n      dailyTweetLimit: 50,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special', 'VIP'],\n      minFollowers: 10000,\n      bonusMultiplier: 3.0\n    }\n  }\n  \n  return scenarios[tier] || scenarios['micro']\n}\n\n// Create minimal tweet embed with preview\nfunction createTweetEmbed(tweet, submitterName, includeButtons = true) {\n  // Choose color based on tier\n  const tierColors = {\n    'micro': 0x6B7280,  // Gray\n    'rising': 0x3BA55D, // Green\n    'star': 0x5865F2,   // Blue\n    'legend': 0xEA580C, // Orange\n    'hero': 0x9333EA    // Purple\n  }\n  \n  // Calculate potential points\n  const likePoints = Math.floor(10 * tweet.bonusMultiplier)\n  const retweetPoints = Math.floor(20 * tweet.bonusMultiplier)\n  const replyPoints = Math.floor(30 * tweet.bonusMultiplier)\n  \n  const embed = new EmbedBuilder()\n    .setColor(tierColors[tweet.tier] || 0x1DA1F2)\n    .setAuthor({ \n      name: `@${tweet.authorHandle}`, \n      url: `https://twitter.com/${tweet.authorHandle}`,\n      iconURL: 'https://abs.twimg.com/icons/apple-touch-icon-192x192.png'\n    })\n    .setDescription(\n      `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n      `**💰 Earn ${tweet.bonusMultiplier}x points:**\\n` +\n      `❤️ Like: ${likePoints} pts | 🔁 RT: ${retweetPoints} pts | 💬 Reply: ${replyPoints} pts`\n    )\n    .addFields(\n      { name: 'Tier', value: `⭐ ${tweet.tier}`, inline: true },\n      { name: 'Category', value: `${tweet.category}`, inline: true },\n      { name: 'Submitted', value: `<t:${Math.floor(new Date(tweet.submittedAt).getTime() / 1000)}:R>`, inline: true }\n    )\n    .setFooter({ text: `Submitted by ${submitterName}` })\n  \n  if (includeButtons) {\n    // Create clickable button for the tweet\n    const row = new ActionRowBuilder()\n      .addComponents(\n        new ButtonBuilder()\n          .setLabel('View & Engage')\n          .setStyle(ButtonStyle.Link)\n          .setURL(tweet.url)\n          .setEmoji('🐦')\n      )\n    \n    return { embeds: [embed], components: [row] }\n  }\n  \n  return { embeds: [embed] }\n}\n\n// Handle slash commands\nclient.on('ready', async () => {\n  console.log(`✅ Engagement bot logged in as ${client.user.tag}`)\n  \n  // Start checking for channel info requests\n  setInterval(async () => {\n    try {\n      // Look for any channel info requests\n      const keys = await redis.keys('discord:channel-info-request:*')\n      \n      for (const key of keys) {\n        const request = await redis.get(key)\n        if (!request) continue\n        \n        let channelId, serverId, projectId\n        try {\n          // Upstash Redis returns the parsed object directly\n          const parsed = typeof request === 'string' ? JSON.parse(request) : request\n          channelId = parsed.channelId\n          serverId = parsed.serverId\n          projectId = parsed.projectId\n        } catch (parseError) {\n          console.error(`Error parsing channel info request from ${key}:`, parseError)\n          console.error('Raw request data:', request)\n          await redis.del(key)\n          continue\n        }\n        \n        // Try to fetch the channel\n        try {\n          console.log(`[DEBUG] Looking for guild ${serverId}`)\n          console.log(`[DEBUG] Available guilds: ${client.guilds.cache.map(g => `${g.name} (${g.id})`).join(', ')}`)\n          \n          const guild = client.guilds.cache.get(serverId)\n          if (!guild) {\n            console.log(`Guild ${serverId} not found in cache`)\n            continue\n          }\n          \n          const channel = guild.channels.cache.get(channelId)\n          if (channel) {\n            // Store the response\n            const responseKey = `discord:channel-info-response:${channelId}`\n            await redis.set(responseKey, JSON.stringify({\n              id: channelId,\n              name: channel.name,\n              type: channel.type === 0 ? 'text' : 'voice'\n            }), {\n              ex: 60 // expire in 60 seconds\n            })\n            \n            // Also store permanent channel metadata\n            const channelMetadataKey = `channel:discord:${channelId}`\n            await redis.json.set(channelMetadataKey, '$', {\n              id: channelId,\n              name: channel.name,\n              type: channel.type === 0 ? 'text' : 'voice',\n              projectId: projectId || null,\n              updatedAt: new Date().toISOString()\n            })\n            \n            console.log(`✅ Fetched channel info: #${channel.name} (${channelId})`)\n          } else {\n            console.log(`Channel ${channelId} not found in guild ${serverId}`)\n          }\n        } catch (error) {\n          console.error(`Error fetching channel ${channelId}:`, error)\n        }\n        \n        // Delete the request\n        await redis.del(key)\n      }\n    } catch (error) {\n      console.error('Error processing channel info requests:', error)\n    }\n  }, 2000) // Check every 2 seconds\n  \n  // Register slash commands\n  const commands = [\n    {\n      name: 'connect',\n      description: 'Connect your Twitter account (must be approved)'\n    },\n    {\n      name: 'submit',\n      description: 'Submit a tweet for engagement tracking',\n      options: [{\n        name: 'url',\n        type: 3, // STRING\n        description: 'The tweet URL',\n        required: true\n      }, {\n        name: 'category',\n        type: 3,\n        description: 'Tweet category (optional)',\n        required: false\n      }]\n    },\n    {\n      name: 'stats',\n      description: 'View your engagement stats'\n    },\n    {\n      name: 'leaderboard',\n      description: 'View the engagement leaderboard'\n    },\n    {\n      name: 'recent',\n      description: 'View recently submitted tweets'\n    },\n    {\n      name: 'tier',\n      description: 'Admin: Set user tier',\n      options: [{\n        name: 'user',\n        type: 6, // USER\n        description: 'The user to update',\n        required: true\n      }, {\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }]\n    },\n    {\n      name: 'scenarios',\n      description: 'Admin: Configure tier scenarios',\n      options: [{\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }, {\n        name: 'daily_limit',\n        type: 4,\n        description: 'Daily tweet limit',\n        required: false\n      }, {\n        name: 'min_followers',\n        type: 4,\n        description: 'Minimum followers required',\n        required: false\n      }, {\n        name: 'bonus_multiplier',\n        type: 10, // DOUBLE\n        description: 'Points bonus multiplier',\n        required: false\n      }]\n    }\n  ]\n  \n  try {\n    await client.application.commands.set(commands)\n    console.log('✅ Slash commands registered')\n  } catch (error) {\n    console.error('Error registering commands:', error)\n  }\n})\n\n// Handle interactions\nclient.on('interactionCreate', async (interaction) => {\n  // Handle slash commands\n  if (interaction.isCommand()) {\n    const { commandName } = interaction\n    \n    if (commandName === 'connect') {\n      // Show modal for Twitter handle input\n      const modal = new ModalBuilder()\n        .setCustomId('connect-twitter')\n        .setTitle('Connect Twitter Account')\n      \n      const handleInput = new TextInputBuilder()\n        .setCustomId('twitter-handle')\n        .setLabel('Your Twitter Handle')\n        .setPlaceholder('@yourusername')\n        .setStyle(TextInputStyle.Short)\n        .setRequired(true)\n      \n      const row = new ActionRowBuilder().addComponents(handleInput)\n      modal.addComponents(row)\n      \n      await interaction.showModal(modal)\n    }\n    \n    else if (commandName === 'submit') {\n      await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n      \n      const url = interaction.options.getString('url')\n      const category = interaction.options.getString('category')\n      \n      // Validate URL\n      const tweetId = extractTweetId(url)\n      if (!tweetId) {\n        await interaction.editReply('❌ Invalid tweet URL. Please provide a valid Twitter/X URL.')\n        return\n      }\n      \n      // Check if user is connected\n      const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n      if (!connection) {\n        await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n        return\n      }\n      \n      // Check if user is still approved\n      const { approved } = await isUserApproved(connection.twitterHandle)\n      if (!approved) {\n        await interaction.editReply('❌ Your Twitter account is no longer approved. Please contact an admin.')\n        return\n      }\n      \n      // Check tier scenarios\n      const scenarios = await getTierScenarios(connection.tier)\n      \n      // Check daily limit\n      const today = new Date().toISOString().split('T')[0]\n      const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n      \n      if (dailySubmissions >= scenarios.dailyTweetLimit) {\n        await interaction.editReply(`❌ You've reached your daily limit of ${scenarios.dailyTweetLimit} tweets for Tier ${connection.tier}.`)\n        return\n      }\n      \n      // Check for duplicate\n      const isDuplicate = await redis.exists(`engagement:tweetid:${tweetId}`)\n      if (isDuplicate) {\n        await interaction.editReply('❌ This tweet has already been submitted.')\n        return\n      }\n      \n      // Extract author handle\n      const authorHandle = extractTwitterHandle(url)\n      \n      // Check if submitter is author or admin\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin && connection.twitterHandle !== authorHandle) {\n        await interaction.editReply('❌ You can only submit your own tweets. Admins can submit any tweet.')\n        return\n      }\n      \n      // Validate category\n      let finalCategory = category\n      if (category && !scenarios.categories.includes(category)) {\n        await interaction.editReply(`❌ Invalid category. Available categories for Tier ${connection.tier}: ${scenarios.categories.join(', ')}`)\n        return\n      }\n      \n      if (!finalCategory) {\n        finalCategory = 'General'\n      }\n      \n      // Submit tweet\n      try {\n        const { nanoid } = await import('nanoid')\n        // Try to fetch tweet content from Twitter API\n        let tweetContent = null\n        try {\n          const response = await fetch(`https://api.twitter.com/2/tweets/${tweetId}?tweet.fields=text`, {\n            headers: {\n              'Authorization': `Bearer ${process.env.TWITTER_BEARER_TOKEN}`\n            }\n          })\n          \n          if (response.ok) {\n            const tweetData = await response.json()\n            tweetContent = tweetData.data?.text || null\n            console.log('📝 Fetched tweet content:', tweetContent ? 'Success' : 'No content')\n          }\n        } catch (error) {\n          console.log('⚠️ Could not fetch tweet content:', error.message)\n        }\n\n        const tweet = {\n          id: nanoid(),\n          tweetId,\n          submitterDiscordId: interaction.user.id,\n          submittedAt: new Date(),\n          category: finalCategory,\n          url,\n          authorHandle,\n          content: tweetContent,\n          tier: connection.tier,\n          bonusMultiplier: scenarios.bonusMultiplier\n        }\n        \n        await redis.json.set(`engagement:tweet:${tweet.id}`, '$', tweet)\n        // Store in sorted set for admin panel compatibility\n        await redis.zadd('engagement:tweets:recent', { score: Date.now(), member: tweet.id })\n        await redis.set(`engagement:tweetid:${tweet.tweetId}`, tweet.id)\n        \n        // Increment daily counter\n        await redis.incr(`engagement:daily:${interaction.user.id}:${today}`)\n        await redis.expire(`engagement:daily:${interaction.user.id}:${today}`, 86400) // 24 hours\n        \n        // Send to channel\n        const channel = interaction.guild.channels.cache.find(ch => ch.name === BOT_CHANNEL_NAME)\n        if (channel) {\n          // Debug: Check bot permissions in channel\n          const botMember = interaction.guild.members.cache.get(client.user.id)\n          const perms = channel.permissionsFor(botMember)\n          console.log(`Bot permissions in #${BOT_CHANNEL_NAME}:`, {\n            viewChannel: perms.has('ViewChannel'),\n            sendMessages: perms.has('SendMessages'),\n            embedLinks: perms.has('EmbedLinks'),\n            readMessageHistory: perms.has('ReadMessageHistory'),\n            useExternalEmojis: perms.has('UseExternalEmojis')\n          })\n          try {\n            const messageContent = createTweetEmbed(tweet, interaction.user.username)\n            await channel.send(messageContent)\n            console.log(`✅ Posted tweet preview to #${BOT_CHANNEL_NAME}`)\n          } catch (channelError) {\n            console.error('Error posting to channel:', channelError)\n            console.log('Make sure the bot has permission to send messages in #engagement-tracker')\n            console.log('Required permissions: View Channel, Send Messages, Embed Links')\n            \n            // Try sending without buttons as fallback\n            try {\n              console.log('Attempting to send without buttons...')\n              const simpleEmbed = createTweetEmbed(tweet, interaction.user.username, false)\n              await channel.send(simpleEmbed)\n              console.log('✅ Sent simplified preview without buttons')\n            } catch (fallbackError) {\n              console.error('Even simple embed failed:', fallbackError)\n              console.log('Bot may lack basic permissions in the channel')\n              \n              // Last resort - send plain text\n              try {\n                const plainMessage = `**@${tweet.authorHandle}**\\n` +\n                  `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n                  `💰 Earn ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | ${tweet.category}\\n` +\n                  `🔗 ${tweet.url}`\n                await channel.send(plainMessage)\n                console.log('✅ Sent plain text preview')\n              } catch (textError) {\n                console.error('Cannot send any message to channel:', textError)\n              }\n            }\n          }\n        } else {\n          console.log(`Channel \"${BOT_CHANNEL_NAME}\" not found. Please create it for tweet announcements.`)\n        }\n        \n        await interaction.editReply(`✅ Tweet submitted successfully! (${parseInt(dailySubmissions) + 1}/${scenarios.dailyTweetLimit} today)`)\n      } catch (error) {\n        console.error('Error submitting tweet:', error)\n        await interaction.editReply('❌ An error occurred while submitting the tweet. Please try again.')\n      }\n    }\n    \n    else if (commandName === 'stats') {\n      await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n      \n      const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n      if (!connection) {\n        await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n        return\n      }\n      \n      // Get tier scenarios\n      const scenarios = await getTierScenarios(connection.tier)\n      \n      // Get today's submissions\n      const today = new Date().toISOString().split('T')[0]\n      const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n      \n      // Get recent engagements (skip for now since we don't have logs yet)\n      const logs = []\n      \n      const embed = new EmbedBuilder()\n        .setColor(0x00FF00)\n        .setTitle('📊 Your Engagement Stats')\n        .setDescription(`**Twitter:** @${connection.twitterHandle}\\n**Tier:** ${connection.tier ? connection.tier.toUpperCase() : 'MICRO'}\\n**Total Points:** ${connection.totalPoints || 0}`)\n        .addFields(\n          { name: 'Daily Limit', value: `${dailySubmissions}/${scenarios.dailyTweetLimit}`, inline: true },\n          { name: 'Bonus Multiplier', value: `${scenarios.bonusMultiplier}x`, inline: true },\n          { name: 'Categories', value: scenarios.categories.join(', '), inline: false }\n        )\n        .setTimestamp()\n      \n      if (logs.length > 0) {\n        const recentActivity = logs.map(log => \n          `${log.interactionType === 'like' ? '❤️' : log.interactionType === 'retweet' ? '🔁' : '💬'} +${log.points} points`\n        ).join('\\n')\n        embed.addFields({ name: 'Recent Activity', value: recentActivity })\n      }\n      \n      await interaction.editReply({ embeds: [embed] })\n    }\n    \n    else if (commandName === 'leaderboard') {\n      await interaction.deferReply()\n      \n      // Get leaderboard data\n      const keys = await redis.keys('engagement:connection:*')\n      const entries = []\n      \n      for (const key of keys.slice(0, 50)) {\n        const connection = await redis.json.get(key)\n        if (connection) {\n          entries.push({\n            discordId: connection.discordId,\n            twitterHandle: connection.twitterHandle,\n            totalPoints: connection.totalPoints || 0,\n            tier: connection.tier\n          })\n        }\n      }\n      \n      // Sort by points\n      entries.sort((a, b) => b.totalPoints - a.totalPoints)\n      \n      const embed = new EmbedBuilder()\n        .setColor(0xFFD700) // Gold\n        .setTitle('🏆 Engagement Leaderboard')\n        .setDescription('Top 10 Engagers')\n        .setTimestamp()\n      \n      const top10 = entries.slice(0, 10).map((entry, index) => {\n        const tierEmoji = {\n          'micro': '⚪',\n          'rising': '🟢',\n          'star': '⭐',\n          'legend': '🟠',\n          'hero': '👑'\n        }[entry.tier] || '⚪'\n        return `**${index + 1}.** @${entry.twitterHandle} ${tierEmoji} ${entry.tier ? entry.tier.toUpperCase() : 'MICRO'} - ${entry.totalPoints} points`\n      }).join('\\n')\n      \n      embed.addFields({ name: 'Rankings', value: top10 || 'No data yet' })\n      \n      await interaction.editReply({ embeds: [embed] })\n    }\n    \n    else if (commandName === 'recent') {\n      await interaction.deferReply()\n      \n      try {\n        // Get recent tweets from sorted set\n        const tweetIds = await redis.zrange('engagement:tweets:recent', 0, 9, { rev: true }) // Get last 10\n        const tweets = []\n        \n        for (const id of tweetIds) {\n          const tweet = await redis.json.get(`engagement:tweet:${id}`)\n          if (tweet) tweets.push(tweet)\n        }\n        \n        const embed = new EmbedBuilder()\n          .setColor(0x1DA1F2) // Twitter blue\n          .setTitle('🐦 Recent Tweets for Engagement')\n          .setDescription('Click on any tweet to engage and earn points!')\n          .setTimestamp()\n        \n        if (tweets.length === 0) {\n          embed.addFields({ name: 'No tweets yet', value: 'Be the first to submit a tweet with `/submit`!' })\n        } else {\n          let tweetList = ''\n          tweets.forEach((tweet, index) => {\n            tweetList += `**${index + 1}. @${tweet.authorHandle}**\\n`\n            if (tweet.content) {\n              tweetList += `\"${tweet.content.substring(0, 100)}${tweet.content.length > 100 ? '...' : ''}\"\\n`\n            }\n            tweetList += `💰 ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | [View Tweet](${tweet.url})\\n\\n`\n          })\n          embed.addFields({ name: 'Recent Tweets', value: tweetList || 'No tweets yet' })\n        }\n        \n        await interaction.editReply({ embeds: [embed] })\n      } catch (error) {\n        console.error('Error in /recent command:', error)\n        await interaction.editReply('❌ An error occurred while fetching recent tweets.')\n      }\n    }\n    \n    else if (commandName === 'tier') {\n      // Admin only\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin) {\n        await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n        return\n      }\n      \n      const user = interaction.options.getUser('user')\n      const tier = interaction.options.getString('tier')\n      \n      const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n      if (!validTiers.includes(tier)) {\n        await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n        return\n      }\n      \n      const connection = await redis.json.get(`engagement:connection:${user.id}`)\n      if (!connection) {\n        await interaction.reply({ content: '❌ User has not connected their Twitter account.', flags: 64 })\n        return\n      }\n      \n      await redis.json.set(`engagement:connection:${user.id}`, '$.tier', tier)\n      await interaction.reply({ content: `✅ Updated ${user.username}'s tier to ${tier.toUpperCase()}`, flags: 64 })\n    }\n    \n    else if (commandName === 'scenarios') {\n      // Admin only\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin) {\n        await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n        return\n      }\n      \n      const tier = interaction.options.getString('tier')\n      const dailyLimit = interaction.options.getInteger('daily_limit')\n      const minFollowers = interaction.options.getInteger('min_followers')\n      const bonusMultiplier = interaction.options.getNumber('bonus_multiplier')\n      \n      const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n      if (!validTiers.includes(tier)) {\n        await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n        return\n      }\n      \n      // Get current scenarios\n      const currentScenarios = await getTierScenarios(tier)\n      \n      // Update with new values\n      if (dailyLimit !== null) currentScenarios.dailyTweetLimit = dailyLimit\n      if (minFollowers !== null) currentScenarios.minFollowers = minFollowers\n      if (bonusMultiplier !== null) currentScenarios.bonusMultiplier = bonusMultiplier\n      \n      // Save scenarios\n      await redis.json.set(`engagement:scenarios:${tier}`, '$', currentScenarios)\n      \n      await interaction.reply({ \n        content: `✅ Updated ${tier.toUpperCase()} tier scenarios:\\n` +\n                 `Daily Limit: ${currentScenarios.dailyTweetLimit}\\n` +\n                 `Min Followers: ${currentScenarios.minFollowers}\\n` +\n                 `Bonus Multiplier: ${currentScenarios.bonusMultiplier}x`,\n        flags: 64 \n      })\n    }\n  }\n  \n  // Handle modal submissions\n  else if (interaction.isModalSubmit()) {\n    if (interaction.customId === 'connect-twitter') {\n      const handle = interaction.fields.getTextInputValue('twitter-handle')\n      const cleanHandle = handle.toLowerCase().replace('@', '').trim()\n      \n      // Check if user is approved\n      const { approved, userData, exists } = await isUserApproved(cleanHandle)\n      \n      // If user doesn't exist, create a new profile (pending approval)\n      if (!exists) {\n        try {\n          const newUser = await createUserProfile(cleanHandle, interaction.user.id)\n          console.log(`✅ Created new profile (pending) for @${cleanHandle}`)\n          \n          await interaction.reply({ \n            content: `📝 Your Twitter account @${cleanHandle} has been registered!\\n\\n` +\n                     `⏳ **Your account is pending approval.** An admin will review and approve your account soon.\\n` +\n                     `📢 You'll be notified once approved and can then use the engagement features.`, \n            flags: 64 \n          })\n          return\n        } catch (error) {\n          console.error('Error creating new user profile:', error)\n          await interaction.reply({ \n            content: '❌ An error occurred while creating your profile. Please try again or contact an admin.', \n            flags: 64 \n          })\n          return\n        }\n      }\n      \n      // If user exists but is not approved\n      if (!approved) {\n        await interaction.reply({ \n          content: '❌ Your Twitter account is pending approval. Please wait for an admin to approve your account.', \n          flags: 64 \n        })\n        return\n      }\n      \n      // Check if handle is already connected\n      const existingDiscordId = await redis.get(`engagement:twitter:${cleanHandle}`)\n      if (existingDiscordId && existingDiscordId !== interaction.user.id) {\n        await interaction.reply({ \n          content: '❌ This Twitter account is already connected to another Discord user.', \n          flags: 64 \n        })\n        return\n      }\n      \n      // Get current role from database\n      const currentRole = userData.role || 'user'\n      \n      // Assign KOL role if user doesn't have a higher role\n      let finalRole = currentRole\n      if (ROLE_HIERARCHY[currentRole] < ROLE_HIERARCHY['kol']) {\n        finalRole = 'kol'\n        await updateUserRole(cleanHandle, 'kol')\n        \n        // Also assign Discord role if available\n        try {\n          const member = await interaction.guild.members.fetch(interaction.user.id)\n          const kolRole = interaction.guild.roles.cache.find(role => role.name.toLowerCase() === KOL_ROLE_NAME)\n          \n          if (kolRole) {\n            // Check if bot has permission to manage roles\n            const botMember = interaction.guild.members.cache.get(client.user.id)\n            if (!botMember.permissions.has('ManageRoles')) {\n              console.warn('⚠️  Bot lacks \"Manage Roles\" permission - cannot assign KOL role')\n              console.log('   Please grant the bot \"Manage Roles\" permission in Discord')\n            } \n            // Check if bot's highest role is above the KOL role\n            else if (botMember.roles.highest.position <= kolRole.position) {\n              console.warn('⚠️  Bot\\'s role is not high enough to assign the KOL role')\n              console.log('   Please move the bot\\'s role above the KOL role in Discord settings')\n            }\n            // Try to assign the role\n            else if (!member.roles.cache.has(kolRole.id)) {\n              await member.roles.add(kolRole)\n              console.log(`✅ Assigned KOL role to ${member.user.tag}`)\n            }\n          } else {\n            console.warn(`⚠️  No role found with name \"${KOL_ROLE_NAME}\" (case-insensitive)`)\n            console.log('   Please create a role named \"kol\" in your Discord server')\n          }\n        } catch (error) {\n          console.error('❌ Error assigning Discord role:', error.message)\n          if (error.code === 50013) {\n            console.log('   This is a permissions issue. Please check:')\n            console.log('   1. Bot has \"Manage Roles\" permission')\n            console.log('   2. Bot\\'s role is above the KOL role in the hierarchy')\n          }\n        }\n      }\n      \n      // Create connection - get tier from user profile\n      const userTier = userData.tier || 'micro'  // Default to micro if no tier\n      const connection = {\n        discordId: interaction.user.id,\n        twitterHandle: cleanHandle,\n        tier: userTier,\n        connectedAt: new Date(),\n        totalPoints: 0,\n        role: finalRole\n      }\n      \n      await redis.json.set(`engagement:connection:${interaction.user.id}`, '$', connection)\n      await redis.set(`engagement:twitter:${cleanHandle}`, interaction.user.id)\n      \n      let message = `✅ Successfully connected Twitter account @${cleanHandle}!`\n      if (finalRole === 'kol' && currentRole !== 'kol') {\n        message += '\\n🎉 You\\'ve been assigned the KOL role!'\n      }\n      \n      await interaction.reply({ \n        content: message, \n        flags: 64 \n      })\n    }\n  }\n})\n\n// Error handling\nclient.on('error', console.error)\n\n// Handle regular messages (for ping/pong)\nclient.on('messageCreate', async (message) => {\n  // Ignore messages from bots\n  if (message.author.bot) return\n  \n  // Simple ping/pong response\n  if (message.content.toLowerCase() === 'ping' || message.content.toLowerCase() === '!ping') {\n    try {\n      await message.reply('pong! 🏓')\n      console.log(`Replied to ping from ${message.author.tag}`)\n    } catch (error) {\n      console.error('Error replying to ping:', error)\n    }\n  }\n})\n\n// Login\nclient.login(process.env.DISCORD_BOT_TOKEN)\n  .then(() => console.log('🚀 Engagement bot starting...'))\n  .catch(console.error) ",
    "fixed": "const { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle } = require('discord.js')\nconst { config } = require('dotenv')\nconst { Redis } = require('@upstash/redis')\nconst { GoogleGenerativeAI } = require('@google/generative-ai')\nconst path = require('path')\nconst { nanoid } = require('nanoid')\n\n// Load environment variables from parent directory\nconst envPath = path.join(__dirname, '..', '.env.local')\nconsole.log('🔍 Loading environment from:', envPath)\nconfig({ path: envPath })\n\n// Check required environment variables\nconst requiredVars = ['UPSTASH_REDIS_REST_URL', 'UPSTASH_REDIS_REST_TOKEN', 'DISCORD_BOT_TOKEN']\nconst optionalVars = ['GEMINI_API_KEY', 'GOOGLE_AI_API_KEY'] // Try both for compatibility\nconst missingVars = requiredVars.filter(v => !process.env[v])\n\n// Check for Gemini/Google AI key\nconst hasAiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n\nif (missingVars.length > 0) {\n  console.error('❌ Missing required environment variables:', missingVars.join(', '))\n  console.error('🔍 Please check your .env.local file contains:')\n  missingVars.forEach(v => console.error(`   ${v}=your_value_here`))\n  process.exit(1)\n}\n\nif (!hasAiKey) {\n  console.warn('⚠️  No AI API key found (GEMINI_API_KEY or GOOGLE_AI_API_KEY)')\n  console.warn('   Sentiment analysis will be disabled')\n}\n\n// Initialize Redis\nconst redis = new Redis({\n  url: process.env.UPSTASH_REDIS_REST_URL,\n  token: process.env.UPSTASH_REDIS_REST_TOKEN\n})\n\n// Initialize Gemini for sentiment analysis (if available)\nlet genAI = null\nlet model = null\n\nif (hasAiKey) {\n  const apiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n  genAI = new GoogleGenerativeAI(apiKey)\n  model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' })\n  console.log('✅ AI model initialized for sentiment analysis')\n}\n\n// Initialize Discord client\nconst client = new Client({\n  intents: [\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildMessages,\n    GatewayIntentBits.MessageContent,\n    GatewayIntentBits.GuildMessageReactions,\n    GatewayIntentBits.GuildMembers\n  ]\n})\n\n// Tweet URL regex\nconst TWEET_REGEX = /https?:\\/\\/(twitter\\.com|x\\.com)\\/[\\w]+\\/status\\/(\\d+)/i\n\n// Bot configuration\nconst BOT_CHANNEL_NAME = 'engagement-tracker'\nconst ADMIN_ROLE_NAME = 'admin'\nconst KOL_ROLE_NAME = 'kol'\n\n// Role hierarchy (higher number = higher priority)\nconst ROLE_HIERARCHY = {\n  'admin': 4,\n  'core': 3,\n  'team': 2,\n  'kol': 1,\n  'user': 0\n}\n\n// Helper function to extract tweet ID from URL\nfunction extractTweetId(url) {\n  const match = url.match(TWEET_REGEX)\n  return match ? match[2] : null\n}\n\n// Helper function to extract Twitter handle from URL\nfunction extractTwitterHandle(url) {\n  const match = url.match(/https?:\\/\\/(twitter\\.com|x\\.com)\\/([\\w]+)\\/status/)\n  return match ? match[2] : null\n}\n\n// Create a new user profile (pending approval)\nasync function createUserProfile(twitterHandle, discordId) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userId = `user_${normalizedHandle}`\n    \n    const newUser = {\n      id: userId,\n      twitterHandle: `@${normalizedHandle}`,\n      name: normalizedHandle, // Use handle as name initially\n      approvalStatus: 'pending', // Set to pending, requiring admin approval\n      role: 'user', // Default to user role\n      tier: 'micro', // Default tier\n      discordId: discordId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      socialAccounts: {\n        twitter: {\n          handle: normalizedHandle,\n          connected: true\n        }\n      }\n    }\n    \n    // Save to Redis\n    await redis.json.set(userId, '$', newUser)\n    \n    // Create username index\n    await redis.sadd(`idx:username:${normalizedHandle}`, userId)\n    \n    // Add to pending users set (not approved)\n    await redis.sadd('users:pending', userId)\n    \n    console.log(`✅ Created new user profile (pending) for @${normalizedHandle}`)\n    return newUser\n  } catch (error) {\n    console.error('Error creating user profile:', error)\n    throw error\n  }\n}\n\n\n// Check if user is approved in the database\nasync function isUserApproved(twitterHandle) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    \n    // Check if user exists via username index\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    if (!userIds || userIds.length === 0) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Get user data\n    const userData = await redis.json.get(`user:${userIds[0]}`)\n    if (!userData) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Check approval status\n    const isApproved = userData.approvalStatus === 'approved'\n    return { approved: isApproved, userData, exists: true }\n  } catch (error) {\n    console.error('Error checking user approval:', error)\n    return { approved: false, userData: null, exists: false }\n  }\n}\n\n// Get user's current role from database\nasync function getUserRole(twitterHandle) {\n  try {\n    const { approved, userData } = await isUserApproved(twitterHandle)\n    if (!approved || !userData) return 'user'\n    \n    return userData.role || 'user'\n  } catch (error) {\n    console.error('Error getting user role:', error)\n    return 'user'\n  }\n}\n\n// Update user's role in database\nasync function updateUserRole(twitterHandle, newRole) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    \n    if (userIds && userIds.length > 0) {\n      await redis.json.set(`user:${userIds[0]}`, '$.role', newRole)\n      return true\n    }\n    return false\n  } catch (error) {\n    console.error('Error updating user role:', error)\n    return false\n  }\n}\n\n// Get tier-based scenarios\nasync function getTierScenarios(tier) {\n  try {\n    const safeTier = tier || 'micro' // Default to micro if tier is null/undefined\n    const scenarios = await redis.json.get(`engagement:scenarios:${safeTier}`)\n    return scenarios || getDefaultScenarios(safeTier)\n  } catch (error) {\n    console.error('Error getting tier scenarios:', error)\n    return getDefaultScenarios(tier || 'micro')\n  }\n}\n\n// Default scenarios by tier\nfunction getDefaultScenarios(tier) {\n  const scenarios = {\n    'micro': {\n      dailyTweetLimit: 5,\n      categories: ['General', 'DeFi', 'NFT'],\n      minFollowers: 100,\n      bonusMultiplier: 1.0\n    },\n    'rising': {\n      dailyTweetLimit: 10,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech'],\n      minFollowers: 500,\n      bonusMultiplier: 1.5\n    },\n    'star': {\n      dailyTweetLimit: 20,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News'],\n      minFollowers: 1000,\n      bonusMultiplier: 2.0\n    },\n    'legend': {\n      dailyTweetLimit: 30,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special'],\n      minFollowers: 5000,\n      bonusMultiplier: 2.5\n    },\n    'hero': {\n      dailyTweetLimit: 50,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special', 'VIP'],\n      minFollowers: 10000,\n      bonusMultiplier: 3.0\n    }\n  }\n  \n  return scenarios[tier] || scenarios['micro']\n}\n\n// Create minimal tweet embed with preview\nfunction createTweetEmbed(tweet, submitterName, includeButtons = true) {\n  // Choose color based on tier\n  const tierColors = {\n    'micro': 0x6B7280,  // Gray\n    'rising': 0x3BA55D, // Green\n    'star': 0x5865F2,   // Blue\n    'legend': 0xEA580C, // Orange\n    'hero': 0x9333EA    // Purple\n  }\n  \n  // Calculate potential points\n  const likePoints = Math.floor(10 * tweet.bonusMultiplier)\n  const retweetPoints = Math.floor(20 * tweet.bonusMultiplier)\n  const replyPoints = Math.floor(30 * tweet.bonusMultiplier)\n  \n  const embed = new EmbedBuilder()\n    .setColor(tierColors[tweet.tier] || 0x1DA1F2)\n    .setAuthor({ \n      name: `@${tweet.authorHandle}`, \n      url: `https://twitter.com/${tweet.authorHandle}`,\n      iconURL: 'https://abs.twimg.com/icons/apple-touch-icon-192x192.png'\n    })\n    .setDescription(\n      `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n      `**💰 Earn ${tweet.bonusMultiplier}x points:**\\n` +\n      `❤️ Like: ${likePoints} pts | 🔁 RT: ${retweetPoints} pts | 💬 Reply: ${replyPoints} pts`\n    )\n    .addFields(\n      { name: 'Tier', value: `⭐ ${tweet.tier}`, inline: true },\n      { name: 'Category', value: `${tweet.category}`, inline: true },\n      { name: 'Submitted', value: `<t:${Math.floor(new Date(tweet.submittedAt).getTime() / 1000)}:R>`, inline: true }\n    )\n    .setFooter({ text: `Submitted by ${submitterName}` })\n  \n  if (includeButtons) {\n    // Create clickable button for the tweet\n    const row = new ActionRowBuilder()\n      .addComponents(\n        new ButtonBuilder()\n          .setLabel('View & Engage')\n          .setStyle(ButtonStyle.Link)\n          .setURL(tweet.url)\n          .setEmoji('🐦')\n      )\n    \n    return { embeds: [embed], components: [row] }\n  }\n  \n  return { embeds: [embed] }\n}\n\n// Handle slash commands\nclient.on('ready', async () => {\n  console.log(`✅ Engagement bot logged in as ${client.user.tag}`)\n  \n  // Start checking for channel info requests\n  setInterval(async () => {\n    try {\n      // Look for any channel info requests\n      const keys = await redis.keys('discord:channel-info-request:*')\n      \n      for (const key of keys) {\n        const request = await redis.get(key)\n        if (!request) continue\n        \n        let channelId, serverId, projectId\n        try {\n          // Upstash Redis returns the parsed object directly\n          const parsed = typeof request === 'string' ? JSON.parse(request) : request\n          channelId = parsed.channelId\n          serverId = parsed.serverId\n          projectId = parsed.projectId\n        } catch (parseError) {\n          console.error(`Error parsing channel info request from ${key}:`, parseError)\n          console.error('Raw request data:', request)\n          await redis.del(key)\n          continue\n        }\n        \n        // Try to fetch the channel\n        try {\n          console.log(`[DEBUG] Looking for guild ${serverId}`)\n          console.log(`[DEBUG] Available guilds: ${client.guilds.cache.map(g => `${g.name} (${g.id})`).join(', ')}`)\n          \n          const guild = client.guilds.cache.get(serverId)\n          if (!guild) {\n            console.log(`Guild ${serverId} not found in cache`)\n            continue\n          }\n          \n          const channel = guild.channels.cache.get(channelId)\n          if (channel) {\n            // Store the response\n            const responseKey = `discord:channel-info-response:${channelId}`\n            await redis.set(responseKey, JSON.stringify({\n              id: channelId,\n              name: channel.name,\n              type: channel.type === 0 ? 'text' : 'voice'\n            }), {\n              ex: 60 // expire in 60 seconds\n            })\n            \n            // Also store permanent channel metadata\n            const channelMetadataKey = `channel:discord:${channelId}`\n            await redis.json.set(channelMetadataKey, '$', {\n              id: channelId,\n              name: channel.name,\n              type: channel.type === 0 ? 'text' : 'voice',\n              projectId: projectId || null,\n              updatedAt: new Date().toISOString()\n            })\n            \n            console.log(`✅ Fetched channel info: #${channel.name} (${channelId})`)\n          } else {\n            console.log(`Channel ${channelId} not found in guild ${serverId}`)\n          }\n        } catch (error) {\n          console.error(`Error fetching channel ${channelId}:`, error)\n        }\n        \n        // Delete the request\n        await redis.del(key)\n      }\n    } catch (error) {\n      console.error('Error processing channel info requests:', error)\n    }\n  }, 2000) // Check every 2 seconds\n  \n  // Register slash commands\n  const commands = [\n    {\n      name: 'connect',\n      description: 'Connect your Twitter account (must be approved)'\n    },\n    {\n      name: 'submit',\n      description: 'Submit a tweet for engagement tracking',\n      options: [{\n        name: 'url',\n        type: 3, // STRING\n        description: 'The tweet URL',\n        required: true\n      }, {\n        name: 'category',\n        type: 3,\n        description: 'Tweet category (optional)',\n        required: false\n      }]\n    },\n    {\n      name: 'stats',\n      description: 'View your engagement stats'\n    },\n    {\n      name: 'leaderboard',\n      description: 'View the engagement leaderboard'\n    },\n    {\n      name: 'recent',\n      description: 'View recently submitted tweets'\n    },\n    {\n      name: 'tier',\n      description: 'Admin: Set user tier',\n      options: [{\n        name: 'user',\n        type: 6, // USER\n        description: 'The user to update',\n        required: true\n      }, {\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }]\n    },\n    {\n      name: 'scenarios',\n      description: 'Admin: Configure tier scenarios',\n      options: [{\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }, {\n        name: 'daily_limit',\n        type: 4,\n        description: 'Daily tweet limit',\n        required: false\n      }, {\n        name: 'min_followers',\n        type: 4,\n        description: 'Minimum followers required',\n        required: false\n      }, {\n        name: 'bonus_multiplier',\n        type: 10, // DOUBLE\n        description: 'Points bonus multiplier',\n        required: false\n      }]\n    }\n  ]\n  \n  try {\n    await client.application.commands.set(commands)\n    console.log('✅ Slash commands registered')\n  } catch (error) {\n    console.error('Error registering commands:', error)\n  }\n})\n\n// Handle interactions\nclient.on('interactionCreate', async (interaction) => {\n  // Handle slash commands\n  if (interaction.isCommand()) {\n    const { commandName } = interaction\n    \n    if (commandName === 'connect') {\n      // Show modal for Twitter handle input\n      const modal = new ModalBuilder()\n        .setCustomId('connect-twitter')\n        .setTitle('Connect Twitter Account')\n      \n      const handleInput = new TextInputBuilder()\n        .setCustomId('twitter-handle')\n        .setLabel('Your Twitter Handle')\n        .setPlaceholder('@yourusername')\n        .setStyle(TextInputStyle.Short)\n        .setRequired(true)\n      \n      const row = new ActionRowBuilder().addComponents(handleInput)\n      modal.addComponents(row)\n      \n      await interaction.showModal(modal)\n    }\n    \n    else if (commandName === 'submit') {\n      await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n      \n      const url = interaction.options.getString('url')\n      const category = interaction.options.getString('category')\n      \n      // Validate URL\n      const tweetId = extractTweetId(url)\n      if (!tweetId) {\n        await interaction.editReply('❌ Invalid tweet URL. Please provide a valid Twitter/X URL.')\n        return\n      }\n      \n      // Check if user is connected\n      const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n      if (!connection) {\n        await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n        return\n      }\n      \n      // Check if user is still approved\n      const { approved } = await isUserApproved(connection.twitterHandle)\n      if (!approved) {\n        await interaction.editReply('❌ Your Twitter account is no longer approved. Please contact an admin.')\n        return\n      }\n      \n      // Check tier scenarios\n      const scenarios = await getTierScenarios(connection.tier)\n      \n      // Check daily limit\n      const today = new Date().toISOString().split('T')[0]\n      const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n      \n      if (dailySubmissions >= scenarios.dailyTweetLimit) {\n        await interaction.editReply(`❌ You've reached your daily limit of ${scenarios.dailyTweetLimit} tweets for Tier ${connection.tier}.`)\n        return\n      }\n      \n      // Check for duplicate\n      const isDuplicate = await redis.exists(`engagement:tweetid:${tweetId}`)\n      if (isDuplicate) {\n        await interaction.editReply('❌ This tweet has already been submitted.')\n        return\n      }\n      \n      // Extract author handle\n      const authorHandle = extractTwitterHandle(url)\n      \n      // Check if submitter is author or admin\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin && connection.twitterHandle !== authorHandle) {\n        await interaction.editReply('❌ You can only submit your own tweets. Admins can submit any tweet.')\n        return\n      }\n      \n      // Validate category\n      let finalCategory = category\n      if (category && !scenarios.categories.includes(category)) {\n        await interaction.editReply(`❌ Invalid category. Available categories for Tier ${connection.tier}: ${scenarios.categories.join(', ')}`)\n        return\n      }\n      \n      if (!finalCategory) {\n        finalCategory = 'General'\n      }\n      \n      // Submit tweet\n      try {\n        const { nanoid } = await import('nanoid')\n        // Try to fetch tweet content from Twitter API\n        let tweetContent = null\n        try {\n          const response = await fetch(`https://api.twitter.com/2/tweets/${tweetId}?tweet.fields=text`, {\n            headers: {\n              'Authorization': `Bearer ${process.env.TWITTER_BEARER_TOKEN}`\n            }\n          })\n          \n          if (response.ok) {\n            const tweetData = await response.json()\n            tweetContent = tweetData.data?.text || null\n            console.log('📝 Fetched tweet content:', tweetContent ? 'Success' : 'No content')\n          }\n        } catch (error) {\n          console.log('⚠️ Could not fetch tweet content:', error.message)\n        }\n\n        const tweet = {\n          id: nanoid(),\n          tweetId,\n          submitterDiscordId: interaction.user.id,\n          submittedAt: new Date(),\n          category: finalCategory,\n          url,\n          authorHandle,\n          content: tweetContent,\n          tier: connection.tier,\n          bonusMultiplier: scenarios.bonusMultiplier\n        }\n        \n        await redis.json.set(`engagement:tweet:${tweet.id}`, '$', tweet)\n        // Store in sorted set for admin panel compatibility\n        await redis.zadd('engagement:tweets:recent', { score: Date.now(), member: tweet.id })\n        await redis.set(`engagement:tweetid:${tweet.tweetId}`, tweet.id)\n        \n        // Increment daily counter\n        await redis.incr(`engagement:daily:${interaction.user.id}:${today}`)\n        await redis.expire(`engagement:daily:${interaction.user.id}:${today}`, 86400) // 24 hours\n        \n        // Send to channel\n        const channel = interaction.guild.channels.cache.find(ch => ch.name === BOT_CHANNEL_NAME)\n        if (channel) {\n          // Debug: Check bot permissions in channel\n          const botMember = interaction.guild.members.cache.get(client.user.id)\n          const perms = channel.permissionsFor(botMember)\n          console.log(`Bot permissions in #${BOT_CHANNEL_NAME}:`, {\n            viewChannel: perms.has('ViewChannel'),\n            sendMessages: perms.has('SendMessages'),\n            embedLinks: perms.has('EmbedLinks'),\n            readMessageHistory: perms.has('ReadMessageHistory'),\n            useExternalEmojis: perms.has('UseExternalEmojis')\n          })\n          try {\n            const messageContent = createTweetEmbed(tweet, interaction.user.username)\n            await channel.send(messageContent)\n            console.log(`✅ Posted tweet preview to #${BOT_CHANNEL_NAME}`)\n          } catch (channelError) {\n            console.error('Error posting to channel:', channelError)\n            console.log('Make sure the bot has permission to send messages in #engagement-tracker')\n            console.log('Required permissions: View Channel, Send Messages, Embed Links')\n            \n            // Try sending without buttons as fallback\n            try {\n              console.log('Attempting to send without buttons...')\n              const simpleEmbed = createTweetEmbed(tweet, interaction.user.username, false)\n              await channel.send(simpleEmbed)\n              console.log('✅ Sent simplified preview without buttons')\n            } catch (fallbackError) {\n              console.error('Even simple embed failed:', fallbackError)\n              console.log('Bot may lack basic permissions in the channel')\n              \n              // Last resort - send plain text\n              try {\n                const plainMessage = `**@${tweet.authorHandle}**\\n` +\n                  `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n                  `💰 Earn ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | ${tweet.category}\\n` +\n                  `🔗 ${tweet.url}`\n                await channel.send(plainMessage)\n                console.log('✅ Sent plain text preview')\n              } catch (textError) {\n                console.error('Cannot send any message to channel:', textError)\n              }\n            }\n          }\n        } else {\n          console.log(`Channel \"${BOT_CHANNEL_NAME}\" not found. Please create it for tweet announcements.`)\n        }\n        \n        await interaction.editReply(`✅ Tweet submitted successfully! (${parseInt(dailySubmissions) + 1}/${scenarios.dailyTweetLimit} today)`)\n      } catch (error) {\n        console.error('Error submitting tweet:', error)\n        await interaction.editReply('❌ An error occurred while submitting the tweet. Please try again.')\n      }\n    }\n    \n    else if (commandName === 'stats') {\n      await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n      \n      const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n      if (!connection) {\n        await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n        return\n      }\n      \n      // Get tier scenarios\n      const scenarios = await getTierScenarios(connection.tier)\n      \n      // Get today's submissions\n      const today = new Date().toISOString().split('T')[0]\n      const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n      \n      // Get recent engagements (skip for now since we don't have logs yet)\n      const logs = []\n      \n      const embed = new EmbedBuilder()\n        .setColor(0x00FF00)\n        .setTitle('📊 Your Engagement Stats')\n        .setDescription(`**Twitter:** @${connection.twitterHandle}\\n**Tier:** ${connection.tier ? connection.tier.toUpperCase() : 'MICRO'}\\n**Total Points:** ${connection.totalPoints || 0}`)\n        .addFields(\n          { name: 'Daily Limit', value: `${dailySubmissions}/${scenarios.dailyTweetLimit}`, inline: true },\n          { name: 'Bonus Multiplier', value: `${scenarios.bonusMultiplier}x`, inline: true },\n          { name: 'Categories', value: scenarios.categories.join(', '), inline: false }\n        )\n        .setTimestamp()\n      \n      if (logs.length > 0) {\n        const recentActivity = logs.map(log => \n          `${log.interactionType === 'like' ? '❤️' : log.interactionType === 'retweet' ? '🔁' : '💬'} +${log.points} points`\n        ).join('\\n')\n        embed.addFields({ name: 'Recent Activity', value: recentActivity })\n      }\n      \n      await interaction.editReply({ embeds: [embed] })\n    }\n    \n    else if (commandName === 'leaderboard') {\n      await interaction.deferReply()\n      \n      // Get leaderboard data\n      const keys = await redis.keys('engagement:connection:*')\n      const entries = []\n      \n      for (const key of keys.slice(0, 50)) {\n        const connection = await redis.json.get(key)\n        if (connection) {\n          entries.push({\n            discordId: connection.discordId,\n            twitterHandle: connection.twitterHandle,\n            totalPoints: connection.totalPoints || 0,\n            tier: connection.tier\n          })\n        }\n      }\n      \n      // Sort by points\n      entries.sort((a, b) => b.totalPoints - a.totalPoints)\n      \n      const embed = new EmbedBuilder()\n        .setColor(0xFFD700) // Gold\n        .setTitle('🏆 Engagement Leaderboard')\n        .setDescription('Top 10 Engagers')\n        .setTimestamp()\n      \n      const top10 = entries.slice(0, 10).map((entry, index) => {\n        const tierEmoji = {\n          'micro': '⚪',\n          'rising': '🟢',\n          'star': '⭐',\n          'legend': '🟠',\n          'hero': '👑'\n        }[entry.tier] || '⚪'\n        return `**${index + 1}.** @${entry.twitterHandle} ${tierEmoji} ${entry.tier ? entry.tier.toUpperCase() : 'MICRO'} - ${entry.totalPoints} points`\n      }).join('\\n')\n      \n      embed.addFields({ name: 'Rankings', value: top10 || 'No data yet' })\n      \n      await interaction.editReply({ embeds: [embed] })\n    }\n    \n    else if (commandName === 'recent') {\n      await interaction.deferReply()\n      \n      try {\n        // Get recent tweets from sorted set\n        const tweetIds = await redis.zrange('engagement:tweets:recent', 0, 9, { rev: true }) // Get last 10\n        const tweets = []\n        \n        for (const id of tweetIds) {\n          const tweet = await redis.json.get(`engagement:tweet:${id}`)\n          if (tweet) tweets.push(tweet)\n        }\n        \n        const embed = new EmbedBuilder()\n          .setColor(0x1DA1F2) // Twitter blue\n          .setTitle('🐦 Recent Tweets for Engagement')\n          .setDescription('Click on any tweet to engage and earn points!')\n          .setTimestamp()\n        \n        if (tweets.length === 0) {\n          embed.addFields({ name: 'No tweets yet', value: 'Be the first to submit a tweet with `/submit`!' })\n        } else {\n          let tweetList = ''\n          tweets.forEach((tweet, index) => {\n            tweetList += `**${index + 1}. @${tweet.authorHandle}**\\n`\n            if (tweet.content) {\n              tweetList += `\"${tweet.content.substring(0, 100)}${tweet.content.length > 100 ? '...' : ''}\"\\n`\n            }\n            tweetList += `💰 ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | [View Tweet](${tweet.url})\\n\\n`\n          })\n          embed.addFields({ name: 'Recent Tweets', value: tweetList || 'No tweets yet' })\n        }\n        \n        await interaction.editReply({ embeds: [embed] })\n      } catch (error) {\n        console.error('Error in /recent command:', error)\n        await interaction.editReply('❌ An error occurred while fetching recent tweets.')\n      }\n    }\n    \n    else if (commandName === 'tier') {\n      // Admin only\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin) {\n        await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n        return\n      }\n      \n      const user = interaction.options.getUser('user')\n      const tier = interaction.options.getString('tier')\n      \n      const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n      if (!validTiers.includes(tier)) {\n        await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n        return\n      }\n      \n      const connection = await redis.json.get(`engagement:connection:${user.id}`)\n      if (!connection) {\n        await interaction.reply({ content: '❌ User has not connected their Twitter account.', flags: 64 })\n        return\n      }\n      \n      await redis.json.set(`engagement:connection:${user.id}`, '$.tier', tier)\n      await interaction.reply({ content: `✅ Updated ${user.username}'s tier to ${tier.toUpperCase()}`, flags: 64 })\n    }\n    \n    else if (commandName === 'scenarios') {\n      // Admin only\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin) {\n        await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n        return\n      }\n      \n      const tier = interaction.options.getString('tier')\n      const dailyLimit = interaction.options.getInteger('daily_limit')\n      const minFollowers = interaction.options.getInteger('min_followers')\n      const bonusMultiplier = interaction.options.getNumber('bonus_multiplier')\n      \n      const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n      if (!validTiers.includes(tier)) {\n        await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n        return\n      }\n      \n      // Get current scenarios\n      const currentScenarios = await getTierScenarios(tier)\n      \n      // Update with new values\n      if (dailyLimit !== null) currentScenarios.dailyTweetLimit = dailyLimit\n      if (minFollowers !== null) currentScenarios.minFollowers = minFollowers\n      if (bonusMultiplier !== null) currentScenarios.bonusMultiplier = bonusMultiplier\n      \n      // Save scenarios\n      await redis.json.set(`engagement:scenarios:${tier}`, '$', currentScenarios)\n      \n      await interaction.reply({ \n        content: `✅ Updated ${tier.toUpperCase()} tier scenarios:\\n` +\n                 `Daily Limit: ${currentScenarios.dailyTweetLimit}\\n` +\n                 `Min Followers: ${currentScenarios.minFollowers}\\n` +\n                 `Bonus Multiplier: ${currentScenarios.bonusMultiplier}x`,\n        flags: 64 \n      })\n    }\n  }\n  \n  // Handle modal submissions\n  else if (interaction.isModalSubmit()) {\n    if (interaction.customId === 'connect-twitter') {\n      const handle = interaction.fields.getTextInputValue('twitter-handle')\n      const cleanHandle = handle.toLowerCase().replace('@', '').trim()\n      \n      // Check if user is approved\n      const { approved, userData, exists } = await isUserApproved(cleanHandle)\n      \n      // If user doesn't exist, create a new profile (pending approval)\n      if (!exists) {\n        try {\n          const newUser = await createUserProfile(cleanHandle, interaction.user.id)\n          console.log(`✅ Created new profile (pending) for @${cleanHandle}`)\n          \n          await interaction.reply({ \n            content: `📝 Your Twitter account @${cleanHandle} has been registered!\\n\\n` +\n                     `⏳ **Your account is pending approval.** An admin will review and approve your account soon.\\n` +\n                     `📢 You'll be notified once approved and can then use the engagement features.`, \n            flags: 64 \n          })\n          return\n        } catch (error) {\n          console.error('Error creating new user profile:', error)\n          await interaction.reply({ \n            content: '❌ An error occurred while creating your profile. Please try again or contact an admin.', \n            flags: 64 \n          })\n          return\n        }\n      }\n      \n      // If user exists but is not approved\n      if (!approved) {\n        await interaction.reply({ \n          content: '❌ Your Twitter account is pending approval. Please wait for an admin to approve your account.', \n          flags: 64 \n        })\n        return\n      }\n      \n      // Check if handle is already connected\n      const existingDiscordId = await redis.get(`engagement:twitter:${cleanHandle}`)\n      if (existingDiscordId && existingDiscordId !== interaction.user.id) {\n        await interaction.reply({ \n          content: '❌ This Twitter account is already connected to another Discord user.', \n          flags: 64 \n        })\n        return\n      }\n      \n      // Get current role from database\n      const currentRole = userData.role || 'user'\n      \n      // Assign KOL role if user doesn't have a higher role\n      let finalRole = currentRole\n      if (ROLE_HIERARCHY[currentRole] < ROLE_HIERARCHY['kol']) {\n        finalRole = 'kol'\n        await updateUserRole(cleanHandle, 'kol')\n        \n        // Also assign Discord role if available\n        try {\n          const member = await interaction.guild.members.fetch(interaction.user.id)\n          const kolRole = interaction.guild.roles.cache.find(role => role.name.toLowerCase() === KOL_ROLE_NAME)\n          \n          if (kolRole) {\n            // Check if bot has permission to manage roles\n            const botMember = interaction.guild.members.cache.get(client.user.id)\n            if (!botMember.permissions.has('ManageRoles')) {\n              console.warn('⚠️  Bot lacks \"Manage Roles\" permission - cannot assign KOL role')\n              console.log('   Please grant the bot \"Manage Roles\" permission in Discord')\n            } \n            // Check if bot's highest role is above the KOL role\n            else if (botMember.roles.highest.position <= kolRole.position) {\n              console.warn('⚠️  Bot\\'s role is not high enough to assign the KOL role')\n              console.log('   Please move the bot\\'s role above the KOL role in Discord settings')\n            }\n            // Try to assign the role\n            else if (!member.roles.cache.has(kolRole.id)) {\n              await member.roles.add(kolRole)\n              console.log(`✅ Assigned KOL role to ${member.user.tag}`)\n            }\n          } else {\n            console.warn(`⚠️  No role found with name \"${KOL_ROLE_NAME}\" (case-insensitive)`)\n            console.log('   Please create a role named \"kol\" in your Discord server')\n          }\n        } catch (error) {\n          console.error('❌ Error assigning Discord role:', error.message)\n          if (error.code === 50013) {\n            console.log('   This is a permissions issue. Please check:')\n            console.log('   1. Bot has \"Manage Roles\" permission')\n            console.log('   2. Bot\\'s role is above the KOL role in the hierarchy')\n          }\n        }\n      }\n      \n      // Create connection - get tier from user profile\n      const userTier = userData.tier || 'micro'  // Default to micro if no tier\n      const connection = {\n        discordId: interaction.user.id,\n        twitterHandle: cleanHandle,\n        tier: userTier,\n        connectedAt: new Date(),\n        totalPoints: 0,\n        role: finalRole\n      }\n      \n      await redis.json.set(`engagement:connection:${interaction.user.id}`, '$', connection)\n      await redis.set(`engagement:twitter:${cleanHandle}`, interaction.user.id)\n      \n      let message = `✅ Successfully connected Twitter account @${cleanHandle}!`\n      if (finalRole === 'kol' && currentRole !== 'kol') {\n        message += '\\n🎉 You\\'ve been assigned the KOL role!'\n      }\n      \n      await interaction.reply({ \n        content: message, \n        flags: 64 \n      })\n    }\n  }\n})\n\n// Error handling\nclient.on('error', console.error)\n\n// Handle regular messages (for ping/pong)\nclient.on('messageCreate', async (message) => {\n  // Ignore messages from bots\n  if (message.author.bot) return\n  \n  // Simple ping/pong response\n  if (message.content.toLowerCase() === 'ping' || message.content.toLowerCase() === '!ping') {\n    try {\n      await message.reply('pong! 🏓')\n      console.log(`Replied to ping from ${message.author.tag}`)\n    } catch (error) {\n      console.error('Error replying to ping:', error)\n    }\n  }\n})\n\n// Login\nclient.login(process.env.DISCORD_BOT_TOKEN)\n  .then(() => console.log('🚀 Engagement bot starting...'))\n  .catch(console.error) "
  },
  {
    "file": "discord-bots/engagement-bot-fixed.js",
    "original": "const { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle } = require('discord.js')\nconst { config } = require('dotenv')\nconst { Redis } = require('@upstash/redis')\nconst { GoogleGenerativeAI } = require('@google/generative-ai')\nconst path = require('path')\nconst { nanoid } = require('nanoid')\n\n// Load environment variables from parent directory\nconst envPath = path.join(__dirname, '..', '.env.local')\nconsole.log('🔍 Loading environment from:', envPath)\nconfig({ path: envPath })\n\n// Check required environment variables\nconst requiredVars = ['UPSTASH_REDIS_REST_URL', 'UPSTASH_REDIS_REST_TOKEN', 'DISCORD_BOT_TOKEN']\nconst optionalVars = ['GEMINI_API_KEY', 'GOOGLE_AI_API_KEY'] // Try both for compatibility\nconst missingVars = requiredVars.filter(v => !process.env[v])\n\n// Check for Gemini/Google AI key\nconst hasAiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n\nif (missingVars.length > 0) {\n  console.error('❌ Missing required environment variables:', missingVars.join(', '))\n  console.error('🔍 Please check your .env.local file contains:')\n  missingVars.forEach(v => console.error(`   ${v}=your_value_here`))\n  process.exit(1)\n}\n\nif (!hasAiKey) {\n  console.warn('⚠️  No AI API key found (GEMINI_API_KEY or GOOGLE_AI_API_KEY)')\n  console.warn('   Sentiment analysis will be disabled')\n}\n\n// Initialize Redis\nconst redis = new Redis({\n  url: process.env.UPSTASH_REDIS_REST_URL,\n  token: process.env.UPSTASH_REDIS_REST_TOKEN\n})\n\n// Initialize Gemini for sentiment analysis (if available)\nlet genAI = null\nlet model = null\n\nif (hasAiKey) {\n  const apiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n  genAI = new GoogleGenerativeAI(apiKey)\n  model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' })\n  console.log('✅ AI model initialized for sentiment analysis')\n}\n\n// Initialize Discord client\nconst client = new Client({\n  intents: [\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildMessages,\n    GatewayIntentBits.MessageContent,\n    GatewayIntentBits.GuildMessageReactions,\n    GatewayIntentBits.GuildMembers\n  ]\n})\n\n// Tweet URL regex\nconst TWEET_REGEX = /https?:\\/\\/(twitter\\.com|x\\.com)\\/[\\w]+\\/status\\/(\\d+)/i\n\n// Bot configuration\nconst BOT_CHANNEL_NAME = 'engagement-tracker'\nconst ADMIN_ROLE_NAME = 'admin'\nconst KOL_ROLE_NAME = 'kol'\n\n// Role hierarchy (higher number = higher priority)\nconst ROLE_HIERARCHY = {\n  'admin': 4,\n  'core': 3,\n  'team': 2,\n  'kol': 1,\n  'user': 0\n}\n\n// Helper function to extract tweet ID from URL\nfunction extractTweetId(url) {\n  const match = url.match(TWEET_REGEX)\n  return match ? match[2] : null\n}\n\n// Helper function to extract Twitter handle from URL\nfunction extractTwitterHandle(url) {\n  const match = url.match(/https?:\\/\\/(twitter\\.com|x\\.com)\\/([\\w]+)\\/status/)\n  return match ? match[2] : null\n}\n\n// Create a new user profile\nasync function createUserProfile(twitterHandle, discordId) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userId = `user:${nanoid()}`\n    \n    const newUser = {\n      id: userId,\n      twitterHandle: `@${normalizedHandle}`,\n      name: normalizedHandle, // Use handle as name initially\n      approvalStatus: 'approved', // Auto-approve for engagement bot\n      role: 'kol', // Default to KOL role for engagement\n      tier: 'micro', // Default tier\n      discordId: discordId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      socialAccounts: {\n        twitter: {\n          handle: normalizedHandle,\n          connected: true\n        }\n      }\n    }\n    \n    // Save to Redis\n    await redis.json.set(userId, '$', newUser)\n    \n    // Create username index\n    await redis.sadd(`idx:username:${normalizedHandle}`, userId)\n    \n    // Add to approved users set\n    await redis.sadd('users:approved', userId)\n    \n    console.log(`✅ Created new user profile for @${normalizedHandle}`)\n    return newUser\n  } catch (error) {\n    console.error('Error creating user profile:', error)\n    throw error\n  }\n}\n\n// Check if user is approved in the database\nasync function isUserApproved(twitterHandle) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    \n    // Check if user exists via username index\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    if (!userIds || userIds.length === 0) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Get user data\n    const userData = await redis.json.get(`user:${userIds[0]}`)\n    if (!userData) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Check approval status\n    const isApproved = userData.approvalStatus === 'approved'\n    return { approved: isApproved, userData, exists: true }\n  } catch (error) {\n    console.error('Error checking user approval:', error)\n    return { approved: false, userData: null, exists: false }\n  }\n}\n\n// Get user's current role from database\nasync function getUserRole(twitterHandle) {\n  try {\n    const { approved, userData } = await isUserApproved(twitterHandle)\n    if (!approved || !userData) return 'user'\n    \n    return userData.role || 'user'\n  } catch (error) {\n    console.error('Error getting user role:', error)\n    return 'user'\n  }\n}\n\n// Update user's role in database\nasync function updateUserRole(twitterHandle, newRole) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    \n    if (userIds && userIds.length > 0) {\n      await redis.json.set(`user:${userIds[0]}`, '$.role', newRole)\n      return true\n    }\n    return false\n  } catch (error) {\n    console.error('Error updating user role:', error)\n    return false\n  }\n}\n\n// Get tier-based scenarios\nasync function getTierScenarios(tier) {\n  try {\n    const safeTier = tier || 'micro' // Default to micro if tier is null/undefined\n    const scenarios = await redis.json.get(`engagement:scenarios:${safeTier}`)\n    return scenarios || getDefaultScenarios(safeTier)\n  } catch (error) {\n    console.error('Error getting tier scenarios:', error)\n    return getDefaultScenarios(tier || 'micro')\n  }\n}\n\n// Default scenarios by tier\nfunction getDefaultScenarios(tier) {\n  const scenarios = {\n    'micro': {\n      dailyTweetLimit: 5,\n      categories: ['General', 'DeFi', 'NFT'],\n      minFollowers: 100,\n      bonusMultiplier: 1.0\n    },\n    'rising': {\n      dailyTweetLimit: 10,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech'],\n      minFollowers: 500,\n      bonusMultiplier: 1.5\n    },\n    'star': {\n      dailyTweetLimit: 20,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News'],\n      minFollowers: 1000,\n      bonusMultiplier: 2.0\n    },\n    'legend': {\n      dailyTweetLimit: 30,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special'],\n      minFollowers: 5000,\n      bonusMultiplier: 2.5\n    },\n    'hero': {\n      dailyTweetLimit: 50,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special', 'VIP'],\n      minFollowers: 10000,\n      bonusMultiplier: 3.0\n    }\n  }\n  \n  return scenarios[tier] || scenarios['micro']\n}\n\n// Create minimal tweet embed with preview\nfunction createTweetEmbed(tweet, submitterName, includeButtons = true) {\n  // Choose color based on tier\n  const tierColors = {\n    'micro': 0x6B7280,  // Gray\n    'rising': 0x3BA55D, // Green\n    'star': 0x5865F2,   // Blue\n    'legend': 0xEA580C, // Orange\n    'hero': 0x9333EA    // Purple\n  }\n  \n  // Calculate potential points\n  const likePoints = Math.floor(10 * tweet.bonusMultiplier)\n  const retweetPoints = Math.floor(20 * tweet.bonusMultiplier)\n  const replyPoints = Math.floor(30 * tweet.bonusMultiplier)\n  \n  const embed = new EmbedBuilder()\n    .setColor(tierColors[tweet.tier] || 0x1DA1F2)\n    .setAuthor({ \n      name: `@${tweet.authorHandle}`, \n      url: `https://twitter.com/${tweet.authorHandle}`,\n      iconURL: 'https://abs.twimg.com/icons/apple-touch-icon-192x192.png'\n    })\n    .setDescription(\n      `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n      `**💰 Earn ${tweet.bonusMultiplier}x points:**\\n` +\n      `❤️ Like: ${likePoints} pts | 🔁 RT: ${retweetPoints} pts | 💬 Reply: ${replyPoints} pts`\n    )\n    .addFields(\n      { name: 'Tier', value: `⭐ ${tweet.tier}`, inline: true },\n      { name: 'Category', value: `${tweet.category}`, inline: true },\n      { name: 'Submitted', value: `<t:${Math.floor(new Date(tweet.submittedAt).getTime() / 1000)}:R>`, inline: true }\n    )\n    .setFooter({ text: `Submitted by ${submitterName}` })\n  \n  if (includeButtons) {\n    // Create clickable button for the tweet\n    const row = new ActionRowBuilder()\n      .addComponents(\n        new ButtonBuilder()\n          .setLabel('View & Engage')\n          .setStyle(ButtonStyle.Link)\n          .setURL(tweet.url)\n          .setEmoji('🐦')\n      )\n    \n    return { embeds: [embed], components: [row] }\n  }\n  \n  return { embeds: [embed] }\n}\n\n// Handle slash commands\nclient.on('ready', async () => {\n  console.log(`✅ Engagement bot (fixed) logged in as ${client.user.tag}`)\n  \n  // Start checking for channel info requests\n  setInterval(async () => {\n    try {\n      // Look for any channel info requests\n      const keys = await redis.keys('discord:channel-info-request:*')\n      \n      for (const key of keys) {\n        const request = await redis.get(key)\n        if (!request) continue\n        \n        let channelId, serverId, projectId\n        try {\n          // Upstash Redis returns the parsed object directly\n          const parsed = typeof request === 'string' ? JSON.parse(request) : request\n          channelId = parsed.channelId\n          serverId = parsed.serverId\n          projectId = parsed.projectId\n        } catch (parseError) {\n          console.error(`Error parsing channel info request from ${key}:`, parseError)\n          console.error('Raw request data:', request)\n          await redis.del(key)\n          continue\n        }\n        \n        // Try to fetch the channel\n        try {\n          console.log(`[DEBUG] Looking for guild ${serverId}`)\n          console.log(`[DEBUG] Available guilds: ${client.guilds.cache.map(g => `${g.name} (${g.id})`).join(', ')}`)\n          \n          const guild = client.guilds.cache.get(serverId)\n          if (!guild) {\n            console.log(`Guild ${serverId} not found in cache`)\n            continue\n          }\n          \n          const channel = guild.channels.cache.get(channelId)\n          if (channel) {\n            // Store the response\n            const responseKey = `discord:channel-info-response:${channelId}`\n            await redis.set(responseKey, JSON.stringify({\n              id: channelId,\n              name: channel.name,\n              type: channel.type === 0 ? 'text' : 'voice'\n            }), {\n              ex: 60 // expire in 60 seconds\n            })\n            \n            // Also store permanent channel metadata\n            const channelMetadataKey = `channel:discord:${channelId}`\n            await redis.json.set(channelMetadataKey, '$', {\n              id: channelId,\n              name: channel.name,\n              type: channel.type === 0 ? 'text' : 'voice',\n              projectId: projectId || null,\n              updatedAt: new Date().toISOString()\n            })\n            \n            console.log(`✅ Fetched channel info: #${channel.name} (${channelId})`)\n          } else {\n            console.log(`Channel ${channelId} not found in guild ${serverId}`)\n          }\n        } catch (error) {\n          console.error(`Error fetching channel ${channelId}:`, error)\n        }\n        \n        // Delete the request\n        await redis.del(key)\n      }\n    } catch (error) {\n      console.error('Error processing channel info requests:', error)\n    }\n  }, 2000) // Check every 2 seconds\n  \n  // Register slash commands\n  const commands = [\n    {\n      name: 'connect',\n      description: 'Connect your Twitter account'\n    },\n    {\n      name: 'submit',\n      description: 'Submit a tweet for engagement tracking',\n      options: [{\n        name: 'url',\n        type: 3, // STRING\n        description: 'The tweet URL',\n        required: true\n      }, {\n        name: 'category',\n        type: 3,\n        description: 'Tweet category (optional)',\n        required: false\n      }]\n    },\n    {\n      name: 'stats',\n      description: 'View your engagement stats'\n    },\n    {\n      name: 'leaderboard',\n      description: 'View the engagement leaderboard'\n    },\n    {\n      name: 'recent',\n      description: 'View recently submitted tweets'\n    },\n    {\n      name: 'tier',\n      description: 'Admin: Set user tier',\n      options: [{\n        name: 'user',\n        type: 6, // USER\n        description: 'The user to update',\n        required: true\n      }, {\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }]\n    },\n    {\n      name: 'scenarios',\n      description: 'Admin: Configure tier scenarios',\n      options: [{\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }, {\n        name: 'daily_limit',\n        type: 4,\n        description: 'Daily tweet limit',\n        required: false\n      }, {\n        name: 'min_followers',\n        type: 4,\n        description: 'Minimum followers required',\n        required: false\n      }, {\n        name: 'bonus_multiplier',\n        type: 10, // DOUBLE\n        description: 'Points bonus multiplier',\n        required: false\n      }]\n    }\n  ]\n  \n  try {\n    await client.application.commands.set(commands)\n    console.log('✅ Slash commands registered')\n  } catch (error) {\n    console.error('Error registering commands:', error)\n  }\n})\n\n// Handle interactions\nclient.on('interactionCreate', async (interaction) => {\n  // Handle slash commands\n  if (interaction.isCommand()) {\n    const { commandName } = interaction\n    \n    if (commandName === 'connect') {\n      // Show modal for Twitter handle input\n      const modal = new ModalBuilder()\n        .setCustomId('connect-twitter')\n        .setTitle('Connect Twitter Account')\n      \n      const handleInput = new TextInputBuilder()\n        .setCustomId('twitter-handle')\n        .setLabel('Your Twitter Handle')\n        .setPlaceholder('@yourusername')\n        .setStyle(TextInputStyle.Short)\n        .setRequired(true)\n      \n      const row = new ActionRowBuilder().addComponents(handleInput)\n      modal.addComponents(row)\n      \n      await interaction.showModal(modal)\n    }\n    \n    else if (commandName === 'submit') {\n      await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n      \n      const url = interaction.options.getString('url')\n      const category = interaction.options.getString('category')\n      \n      // Validate URL\n      const tweetId = extractTweetId(url)\n      if (!tweetId) {\n        await interaction.editReply('❌ Invalid tweet URL. Please provide a valid Twitter/X URL.')\n        return\n      }\n      \n      // Check if user is connected\n      const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n      if (!connection) {\n        await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n        return\n      }\n      \n      // Check if user is still approved\n      const { approved } = await isUserApproved(connection.twitterHandle)\n      if (!approved) {\n        await interaction.editReply('❌ Your Twitter account is no longer approved. Please contact an admin.')\n        return\n      }\n      \n      // Check tier scenarios\n      const scenarios = await getTierScenarios(connection.tier)\n      \n      // Check daily limit\n      const today = new Date().toISOString().split('T')[0]\n      const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n      \n      if (dailySubmissions >= scenarios.dailyTweetLimit) {\n        await interaction.editReply(`❌ You've reached your daily limit of ${scenarios.dailyTweetLimit} tweets for Tier ${connection.tier}.`)\n        return\n      }\n      \n      // Check for duplicate\n      const isDuplicate = await redis.exists(`engagement:tweetid:${tweetId}`)\n      if (isDuplicate) {\n        await interaction.editReply('❌ This tweet has already been submitted.')\n        return\n      }\n      \n      // Extract author handle\n      const authorHandle = extractTwitterHandle(url)\n      \n      // Check if submitter is author or admin\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin && connection.twitterHandle !== authorHandle) {\n        await interaction.editReply('❌ You can only submit your own tweets. Admins can submit any tweet.')\n        return\n      }\n      \n      // Validate category\n      let finalCategory = category\n      if (category && !scenarios.categories.includes(category)) {\n        await interaction.editReply(`❌ Invalid category. Available categories for Tier ${connection.tier}: ${scenarios.categories.join(', ')}`)\n        return\n      }\n      \n      if (!finalCategory) {\n        finalCategory = 'General'\n      }\n      \n      // Submit tweet\n      try {\n        const { nanoid } = await import('nanoid')\n        // Try to fetch tweet content from Twitter API\n        let tweetContent = null\n        try {\n          const response = await fetch(`https://api.twitter.com/2/tweets/${tweetId}?tweet.fields=text`, {\n            headers: {\n              'Authorization': `Bearer ${process.env.TWITTER_BEARER_TOKEN}`\n            }\n          })\n          \n          if (response.ok) {\n            const tweetData = await response.json()\n            tweetContent = tweetData.data?.text || null\n            console.log('📝 Fetched tweet content:', tweetContent ? 'Success' : 'No content')\n          }\n        } catch (error) {\n          console.log('⚠️ Could not fetch tweet content:', error.message)\n        }\n\n        const tweet = {\n          id: nanoid(),\n          tweetId,\n          submitterDiscordId: interaction.user.id,\n          submittedAt: new Date(),\n          category: finalCategory,\n          url,\n          authorHandle,\n          content: tweetContent,\n          tier: connection.tier,\n          bonusMultiplier: scenarios.bonusMultiplier\n        }\n        \n        await redis.json.set(`engagement:tweet:${tweet.id}`, '$', tweet)\n        // Store in sorted set for admin panel compatibility\n        await redis.zadd('engagement:tweets:recent', { score: Date.now(), member: tweet.id })\n        await redis.set(`engagement:tweetid:${tweet.tweetId}`, tweet.id)\n        \n        // Increment daily counter\n        await redis.incr(`engagement:daily:${interaction.user.id}:${today}`)\n        await redis.expire(`engagement:daily:${interaction.user.id}:${today}`, 86400) // 24 hours\n        \n        // Send to channel\n        const channel = interaction.guild.channels.cache.find(ch => ch.name === BOT_CHANNEL_NAME)\n        if (channel) {\n          // Debug: Check bot permissions in channel\n          const botMember = interaction.guild.members.cache.get(client.user.id)\n          const perms = channel.permissionsFor(botMember)\n          console.log(`Bot permissions in #${BOT_CHANNEL_NAME}:`, {\n            viewChannel: perms.has('ViewChannel'),\n            sendMessages: perms.has('SendMessages'),\n            embedLinks: perms.has('EmbedLinks'),\n            readMessageHistory: perms.has('ReadMessageHistory'),\n            useExternalEmojis: perms.has('UseExternalEmojis')\n          })\n          try {\n            const messageContent = createTweetEmbed(tweet, interaction.user.username)\n            await channel.send(messageContent)\n            console.log(`✅ Posted tweet preview to #${BOT_CHANNEL_NAME}`)\n          } catch (channelError) {\n            console.error('Error posting to channel:', channelError)\n            console.log('Make sure the bot has permission to send messages in #engagement-tracker')\n            console.log('Required permissions: View Channel, Send Messages, Embed Links')\n            \n            // Try sending without buttons as fallback\n            try {\n              console.log('Attempting to send without buttons...')\n              const simpleEmbed = createTweetEmbed(tweet, interaction.user.username, false)\n              await channel.send(simpleEmbed)\n              console.log('✅ Sent simplified preview without buttons')\n            } catch (fallbackError) {\n              console.error('Even simple embed failed:', fallbackError)\n              console.log('Bot may lack basic permissions in the channel')\n              \n              // Last resort - send plain text\n              try {\n                const plainMessage = `**@${tweet.authorHandle}**\\n` +\n                  `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n                  `💰 Earn ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | ${tweet.category}\\n` +\n                  `🔗 ${tweet.url}`\n                await channel.send(plainMessage)\n                console.log('✅ Sent plain text preview')\n              } catch (textError) {\n                console.error('Cannot send any message to channel:', textError)\n              }\n            }\n          }\n        } else {\n          console.log(`Channel \"${BOT_CHANNEL_NAME}\" not found. Please create it for tweet announcements.`)\n        }\n        \n        await interaction.editReply(`✅ Tweet submitted successfully! (${parseInt(dailySubmissions) + 1}/${scenarios.dailyTweetLimit} today)`)\n      } catch (error) {\n        console.error('Error submitting tweet:', error)\n        await interaction.editReply('❌ An error occurred while submitting the tweet. Please try again.')\n      }\n    }\n    \n    else if (commandName === 'stats') {\n      await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n      \n      const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n      if (!connection) {\n        await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n        return\n      }\n      \n      // Get tier scenarios\n      const scenarios = await getTierScenarios(connection.tier)\n      \n      // Get today's submissions\n      const today = new Date().toISOString().split('T')[0]\n      const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n      \n      // Get recent engagements (skip for now since we don't have logs yet)\n      const logs = []\n      \n      const embed = new EmbedBuilder()\n        .setColor(0x00FF00)\n        .setTitle('📊 Your Engagement Stats')\n        .setDescription(`**Twitter:** @${connection.twitterHandle}\\n**Tier:** ${connection.tier ? connection.tier.toUpperCase() : 'MICRO'}\\n**Total Points:** ${connection.totalPoints || 0}`)\n        .addFields(\n          { name: 'Daily Limit', value: `${dailySubmissions}/${scenarios.dailyTweetLimit}`, inline: true },\n          { name: 'Bonus Multiplier', value: `${scenarios.bonusMultiplier}x`, inline: true },\n          { name: 'Categories', value: scenarios.categories.join(', '), inline: false }\n        )\n        .setTimestamp()\n      \n      if (logs.length > 0) {\n        const recentActivity = logs.map(log => \n          `${log.interactionType === 'like' ? '❤️' : log.interactionType === 'retweet' ? '🔁' : '💬'} +${log.points} points`\n        ).join('\\n')\n        embed.addFields({ name: 'Recent Activity', value: recentActivity })\n      }\n      \n      await interaction.editReply({ embeds: [embed] })\n    }\n    \n    else if (commandName === 'leaderboard') {\n      await interaction.deferReply()\n      \n      // Get leaderboard data\n      const keys = await redis.keys('engagement:connection:*')\n      const entries = []\n      \n      for (const key of keys.slice(0, 50)) {\n        const connection = await redis.json.get(key)\n        if (connection) {\n          entries.push({\n            discordId: connection.discordId,\n            twitterHandle: connection.twitterHandle,\n            totalPoints: connection.totalPoints || 0,\n            tier: connection.tier\n          })\n        }\n      }\n      \n      // Sort by points\n      entries.sort((a, b) => b.totalPoints - a.totalPoints)\n      \n      const embed = new EmbedBuilder()\n        .setColor(0xFFD700) // Gold\n        .setTitle('🏆 Engagement Leaderboard')\n        .setDescription('Top 10 Engagers')\n        .setTimestamp()\n      \n      const top10 = entries.slice(0, 10).map((entry, index) => {\n        const tierEmoji = {\n          'micro': '⚪',\n          'rising': '🟢',\n          'star': '⭐',\n          'legend': '🟠',\n          'hero': '👑'\n        }[entry.tier] || '⚪'\n        return `**${index + 1}.** @${entry.twitterHandle} ${tierEmoji} ${entry.tier ? entry.tier.toUpperCase() : 'MICRO'} - ${entry.totalPoints} points`\n      }).join('\\n')\n      \n      embed.addFields({ name: 'Rankings', value: top10 || 'No data yet' })\n      \n      await interaction.editReply({ embeds: [embed] })\n    }\n    \n    else if (commandName === 'recent') {\n      await interaction.deferReply()\n      \n      try {\n        // Get recent tweets from sorted set\n        const tweetIds = await redis.zrange('engagement:tweets:recent', 0, 9, { rev: true }) // Get last 10\n        const tweets = []\n        \n        for (const id of tweetIds) {\n          const tweet = await redis.json.get(`engagement:tweet:${id}`)\n          if (tweet) tweets.push(tweet)\n        }\n        \n        const embed = new EmbedBuilder()\n          .setColor(0x1DA1F2) // Twitter blue\n          .setTitle('🐦 Recent Tweets for Engagement')\n          .setDescription('Click on any tweet to engage and earn points!')\n          .setTimestamp()\n        \n        if (tweets.length === 0) {\n          embed.addFields({ name: 'No tweets yet', value: 'Be the first to submit a tweet with `/submit`!' })\n        } else {\n          let tweetList = ''\n          tweets.forEach((tweet, index) => {\n            tweetList += `**${index + 1}. @${tweet.authorHandle}**\\n`\n            if (tweet.content) {\n              tweetList += `\"${tweet.content.substring(0, 100)}${tweet.content.length > 100 ? '...' : ''}\"\\n`\n            }\n            tweetList += `💰 ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | [View Tweet](${tweet.url})\\n\\n`\n          })\n          embed.addFields({ name: 'Recent Tweets', value: tweetList || 'No tweets yet' })\n        }\n        \n        await interaction.editReply({ embeds: [embed] })\n      } catch (error) {\n        console.error('Error in /recent command:', error)\n        await interaction.editReply('❌ An error occurred while fetching recent tweets.')\n      }\n    }\n    \n    else if (commandName === 'tier') {\n      // Admin only\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin) {\n        await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n        return\n      }\n      \n      const user = interaction.options.getUser('user')\n      const tier = interaction.options.getString('tier')\n      \n      const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n      if (!validTiers.includes(tier)) {\n        await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n        return\n      }\n      \n      const connection = await redis.json.get(`engagement:connection:${user.id}`)\n      if (!connection) {\n        await interaction.reply({ content: '❌ User has not connected their Twitter account.', flags: 64 })\n        return\n      }\n      \n      await redis.json.set(`engagement:connection:${user.id}`, '$.tier', tier)\n      await interaction.reply({ content: `✅ Updated ${user.username}'s tier to ${tier.toUpperCase()}`, flags: 64 })\n    }\n    \n    else if (commandName === 'scenarios') {\n      // Admin only\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin) {\n        await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n        return\n      }\n      \n      const tier = interaction.options.getString('tier')\n      const dailyLimit = interaction.options.getInteger('daily_limit')\n      const minFollowers = interaction.options.getInteger('min_followers')\n      const bonusMultiplier = interaction.options.getNumber('bonus_multiplier')\n      \n      const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n      if (!validTiers.includes(tier)) {\n        await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n        return\n      }\n      \n      // Get current scenarios\n      const currentScenarios = await getTierScenarios(tier)\n      \n      // Update with new values\n      if (dailyLimit !== null) currentScenarios.dailyTweetLimit = dailyLimit\n      if (minFollowers !== null) currentScenarios.minFollowers = minFollowers\n      if (bonusMultiplier !== null) currentScenarios.bonusMultiplier = bonusMultiplier\n      \n      // Save scenarios\n      await redis.json.set(`engagement:scenarios:${tier}`, '$', currentScenarios)\n      \n      await interaction.reply({ \n        content: `✅ Updated ${tier.toUpperCase()} tier scenarios:\\n` +\n                 `Daily Limit: ${currentScenarios.dailyTweetLimit}\\n` +\n                 `Min Followers: ${currentScenarios.minFollowers}\\n` +\n                 `Bonus Multiplier: ${currentScenarios.bonusMultiplier}x`,\n        flags: 64 \n      })\n    }\n  }\n  \n  // Handle modal submissions\n  else if (interaction.isModalSubmit()) {\n    if (interaction.customId === 'connect-twitter') {\n      const handle = interaction.fields.getTextInputValue('twitter-handle')\n      const cleanHandle = handle.toLowerCase().replace('@', '').trim()\n      \n      // Check if user exists\n      const { approved, userData, exists } = await isUserApproved(cleanHandle)\n      \n      // If user doesn't exist, create a new profile\n      if (!exists) {\n        try {\n          const newUser = await createUserProfile(cleanHandle, interaction.user.id)\n          console.log(`✅ Created new profile for @${cleanHandle}`)\n          \n          // Create connection with the new user data\n          const connection = {\n            discordId: interaction.user.id,\n            twitterHandle: cleanHandle,\n            tier: newUser.tier || 'micro',\n            connectedAt: new Date(),\n            totalPoints: 0,\n            role: newUser.role || 'kol'\n          }\n          \n          await redis.json.set(`engagement:connection:${interaction.user.id}`, '$', connection)\n          await redis.set(`engagement:twitter:${cleanHandle}`, interaction.user.id)\n          \n          // Try to assign Discord KOL role\n          try {\n            const member = await interaction.guild.members.fetch(interaction.user.id)\n            const kolRole = interaction.guild.roles.cache.find(role => role.name.toLowerCase() === KOL_ROLE_NAME)\n            \n            if (kolRole && member && !member.roles.cache.has(kolRole.id)) {\n              const botMember = interaction.guild.members.cache.get(client.user.id)\n              if (botMember.permissions.has('ManageRoles') && botMember.roles.highest.position > kolRole.position) {\n                await member.roles.add(kolRole)\n                console.log(`✅ Assigned KOL role to ${member.user.tag}`)\n              }\n            }\n          } catch (roleError) {\n            console.error('Error assigning Discord role:', roleError)\n          }\n          \n          await interaction.reply({ \n            content: `✅ Welcome! Your Twitter account @${cleanHandle} has been connected and approved!\\n🎉 You've been assigned the KOL role and can now start submitting tweets.`, \n            flags: 64 \n          })\n          return\n        } catch (error) {\n          console.error('Error creating new user profile:', error)\n          await interaction.reply({ \n            content: '❌ An error occurred while creating your profile. Please try again or contact an admin.', \n            flags: 64 \n          })\n          return\n        }\n      }\n      \n      // If user exists but is not approved\n      if (!approved) {\n        await interaction.reply({ \n          content: '❌ Your Twitter account exists but is not approved. Please contact an admin for approval.', \n          flags: 64 \n        })\n        return\n      }\n      \n      // Check if handle is already connected to another Discord account\n      const existingDiscordId = await redis.get(`engagement:twitter:${cleanHandle}`)\n      if (existingDiscordId && existingDiscordId !== interaction.user.id) {\n        await interaction.reply({ \n          content: '❌ This Twitter account is already connected to another Discord user.', \n          flags: 64 \n        })\n        return\n      }\n      \n      // User exists and is approved - create connection\n      const currentRole = userData.role || 'user'\n      \n      // Assign KOL role if user doesn't have a higher role\n      let finalRole = currentRole\n      if (ROLE_HIERARCHY[currentRole] < ROLE_HIERARCHY['kol']) {\n        finalRole = 'kol'\n        await updateUserRole(cleanHandle, 'kol')\n        \n        // Also assign Discord role if available\n        try {\n          const member = await interaction.guild.members.fetch(interaction.user.id)\n          const kolRole = interaction.guild.roles.cache.find(role => role.name.toLowerCase() === KOL_ROLE_NAME)\n          \n          if (kolRole) {\n            // Check if bot has permission to manage roles\n            const botMember = interaction.guild.members.cache.get(client.user.id)\n            if (!botMember.permissions.has('ManageRoles')) {\n              console.warn('⚠️  Bot lacks \"Manage Roles\" permission - cannot assign KOL role')\n              console.log('   Please grant the bot \"Manage Roles\" permission in Discord')\n            } \n            // Check if bot's highest role is above the KOL role\n            else if (botMember.roles.highest.position <= kolRole.position) {\n              console.warn('⚠️  Bot\\'s role is not high enough to assign the KOL role')\n              console.log('   Please move the bot\\'s role above the KOL role in Discord settings')\n            }\n            // Try to assign the role\n            else if (!member.roles.cache.has(kolRole.id)) {\n              await member.roles.add(kolRole)\n              console.log(`✅ Assigned KOL role to ${member.user.tag}`)\n            }\n          } else {\n            console.warn(`⚠️  No role found with name \"${KOL_ROLE_NAME}\" (case-insensitive)`)\n            console.log('   Please create a role named \"kol\" in your Discord server')\n          }\n        } catch (error) {\n          console.error('❌ Error assigning Discord role:', error.message)\n          if (error.code === 50013) {\n            console.log('   This is a permissions issue. Please check:')\n            console.log('   1. Bot has \"Manage Roles\" permission')\n            console.log('   2. Bot\\'s role is above the KOL role in the hierarchy')\n          }\n        }\n      }\n      \n      // Create connection - get tier from user profile\n      const userTier = userData.tier || 'micro'  // Default to micro if no tier\n      const connection = {\n        discordId: interaction.user.id,\n        twitterHandle: cleanHandle,\n        tier: userTier,\n        connectedAt: new Date(),\n        totalPoints: 0,\n        role: finalRole\n      }\n      \n      await redis.json.set(`engagement:connection:${interaction.user.id}`, '$', connection)\n      await redis.set(`engagement:twitter:${cleanHandle}`, interaction.user.id)\n      \n      let message = `✅ Successfully connected Twitter account @${cleanHandle}!`\n      if (finalRole === 'kol' && currentRole !== 'kol') {\n        message += '\\n🎉 You\\'ve been assigned the KOL role!'\n      }\n      \n      await interaction.reply({ \n        content: message, \n        flags: 64 \n      })\n    }\n  }\n})\n\n// Error handling\nclient.on('error', console.error)\n\n// Handle regular messages (for ping/pong)\nclient.on('messageCreate', async (message) => {\n  // Ignore messages from bots\n  if (message.author.bot) return\n  \n  // Simple ping/pong response\n  if (message.content.toLowerCase() === 'ping' || message.content.toLowerCase() === '!ping') {\n    try {\n      await message.reply('pong! 🏓')\n      console.log(`Replied to ping from ${message.author.tag}`)\n    } catch (error) {\n      console.error('Error replying to ping:', error)\n    }\n  }\n})\n\n// Login\nclient.login(process.env.DISCORD_BOT_TOKEN)\n  .then(() => console.log('🚀 Engagement bot (fixed) starting...'))\n  .catch(console.error) \n  .catch(console.error) ",
    "fixed": "const { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle } = require('discord.js')\nconst { config } = require('dotenv')\nconst { Redis } = require('@upstash/redis')\nconst { GoogleGenerativeAI } = require('@google/generative-ai')\nconst path = require('path')\nconst { nanoid } = require('nanoid')\n\n// Load environment variables from parent directory\nconst envPath = path.join(__dirname, '..', '.env.local')\nconsole.log('🔍 Loading environment from:', envPath)\nconfig({ path: envPath })\n\n// Check required environment variables\nconst requiredVars = ['UPSTASH_REDIS_REST_URL', 'UPSTASH_REDIS_REST_TOKEN', 'DISCORD_BOT_TOKEN']\nconst optionalVars = ['GEMINI_API_KEY', 'GOOGLE_AI_API_KEY'] // Try both for compatibility\nconst missingVars = requiredVars.filter(v => !process.env[v])\n\n// Check for Gemini/Google AI key\nconst hasAiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n\nif (missingVars.length > 0) {\n  console.error('❌ Missing required environment variables:', missingVars.join(', '))\n  console.error('🔍 Please check your .env.local file contains:')\n  missingVars.forEach(v => console.error(`   ${v}=your_value_here`))\n  process.exit(1)\n}\n\nif (!hasAiKey) {\n  console.warn('⚠️  No AI API key found (GEMINI_API_KEY or GOOGLE_AI_API_KEY)')\n  console.warn('   Sentiment analysis will be disabled')\n}\n\n// Initialize Redis\nconst redis = new Redis({\n  url: process.env.UPSTASH_REDIS_REST_URL,\n  token: process.env.UPSTASH_REDIS_REST_TOKEN\n})\n\n// Initialize Gemini for sentiment analysis (if available)\nlet genAI = null\nlet model = null\n\nif (hasAiKey) {\n  const apiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n  genAI = new GoogleGenerativeAI(apiKey)\n  model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' })\n  console.log('✅ AI model initialized for sentiment analysis')\n}\n\n// Initialize Discord client\nconst client = new Client({\n  intents: [\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildMessages,\n    GatewayIntentBits.MessageContent,\n    GatewayIntentBits.GuildMessageReactions,\n    GatewayIntentBits.GuildMembers\n  ]\n})\n\n// Tweet URL regex\nconst TWEET_REGEX = /https?:\\/\\/(twitter\\.com|x\\.com)\\/[\\w]+\\/status\\/(\\d+)/i\n\n// Bot configuration\nconst BOT_CHANNEL_NAME = 'engagement-tracker'\nconst ADMIN_ROLE_NAME = 'admin'\nconst KOL_ROLE_NAME = 'kol'\n\n// Role hierarchy (higher number = higher priority)\nconst ROLE_HIERARCHY = {\n  'admin': 4,\n  'core': 3,\n  'team': 2,\n  'kol': 1,\n  'user': 0\n}\n\n// Helper function to extract tweet ID from URL\nfunction extractTweetId(url) {\n  const match = url.match(TWEET_REGEX)\n  return match ? match[2] : null\n}\n\n// Helper function to extract Twitter handle from URL\nfunction extractTwitterHandle(url) {\n  const match = url.match(/https?:\\/\\/(twitter\\.com|x\\.com)\\/([\\w]+)\\/status/)\n  return match ? match[2] : null\n}\n\n// Create a new user profile\nasync function createUserProfile(twitterHandle, discordId) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userId = `user_${normalizedHandle}`\n    \n    const newUser = {\n      id: userId,\n      twitterHandle: `@${normalizedHandle}`,\n      name: normalizedHandle, // Use handle as name initially\n      approvalStatus: 'approved', // Auto-approve for engagement bot\n      role: 'kol', // Default to KOL role for engagement\n      tier: 'micro', // Default tier\n      discordId: discordId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      socialAccounts: {\n        twitter: {\n          handle: normalizedHandle,\n          connected: true\n        }\n      }\n    }\n    \n    // Save to Redis\n    await redis.json.set(userId, '$', newUser)\n    \n    // Create username index\n    await redis.sadd(`idx:username:${normalizedHandle}`, userId)\n    \n    // Add to approved users set\n    await redis.sadd('users:approved', userId)\n    \n    console.log(`✅ Created new user profile for @${normalizedHandle}`)\n    return newUser\n  } catch (error) {\n    console.error('Error creating user profile:', error)\n    throw error\n  }\n}\n\n// Check if user is approved in the database\nasync function isUserApproved(twitterHandle) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    \n    // Check if user exists via username index\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    if (!userIds || userIds.length === 0) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Get user data\n    const userData = await redis.json.get(`user:${userIds[0]}`)\n    if (!userData) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Check approval status\n    const isApproved = userData.approvalStatus === 'approved'\n    return { approved: isApproved, userData, exists: true }\n  } catch (error) {\n    console.error('Error checking user approval:', error)\n    return { approved: false, userData: null, exists: false }\n  }\n}\n\n// Get user's current role from database\nasync function getUserRole(twitterHandle) {\n  try {\n    const { approved, userData } = await isUserApproved(twitterHandle)\n    if (!approved || !userData) return 'user'\n    \n    return userData.role || 'user'\n  } catch (error) {\n    console.error('Error getting user role:', error)\n    return 'user'\n  }\n}\n\n// Update user's role in database\nasync function updateUserRole(twitterHandle, newRole) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    \n    if (userIds && userIds.length > 0) {\n      await redis.json.set(`user:${userIds[0]}`, '$.role', newRole)\n      return true\n    }\n    return false\n  } catch (error) {\n    console.error('Error updating user role:', error)\n    return false\n  }\n}\n\n// Get tier-based scenarios\nasync function getTierScenarios(tier) {\n  try {\n    const safeTier = tier || 'micro' // Default to micro if tier is null/undefined\n    const scenarios = await redis.json.get(`engagement:scenarios:${safeTier}`)\n    return scenarios || getDefaultScenarios(safeTier)\n  } catch (error) {\n    console.error('Error getting tier scenarios:', error)\n    return getDefaultScenarios(tier || 'micro')\n  }\n}\n\n// Default scenarios by tier\nfunction getDefaultScenarios(tier) {\n  const scenarios = {\n    'micro': {\n      dailyTweetLimit: 5,\n      categories: ['General', 'DeFi', 'NFT'],\n      minFollowers: 100,\n      bonusMultiplier: 1.0\n    },\n    'rising': {\n      dailyTweetLimit: 10,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech'],\n      minFollowers: 500,\n      bonusMultiplier: 1.5\n    },\n    'star': {\n      dailyTweetLimit: 20,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News'],\n      minFollowers: 1000,\n      bonusMultiplier: 2.0\n    },\n    'legend': {\n      dailyTweetLimit: 30,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special'],\n      minFollowers: 5000,\n      bonusMultiplier: 2.5\n    },\n    'hero': {\n      dailyTweetLimit: 50,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special', 'VIP'],\n      minFollowers: 10000,\n      bonusMultiplier: 3.0\n    }\n  }\n  \n  return scenarios[tier] || scenarios['micro']\n}\n\n// Create minimal tweet embed with preview\nfunction createTweetEmbed(tweet, submitterName, includeButtons = true) {\n  // Choose color based on tier\n  const tierColors = {\n    'micro': 0x6B7280,  // Gray\n    'rising': 0x3BA55D, // Green\n    'star': 0x5865F2,   // Blue\n    'legend': 0xEA580C, // Orange\n    'hero': 0x9333EA    // Purple\n  }\n  \n  // Calculate potential points\n  const likePoints = Math.floor(10 * tweet.bonusMultiplier)\n  const retweetPoints = Math.floor(20 * tweet.bonusMultiplier)\n  const replyPoints = Math.floor(30 * tweet.bonusMultiplier)\n  \n  const embed = new EmbedBuilder()\n    .setColor(tierColors[tweet.tier] || 0x1DA1F2)\n    .setAuthor({ \n      name: `@${tweet.authorHandle}`, \n      url: `https://twitter.com/${tweet.authorHandle}`,\n      iconURL: 'https://abs.twimg.com/icons/apple-touch-icon-192x192.png'\n    })\n    .setDescription(\n      `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n      `**💰 Earn ${tweet.bonusMultiplier}x points:**\\n` +\n      `❤️ Like: ${likePoints} pts | 🔁 RT: ${retweetPoints} pts | 💬 Reply: ${replyPoints} pts`\n    )\n    .addFields(\n      { name: 'Tier', value: `⭐ ${tweet.tier}`, inline: true },\n      { name: 'Category', value: `${tweet.category}`, inline: true },\n      { name: 'Submitted', value: `<t:${Math.floor(new Date(tweet.submittedAt).getTime() / 1000)}:R>`, inline: true }\n    )\n    .setFooter({ text: `Submitted by ${submitterName}` })\n  \n  if (includeButtons) {\n    // Create clickable button for the tweet\n    const row = new ActionRowBuilder()\n      .addComponents(\n        new ButtonBuilder()\n          .setLabel('View & Engage')\n          .setStyle(ButtonStyle.Link)\n          .setURL(tweet.url)\n          .setEmoji('🐦')\n      )\n    \n    return { embeds: [embed], components: [row] }\n  }\n  \n  return { embeds: [embed] }\n}\n\n// Handle slash commands\nclient.on('ready', async () => {\n  console.log(`✅ Engagement bot (fixed) logged in as ${client.user.tag}`)\n  \n  // Start checking for channel info requests\n  setInterval(async () => {\n    try {\n      // Look for any channel info requests\n      const keys = await redis.keys('discord:channel-info-request:*')\n      \n      for (const key of keys) {\n        const request = await redis.get(key)\n        if (!request) continue\n        \n        let channelId, serverId, projectId\n        try {\n          // Upstash Redis returns the parsed object directly\n          const parsed = typeof request === 'string' ? JSON.parse(request) : request\n          channelId = parsed.channelId\n          serverId = parsed.serverId\n          projectId = parsed.projectId\n        } catch (parseError) {\n          console.error(`Error parsing channel info request from ${key}:`, parseError)\n          console.error('Raw request data:', request)\n          await redis.del(key)\n          continue\n        }\n        \n        // Try to fetch the channel\n        try {\n          console.log(`[DEBUG] Looking for guild ${serverId}`)\n          console.log(`[DEBUG] Available guilds: ${client.guilds.cache.map(g => `${g.name} (${g.id})`).join(', ')}`)\n          \n          const guild = client.guilds.cache.get(serverId)\n          if (!guild) {\n            console.log(`Guild ${serverId} not found in cache`)\n            continue\n          }\n          \n          const channel = guild.channels.cache.get(channelId)\n          if (channel) {\n            // Store the response\n            const responseKey = `discord:channel-info-response:${channelId}`\n            await redis.set(responseKey, JSON.stringify({\n              id: channelId,\n              name: channel.name,\n              type: channel.type === 0 ? 'text' : 'voice'\n            }), {\n              ex: 60 // expire in 60 seconds\n            })\n            \n            // Also store permanent channel metadata\n            const channelMetadataKey = `channel:discord:${channelId}`\n            await redis.json.set(channelMetadataKey, '$', {\n              id: channelId,\n              name: channel.name,\n              type: channel.type === 0 ? 'text' : 'voice',\n              projectId: projectId || null,\n              updatedAt: new Date().toISOString()\n            })\n            \n            console.log(`✅ Fetched channel info: #${channel.name} (${channelId})`)\n          } else {\n            console.log(`Channel ${channelId} not found in guild ${serverId}`)\n          }\n        } catch (error) {\n          console.error(`Error fetching channel ${channelId}:`, error)\n        }\n        \n        // Delete the request\n        await redis.del(key)\n      }\n    } catch (error) {\n      console.error('Error processing channel info requests:', error)\n    }\n  }, 2000) // Check every 2 seconds\n  \n  // Register slash commands\n  const commands = [\n    {\n      name: 'connect',\n      description: 'Connect your Twitter account'\n    },\n    {\n      name: 'submit',\n      description: 'Submit a tweet for engagement tracking',\n      options: [{\n        name: 'url',\n        type: 3, // STRING\n        description: 'The tweet URL',\n        required: true\n      }, {\n        name: 'category',\n        type: 3,\n        description: 'Tweet category (optional)',\n        required: false\n      }]\n    },\n    {\n      name: 'stats',\n      description: 'View your engagement stats'\n    },\n    {\n      name: 'leaderboard',\n      description: 'View the engagement leaderboard'\n    },\n    {\n      name: 'recent',\n      description: 'View recently submitted tweets'\n    },\n    {\n      name: 'tier',\n      description: 'Admin: Set user tier',\n      options: [{\n        name: 'user',\n        type: 6, // USER\n        description: 'The user to update',\n        required: true\n      }, {\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }]\n    },\n    {\n      name: 'scenarios',\n      description: 'Admin: Configure tier scenarios',\n      options: [{\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }, {\n        name: 'daily_limit',\n        type: 4,\n        description: 'Daily tweet limit',\n        required: false\n      }, {\n        name: 'min_followers',\n        type: 4,\n        description: 'Minimum followers required',\n        required: false\n      }, {\n        name: 'bonus_multiplier',\n        type: 10, // DOUBLE\n        description: 'Points bonus multiplier',\n        required: false\n      }]\n    }\n  ]\n  \n  try {\n    await client.application.commands.set(commands)\n    console.log('✅ Slash commands registered')\n  } catch (error) {\n    console.error('Error registering commands:', error)\n  }\n})\n\n// Handle interactions\nclient.on('interactionCreate', async (interaction) => {\n  // Handle slash commands\n  if (interaction.isCommand()) {\n    const { commandName } = interaction\n    \n    if (commandName === 'connect') {\n      // Show modal for Twitter handle input\n      const modal = new ModalBuilder()\n        .setCustomId('connect-twitter')\n        .setTitle('Connect Twitter Account')\n      \n      const handleInput = new TextInputBuilder()\n        .setCustomId('twitter-handle')\n        .setLabel('Your Twitter Handle')\n        .setPlaceholder('@yourusername')\n        .setStyle(TextInputStyle.Short)\n        .setRequired(true)\n      \n      const row = new ActionRowBuilder().addComponents(handleInput)\n      modal.addComponents(row)\n      \n      await interaction.showModal(modal)\n    }\n    \n    else if (commandName === 'submit') {\n      await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n      \n      const url = interaction.options.getString('url')\n      const category = interaction.options.getString('category')\n      \n      // Validate URL\n      const tweetId = extractTweetId(url)\n      if (!tweetId) {\n        await interaction.editReply('❌ Invalid tweet URL. Please provide a valid Twitter/X URL.')\n        return\n      }\n      \n      // Check if user is connected\n      const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n      if (!connection) {\n        await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n        return\n      }\n      \n      // Check if user is still approved\n      const { approved } = await isUserApproved(connection.twitterHandle)\n      if (!approved) {\n        await interaction.editReply('❌ Your Twitter account is no longer approved. Please contact an admin.')\n        return\n      }\n      \n      // Check tier scenarios\n      const scenarios = await getTierScenarios(connection.tier)\n      \n      // Check daily limit\n      const today = new Date().toISOString().split('T')[0]\n      const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n      \n      if (dailySubmissions >= scenarios.dailyTweetLimit) {\n        await interaction.editReply(`❌ You've reached your daily limit of ${scenarios.dailyTweetLimit} tweets for Tier ${connection.tier}.`)\n        return\n      }\n      \n      // Check for duplicate\n      const isDuplicate = await redis.exists(`engagement:tweetid:${tweetId}`)\n      if (isDuplicate) {\n        await interaction.editReply('❌ This tweet has already been submitted.')\n        return\n      }\n      \n      // Extract author handle\n      const authorHandle = extractTwitterHandle(url)\n      \n      // Check if submitter is author or admin\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin && connection.twitterHandle !== authorHandle) {\n        await interaction.editReply('❌ You can only submit your own tweets. Admins can submit any tweet.')\n        return\n      }\n      \n      // Validate category\n      let finalCategory = category\n      if (category && !scenarios.categories.includes(category)) {\n        await interaction.editReply(`❌ Invalid category. Available categories for Tier ${connection.tier}: ${scenarios.categories.join(', ')}`)\n        return\n      }\n      \n      if (!finalCategory) {\n        finalCategory = 'General'\n      }\n      \n      // Submit tweet\n      try {\n        const { nanoid } = await import('nanoid')\n        // Try to fetch tweet content from Twitter API\n        let tweetContent = null\n        try {\n          const response = await fetch(`https://api.twitter.com/2/tweets/${tweetId}?tweet.fields=text`, {\n            headers: {\n              'Authorization': `Bearer ${process.env.TWITTER_BEARER_TOKEN}`\n            }\n          })\n          \n          if (response.ok) {\n            const tweetData = await response.json()\n            tweetContent = tweetData.data?.text || null\n            console.log('📝 Fetched tweet content:', tweetContent ? 'Success' : 'No content')\n          }\n        } catch (error) {\n          console.log('⚠️ Could not fetch tweet content:', error.message)\n        }\n\n        const tweet = {\n          id: nanoid(),\n          tweetId,\n          submitterDiscordId: interaction.user.id,\n          submittedAt: new Date(),\n          category: finalCategory,\n          url,\n          authorHandle,\n          content: tweetContent,\n          tier: connection.tier,\n          bonusMultiplier: scenarios.bonusMultiplier\n        }\n        \n        await redis.json.set(`engagement:tweet:${tweet.id}`, '$', tweet)\n        // Store in sorted set for admin panel compatibility\n        await redis.zadd('engagement:tweets:recent', { score: Date.now(), member: tweet.id })\n        await redis.set(`engagement:tweetid:${tweet.tweetId}`, tweet.id)\n        \n        // Increment daily counter\n        await redis.incr(`engagement:daily:${interaction.user.id}:${today}`)\n        await redis.expire(`engagement:daily:${interaction.user.id}:${today}`, 86400) // 24 hours\n        \n        // Send to channel\n        const channel = interaction.guild.channels.cache.find(ch => ch.name === BOT_CHANNEL_NAME)\n        if (channel) {\n          // Debug: Check bot permissions in channel\n          const botMember = interaction.guild.members.cache.get(client.user.id)\n          const perms = channel.permissionsFor(botMember)\n          console.log(`Bot permissions in #${BOT_CHANNEL_NAME}:`, {\n            viewChannel: perms.has('ViewChannel'),\n            sendMessages: perms.has('SendMessages'),\n            embedLinks: perms.has('EmbedLinks'),\n            readMessageHistory: perms.has('ReadMessageHistory'),\n            useExternalEmojis: perms.has('UseExternalEmojis')\n          })\n          try {\n            const messageContent = createTweetEmbed(tweet, interaction.user.username)\n            await channel.send(messageContent)\n            console.log(`✅ Posted tweet preview to #${BOT_CHANNEL_NAME}`)\n          } catch (channelError) {\n            console.error('Error posting to channel:', channelError)\n            console.log('Make sure the bot has permission to send messages in #engagement-tracker')\n            console.log('Required permissions: View Channel, Send Messages, Embed Links')\n            \n            // Try sending without buttons as fallback\n            try {\n              console.log('Attempting to send without buttons...')\n              const simpleEmbed = createTweetEmbed(tweet, interaction.user.username, false)\n              await channel.send(simpleEmbed)\n              console.log('✅ Sent simplified preview without buttons')\n            } catch (fallbackError) {\n              console.error('Even simple embed failed:', fallbackError)\n              console.log('Bot may lack basic permissions in the channel')\n              \n              // Last resort - send plain text\n              try {\n                const plainMessage = `**@${tweet.authorHandle}**\\n` +\n                  `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n                  `💰 Earn ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | ${tweet.category}\\n` +\n                  `🔗 ${tweet.url}`\n                await channel.send(plainMessage)\n                console.log('✅ Sent plain text preview')\n              } catch (textError) {\n                console.error('Cannot send any message to channel:', textError)\n              }\n            }\n          }\n        } else {\n          console.log(`Channel \"${BOT_CHANNEL_NAME}\" not found. Please create it for tweet announcements.`)\n        }\n        \n        await interaction.editReply(`✅ Tweet submitted successfully! (${parseInt(dailySubmissions) + 1}/${scenarios.dailyTweetLimit} today)`)\n      } catch (error) {\n        console.error('Error submitting tweet:', error)\n        await interaction.editReply('❌ An error occurred while submitting the tweet. Please try again.')\n      }\n    }\n    \n    else if (commandName === 'stats') {\n      await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n      \n      const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n      if (!connection) {\n        await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n        return\n      }\n      \n      // Get tier scenarios\n      const scenarios = await getTierScenarios(connection.tier)\n      \n      // Get today's submissions\n      const today = new Date().toISOString().split('T')[0]\n      const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n      \n      // Get recent engagements (skip for now since we don't have logs yet)\n      const logs = []\n      \n      const embed = new EmbedBuilder()\n        .setColor(0x00FF00)\n        .setTitle('📊 Your Engagement Stats')\n        .setDescription(`**Twitter:** @${connection.twitterHandle}\\n**Tier:** ${connection.tier ? connection.tier.toUpperCase() : 'MICRO'}\\n**Total Points:** ${connection.totalPoints || 0}`)\n        .addFields(\n          { name: 'Daily Limit', value: `${dailySubmissions}/${scenarios.dailyTweetLimit}`, inline: true },\n          { name: 'Bonus Multiplier', value: `${scenarios.bonusMultiplier}x`, inline: true },\n          { name: 'Categories', value: scenarios.categories.join(', '), inline: false }\n        )\n        .setTimestamp()\n      \n      if (logs.length > 0) {\n        const recentActivity = logs.map(log => \n          `${log.interactionType === 'like' ? '❤️' : log.interactionType === 'retweet' ? '🔁' : '💬'} +${log.points} points`\n        ).join('\\n')\n        embed.addFields({ name: 'Recent Activity', value: recentActivity })\n      }\n      \n      await interaction.editReply({ embeds: [embed] })\n    }\n    \n    else if (commandName === 'leaderboard') {\n      await interaction.deferReply()\n      \n      // Get leaderboard data\n      const keys = await redis.keys('engagement:connection:*')\n      const entries = []\n      \n      for (const key of keys.slice(0, 50)) {\n        const connection = await redis.json.get(key)\n        if (connection) {\n          entries.push({\n            discordId: connection.discordId,\n            twitterHandle: connection.twitterHandle,\n            totalPoints: connection.totalPoints || 0,\n            tier: connection.tier\n          })\n        }\n      }\n      \n      // Sort by points\n      entries.sort((a, b) => b.totalPoints - a.totalPoints)\n      \n      const embed = new EmbedBuilder()\n        .setColor(0xFFD700) // Gold\n        .setTitle('🏆 Engagement Leaderboard')\n        .setDescription('Top 10 Engagers')\n        .setTimestamp()\n      \n      const top10 = entries.slice(0, 10).map((entry, index) => {\n        const tierEmoji = {\n          'micro': '⚪',\n          'rising': '🟢',\n          'star': '⭐',\n          'legend': '🟠',\n          'hero': '👑'\n        }[entry.tier] || '⚪'\n        return `**${index + 1}.** @${entry.twitterHandle} ${tierEmoji} ${entry.tier ? entry.tier.toUpperCase() : 'MICRO'} - ${entry.totalPoints} points`\n      }).join('\\n')\n      \n      embed.addFields({ name: 'Rankings', value: top10 || 'No data yet' })\n      \n      await interaction.editReply({ embeds: [embed] })\n    }\n    \n    else if (commandName === 'recent') {\n      await interaction.deferReply()\n      \n      try {\n        // Get recent tweets from sorted set\n        const tweetIds = await redis.zrange('engagement:tweets:recent', 0, 9, { rev: true }) // Get last 10\n        const tweets = []\n        \n        for (const id of tweetIds) {\n          const tweet = await redis.json.get(`engagement:tweet:${id}`)\n          if (tweet) tweets.push(tweet)\n        }\n        \n        const embed = new EmbedBuilder()\n          .setColor(0x1DA1F2) // Twitter blue\n          .setTitle('🐦 Recent Tweets for Engagement')\n          .setDescription('Click on any tweet to engage and earn points!')\n          .setTimestamp()\n        \n        if (tweets.length === 0) {\n          embed.addFields({ name: 'No tweets yet', value: 'Be the first to submit a tweet with `/submit`!' })\n        } else {\n          let tweetList = ''\n          tweets.forEach((tweet, index) => {\n            tweetList += `**${index + 1}. @${tweet.authorHandle}**\\n`\n            if (tweet.content) {\n              tweetList += `\"${tweet.content.substring(0, 100)}${tweet.content.length > 100 ? '...' : ''}\"\\n`\n            }\n            tweetList += `💰 ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | [View Tweet](${tweet.url})\\n\\n`\n          })\n          embed.addFields({ name: 'Recent Tweets', value: tweetList || 'No tweets yet' })\n        }\n        \n        await interaction.editReply({ embeds: [embed] })\n      } catch (error) {\n        console.error('Error in /recent command:', error)\n        await interaction.editReply('❌ An error occurred while fetching recent tweets.')\n      }\n    }\n    \n    else if (commandName === 'tier') {\n      // Admin only\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin) {\n        await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n        return\n      }\n      \n      const user = interaction.options.getUser('user')\n      const tier = interaction.options.getString('tier')\n      \n      const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n      if (!validTiers.includes(tier)) {\n        await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n        return\n      }\n      \n      const connection = await redis.json.get(`engagement:connection:${user.id}`)\n      if (!connection) {\n        await interaction.reply({ content: '❌ User has not connected their Twitter account.', flags: 64 })\n        return\n      }\n      \n      await redis.json.set(`engagement:connection:${user.id}`, '$.tier', tier)\n      await interaction.reply({ content: `✅ Updated ${user.username}'s tier to ${tier.toUpperCase()}`, flags: 64 })\n    }\n    \n    else if (commandName === 'scenarios') {\n      // Admin only\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin) {\n        await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n        return\n      }\n      \n      const tier = interaction.options.getString('tier')\n      const dailyLimit = interaction.options.getInteger('daily_limit')\n      const minFollowers = interaction.options.getInteger('min_followers')\n      const bonusMultiplier = interaction.options.getNumber('bonus_multiplier')\n      \n      const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n      if (!validTiers.includes(tier)) {\n        await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n        return\n      }\n      \n      // Get current scenarios\n      const currentScenarios = await getTierScenarios(tier)\n      \n      // Update with new values\n      if (dailyLimit !== null) currentScenarios.dailyTweetLimit = dailyLimit\n      if (minFollowers !== null) currentScenarios.minFollowers = minFollowers\n      if (bonusMultiplier !== null) currentScenarios.bonusMultiplier = bonusMultiplier\n      \n      // Save scenarios\n      await redis.json.set(`engagement:scenarios:${tier}`, '$', currentScenarios)\n      \n      await interaction.reply({ \n        content: `✅ Updated ${tier.toUpperCase()} tier scenarios:\\n` +\n                 `Daily Limit: ${currentScenarios.dailyTweetLimit}\\n` +\n                 `Min Followers: ${currentScenarios.minFollowers}\\n` +\n                 `Bonus Multiplier: ${currentScenarios.bonusMultiplier}x`,\n        flags: 64 \n      })\n    }\n  }\n  \n  // Handle modal submissions\n  else if (interaction.isModalSubmit()) {\n    if (interaction.customId === 'connect-twitter') {\n      const handle = interaction.fields.getTextInputValue('twitter-handle')\n      const cleanHandle = handle.toLowerCase().replace('@', '').trim()\n      \n      // Check if user exists\n      const { approved, userData, exists } = await isUserApproved(cleanHandle)\n      \n      // If user doesn't exist, create a new profile\n      if (!exists) {\n        try {\n          const newUser = await createUserProfile(cleanHandle, interaction.user.id)\n          console.log(`✅ Created new profile for @${cleanHandle}`)\n          \n          // Create connection with the new user data\n          const connection = {\n            discordId: interaction.user.id,\n            twitterHandle: cleanHandle,\n            tier: newUser.tier || 'micro',\n            connectedAt: new Date(),\n            totalPoints: 0,\n            role: newUser.role || 'kol'\n          }\n          \n          await redis.json.set(`engagement:connection:${interaction.user.id}`, '$', connection)\n          await redis.set(`engagement:twitter:${cleanHandle}`, interaction.user.id)\n          \n          // Try to assign Discord KOL role\n          try {\n            const member = await interaction.guild.members.fetch(interaction.user.id)\n            const kolRole = interaction.guild.roles.cache.find(role => role.name.toLowerCase() === KOL_ROLE_NAME)\n            \n            if (kolRole && member && !member.roles.cache.has(kolRole.id)) {\n              const botMember = interaction.guild.members.cache.get(client.user.id)\n              if (botMember.permissions.has('ManageRoles') && botMember.roles.highest.position > kolRole.position) {\n                await member.roles.add(kolRole)\n                console.log(`✅ Assigned KOL role to ${member.user.tag}`)\n              }\n            }\n          } catch (roleError) {\n            console.error('Error assigning Discord role:', roleError)\n          }\n          \n          await interaction.reply({ \n            content: `✅ Welcome! Your Twitter account @${cleanHandle} has been connected and approved!\\n🎉 You've been assigned the KOL role and can now start submitting tweets.`, \n            flags: 64 \n          })\n          return\n        } catch (error) {\n          console.error('Error creating new user profile:', error)\n          await interaction.reply({ \n            content: '❌ An error occurred while creating your profile. Please try again or contact an admin.', \n            flags: 64 \n          })\n          return\n        }\n      }\n      \n      // If user exists but is not approved\n      if (!approved) {\n        await interaction.reply({ \n          content: '❌ Your Twitter account exists but is not approved. Please contact an admin for approval.', \n          flags: 64 \n        })\n        return\n      }\n      \n      // Check if handle is already connected to another Discord account\n      const existingDiscordId = await redis.get(`engagement:twitter:${cleanHandle}`)\n      if (existingDiscordId && existingDiscordId !== interaction.user.id) {\n        await interaction.reply({ \n          content: '❌ This Twitter account is already connected to another Discord user.', \n          flags: 64 \n        })\n        return\n      }\n      \n      // User exists and is approved - create connection\n      const currentRole = userData.role || 'user'\n      \n      // Assign KOL role if user doesn't have a higher role\n      let finalRole = currentRole\n      if (ROLE_HIERARCHY[currentRole] < ROLE_HIERARCHY['kol']) {\n        finalRole = 'kol'\n        await updateUserRole(cleanHandle, 'kol')\n        \n        // Also assign Discord role if available\n        try {\n          const member = await interaction.guild.members.fetch(interaction.user.id)\n          const kolRole = interaction.guild.roles.cache.find(role => role.name.toLowerCase() === KOL_ROLE_NAME)\n          \n          if (kolRole) {\n            // Check if bot has permission to manage roles\n            const botMember = interaction.guild.members.cache.get(client.user.id)\n            if (!botMember.permissions.has('ManageRoles')) {\n              console.warn('⚠️  Bot lacks \"Manage Roles\" permission - cannot assign KOL role')\n              console.log('   Please grant the bot \"Manage Roles\" permission in Discord')\n            } \n            // Check if bot's highest role is above the KOL role\n            else if (botMember.roles.highest.position <= kolRole.position) {\n              console.warn('⚠️  Bot\\'s role is not high enough to assign the KOL role')\n              console.log('   Please move the bot\\'s role above the KOL role in Discord settings')\n            }\n            // Try to assign the role\n            else if (!member.roles.cache.has(kolRole.id)) {\n              await member.roles.add(kolRole)\n              console.log(`✅ Assigned KOL role to ${member.user.tag}`)\n            }\n          } else {\n            console.warn(`⚠️  No role found with name \"${KOL_ROLE_NAME}\" (case-insensitive)`)\n            console.log('   Please create a role named \"kol\" in your Discord server')\n          }\n        } catch (error) {\n          console.error('❌ Error assigning Discord role:', error.message)\n          if (error.code === 50013) {\n            console.log('   This is a permissions issue. Please check:')\n            console.log('   1. Bot has \"Manage Roles\" permission')\n            console.log('   2. Bot\\'s role is above the KOL role in the hierarchy')\n          }\n        }\n      }\n      \n      // Create connection - get tier from user profile\n      const userTier = userData.tier || 'micro'  // Default to micro if no tier\n      const connection = {\n        discordId: interaction.user.id,\n        twitterHandle: cleanHandle,\n        tier: userTier,\n        connectedAt: new Date(),\n        totalPoints: 0,\n        role: finalRole\n      }\n      \n      await redis.json.set(`engagement:connection:${interaction.user.id}`, '$', connection)\n      await redis.set(`engagement:twitter:${cleanHandle}`, interaction.user.id)\n      \n      let message = `✅ Successfully connected Twitter account @${cleanHandle}!`\n      if (finalRole === 'kol' && currentRole !== 'kol') {\n        message += '\\n🎉 You\\'ve been assigned the KOL role!'\n      }\n      \n      await interaction.reply({ \n        content: message, \n        flags: 64 \n      })\n    }\n  }\n})\n\n// Error handling\nclient.on('error', console.error)\n\n// Handle regular messages (for ping/pong)\nclient.on('messageCreate', async (message) => {\n  // Ignore messages from bots\n  if (message.author.bot) return\n  \n  // Simple ping/pong response\n  if (message.content.toLowerCase() === 'ping' || message.content.toLowerCase() === '!ping') {\n    try {\n      await message.reply('pong! 🏓')\n      console.log(`Replied to ping from ${message.author.tag}`)\n    } catch (error) {\n      console.error('Error replying to ping:', error)\n    }\n  }\n})\n\n// Login\nclient.login(process.env.DISCORD_BOT_TOKEN)\n  .then(() => console.log('🚀 Engagement bot (fixed) starting...'))\n  .catch(console.error) \n  .catch(console.error) "
  },
  {
    "file": "discord-bots/engagement-bot-conservative.js",
    "original": "const { nanoid } = require('nanoid')\n\n// Create a new user profile (pending approval)\nasync function createUserProfile(twitterHandle, discordId) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userId = `user:${nanoid()}`\n    \n    const newUser = {\n      id: userId,\n      twitterHandle: `@${normalizedHandle}`,\n      name: normalizedHandle, // Use handle as name initially\n      approvalStatus: 'pending', // Set to pending, requiring admin approval\n      role: 'user', // Default to user role\n      tier: 'micro', // Default tier\n      discordId: discordId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      socialAccounts: {\n        twitter: {\n          handle: normalizedHandle,\n          connected: true\n        }\n      }\n    }\n    \n    // Save to Redis\n    await redis.json.set(userId, '$', newUser)\n    \n    // Create username index\n    await redis.sadd(`idx:username:${normalizedHandle}`, userId)\n    \n    // Add to pending users set (not approved)\n    await redis.sadd('users:pending', userId)\n    \n    console.log(`✅ Created new user profile (pending) for @${normalizedHandle}`)\n    return newUser\n  } catch (error) {\n    console.error('Error creating user profile:', error)\n    throw error\n  }\n}\n\n// Modify the isUserApproved function to return exists flag:\nasync function isUserApproved(twitterHandle) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    \n    // Check if user exists via username index\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    if (!userIds || userIds.length === 0) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Get user data\n    const userData = await redis.json.get(`user:${userIds[0]}`)\n    if (!userData) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Check approval status\n    const isApproved = userData.approvalStatus === 'approved'\n    return { approved: isApproved, userData, exists: true }\n  } catch (error) {\n    console.error('Error checking user approval:', error)\n    return { approved: false, userData: null, exists: false }\n  }\n}\n\n// In the modal submission handler for 'connect-twitter', replace the existing logic with:\nif (interaction.customId === 'connect-twitter') {\n  const handle = interaction.fields.getTextInputValue('twitter-handle')\n  const cleanHandle = handle.toLowerCase().replace('@', '').trim()\n  \n  // Check if user exists\n  const { approved, userData, exists } = await isUserApproved(cleanHandle)\n  \n  // If user doesn't exist, create a new profile (pending approval)\n  if (!exists) {\n    try {\n      const newUser = await createUserProfile(cleanHandle, interaction.user.id)\n      console.log(`✅ Created new profile (pending) for @${cleanHandle}`)\n      \n      await interaction.reply({ \n        content: `📝 Your Twitter account @${cleanHandle} has been registered!\\n\\n` +\n                 `⏳ **Your account is pending approval.** An admin will review and approve your account soon.\\n` +\n                 `📢 You'll be notified once approved and can then use the engagement features.`, \n        flags: 64 \n      })\n      return\n    } catch (error) {\n      console.error('Error creating new user profile:', error)\n      await interaction.reply({ \n        content: '❌ An error occurred while creating your profile. Please try again or contact an admin.', \n        flags: 64 \n      })\n      return\n    }\n  }\n  \n  // If user exists but is not approved\n  if (!approved) {\n    await interaction.reply({ \n      content: '❌ Your Twitter account is pending approval. Please wait for an admin to approve your account.', \n      flags: 64 \n    })\n    return\n  }\n  \n  // Rest of the existing logic for approved users...\n} ",
    "fixed": "const { nanoid } = require('nanoid')\n\n// Create a new user profile (pending approval)\nasync function createUserProfile(twitterHandle, discordId) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userId = `user_${normalizedHandle}`\n    \n    const newUser = {\n      id: userId,\n      twitterHandle: `@${normalizedHandle}`,\n      name: normalizedHandle, // Use handle as name initially\n      approvalStatus: 'pending', // Set to pending, requiring admin approval\n      role: 'user', // Default to user role\n      tier: 'micro', // Default tier\n      discordId: discordId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      socialAccounts: {\n        twitter: {\n          handle: normalizedHandle,\n          connected: true\n        }\n      }\n    }\n    \n    // Save to Redis\n    await redis.json.set(userId, '$', newUser)\n    \n    // Create username index\n    await redis.sadd(`idx:username:${normalizedHandle}`, userId)\n    \n    // Add to pending users set (not approved)\n    await redis.sadd('users:pending', userId)\n    \n    console.log(`✅ Created new user profile (pending) for @${normalizedHandle}`)\n    return newUser\n  } catch (error) {\n    console.error('Error creating user profile:', error)\n    throw error\n  }\n}\n\n// Modify the isUserApproved function to return exists flag:\nasync function isUserApproved(twitterHandle) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    \n    // Check if user exists via username index\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    if (!userIds || userIds.length === 0) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Get user data\n    const userData = await redis.json.get(`user:${userIds[0]}`)\n    if (!userData) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Check approval status\n    const isApproved = userData.approvalStatus === 'approved'\n    return { approved: isApproved, userData, exists: true }\n  } catch (error) {\n    console.error('Error checking user approval:', error)\n    return { approved: false, userData: null, exists: false }\n  }\n}\n\n// In the modal submission handler for 'connect-twitter', replace the existing logic with:\nif (interaction.customId === 'connect-twitter') {\n  const handle = interaction.fields.getTextInputValue('twitter-handle')\n  const cleanHandle = handle.toLowerCase().replace('@', '').trim()\n  \n  // Check if user exists\n  const { approved, userData, exists } = await isUserApproved(cleanHandle)\n  \n  // If user doesn't exist, create a new profile (pending approval)\n  if (!exists) {\n    try {\n      const newUser = await createUserProfile(cleanHandle, interaction.user.id)\n      console.log(`✅ Created new profile (pending) for @${cleanHandle}`)\n      \n      await interaction.reply({ \n        content: `📝 Your Twitter account @${cleanHandle} has been registered!\\n\\n` +\n                 `⏳ **Your account is pending approval.** An admin will review and approve your account soon.\\n` +\n                 `📢 You'll be notified once approved and can then use the engagement features.`, \n        flags: 64 \n      })\n      return\n    } catch (error) {\n      console.error('Error creating new user profile:', error)\n      await interaction.reply({ \n        content: '❌ An error occurred while creating your profile. Please try again or contact an admin.', \n        flags: 64 \n      })\n      return\n    }\n  }\n  \n  // If user exists but is not approved\n  if (!approved) {\n    await interaction.reply({ \n      content: '❌ Your Twitter account is pending approval. Please wait for an admin to approve your account.', \n      flags: 64 \n    })\n    return\n  }\n  \n  // Rest of the existing logic for approved users...\n} "
  },
  {
    "file": "discord-bots/engagement-bot-broken.js",
    "original": "const { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle, REST, Routes } = require('discord.js')\nconst { config } = require('dotenv')\nconst { Redis } = require('@upstash/redis')\nconst { GoogleGenerativeAI } = require('@google/generative-ai')\nconst path = require('path')\nconst { nanoid } = require('nanoid')\n\n// Load environment variables from parent directory\nconst envPath = path.join(__dirname, '..', '.env.local')\nconsole.log('🔍 Loading environment from:', envPath)\nconfig({ path: envPath })\n\n// Check required environment variables\nconst requiredVars = ['UPSTASH_REDIS_REST_URL', 'UPSTASH_REDIS_REST_TOKEN', 'DISCORD_BOT_TOKEN']\nconst optionalVars = ['GEMINI_API_KEY', 'GOOGLE_AI_API_KEY'] // Try both for compatibility\nconst missingVars = requiredVars.filter(v => !process.env[v])\n\n// Check for Gemini/Google AI key\nconst hasAiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n\nif (missingVars.length > 0) {\n  console.error('❌ Missing required environment variables:', missingVars.join(', '))\n  console.error('🔍 Please check your .env.local file contains:')\n  missingVars.forEach(v => console.error(`   ${v}=your_value_here`))\n  process.exit(1)\n}\n\nif (!hasAiKey) {\n  console.warn('⚠️  No AI API key found (GEMINI_API_KEY or GOOGLE_AI_API_KEY)')\n  console.warn('   Sentiment analysis will be disabled')\n}\n\n// Initialize Redis\nconst redis = new Redis({\n  url: process.env.UPSTASH_REDIS_REST_URL,\n  token: process.env.UPSTASH_REDIS_REST_TOKEN\n})\n\n// Initialize Gemini for sentiment analysis (if available)\nlet genAI = null\nlet model = null\n\nif (hasAiKey) {\n  const apiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n  genAI = new GoogleGenerativeAI(apiKey)\n  model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' })\n  console.log('✅ AI model initialized for sentiment analysis')\n}\n\n// Initialize Discord client\nconst client = new Client({\n  intents: [\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildMessages,\n    GatewayIntentBits.MessageContent,\n    GatewayIntentBits.GuildMessageReactions,\n    GatewayIntentBits.GuildMembers\n  ]\n})\n\n// Tweet URL regex\nconst TWEET_REGEX = /https?:\\/\\/(twitter\\.com|x\\.com)\\/[\\w]+\\/status\\/(\\d+)/i\n\n// Bot configuration\nconst BOT_CHANNEL_NAME = 'engagement-tracker'\nconst ADMIN_ROLE_NAME = 'admin'\nconst KOL_ROLE_NAME = 'kol'\n\n// Role hierarchy (higher number = higher priority)\nconst ROLE_HIERARCHY = {\n  'admin': 4,\n  'core': 3,\n  'team': 2,\n  'kol': 1,\n  'user': 0\n}\n\n// Helper function to extract tweet ID from URL\nfunction extractTweetId(url) {\n  const match = url.match(TWEET_REGEX)\n  return match ? match[2] : null\n}\n\n// Helper function to extract Twitter handle from URL\nfunction extractTwitterHandle(url) {\n  const match = url.match(/https?:\\/\\/(twitter\\.com|x\\.com)\\/([\\w]+)\\/status/)\n  return match ? match[2] : null\n}\n\n// Create a new user profile (pending approval)\nasync function createUserProfile(twitterHandle, discordId) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userId = `user:${nanoid()}`\n    \n    const newUser = {\n      id: userId,\n      twitterHandle: `@${normalizedHandle}`,\n      name: normalizedHandle, // Use handle as name initially\n      approvalStatus: 'pending', // Set to pending, requiring admin approval\n      role: 'user', // Default to user role\n      tier: 'micro', // Default tier\n      discordId: discordId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      socialAccounts: {\n        twitter: {\n          handle: normalizedHandle,\n          connected: true\n        }\n      }\n    }\n    \n    // Save to Redis\n    await redis.json.set(userId, '$', newUser)\n    \n    // Create username index\n    await redis.sadd(`idx:username:${normalizedHandle}`, userId)\n    \n    // Add to pending users set (not approved)\n    await redis.sadd('users:pending', userId)\n    \n    console.log(`✅ Created new user profile (pending) for @${normalizedHandle}`)\n    return newUser\n  } catch (error) {\n    console.error('Error creating user profile:', error)\n    throw error\n  }\n}\n\n\n// Check if user is approved in the database\nasync function isUserApproved(twitterHandle) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    \n    // Check if user exists via username index\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    if (!userIds || userIds.length === 0) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Get user data\n    const userData = await redis.json.get(`user:${userIds[0]}`)\n    if (!userData) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Check approval status\n    const isApproved = userData.approvalStatus === 'approved'\n    return { approved: isApproved, userData, exists: true }\n  } catch (error) {\n    console.error('Error checking user approval:', error)\n    return { approved: false, userData: null, exists: false }\n  }\n}\n\n// Get user's current role from database\nasync function getUserRole(twitterHandle) {\n  try {\n    const { approved, userData } = await isUserApproved(twitterHandle)\n    if (!approved || !userData) return 'user'\n    \n    return userData.role || 'user'\n  } catch (error) {\n    console.error('Error getting user role:', error)\n    return 'user'\n  }\n}\n\n// Update user's role in database\nasync function updateUserRole(twitterHandle, newRole) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    \n    if (userIds && userIds.length > 0) {\n      await redis.json.set(`user:${userIds[0]}`, '$.role', newRole)\n      return true\n    }\n    return false\n  } catch (error) {\n    console.error('Error updating user role:', error)\n    return false\n  }\n}\n\n// Get tier-based scenarios\nasync function getTierScenarios(tier) {\n  try {\n    const safeTier = tier || 'micro' // Default to micro if tier is null/undefined\n    const scenarios = await redis.json.get(`engagement:scenarios:${safeTier}`)\n    return scenarios || getDefaultScenarios(safeTier)\n  } catch (error) {\n    console.error('Error getting tier scenarios:', error)\n    return getDefaultScenarios(tier || 'micro')\n  }\n}\n\n// Default scenarios by tier\nfunction getDefaultScenarios(tier) {\n  const scenarios = {\n    'micro': {\n      dailyTweetLimit: 5,\n      categories: ['General', 'DeFi', 'NFT'],\n      minFollowers: 100,\n      bonusMultiplier: 1.0\n    },\n    'rising': {\n      dailyTweetLimit: 10,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech'],\n      minFollowers: 500,\n      bonusMultiplier: 1.5\n    },\n    'star': {\n      dailyTweetLimit: 20,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News'],\n      minFollowers: 1000,\n      bonusMultiplier: 2.0\n    },\n    'legend': {\n      dailyTweetLimit: 30,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special'],\n      minFollowers: 5000,\n      bonusMultiplier: 2.5\n    },\n    'hero': {\n      dailyTweetLimit: 50,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special', 'VIP'],\n      minFollowers: 10000,\n      bonusMultiplier: 3.0\n    }\n  }\n  \n  return scenarios[tier] || scenarios['micro']\n}\n\n// Create minimal tweet embed with preview\nfunction createTweetEmbed(tweet, submitterName, includeButtons = true) {\n  // Choose color based on tier\n  const tierColors = {\n    'micro': 0x6B7280,  // Gray\n    'rising': 0x3BA55D, // Green\n    'star': 0x5865F2,   // Blue\n    'legend': 0xEA580C, // Orange\n    'hero': 0x9333EA    // Purple\n  }\n  \n  // Calculate potential points\n  const likePoints = Math.floor(10 * tweet.bonusMultiplier)\n  const retweetPoints = Math.floor(20 * tweet.bonusMultiplier)\n  const replyPoints = Math.floor(30 * tweet.bonusMultiplier)\n  \n  const embed = new EmbedBuilder()\n    .setColor(tierColors[tweet.tier] || 0x1DA1F2)\n    .setAuthor({ \n      name: `@${tweet.authorHandle}`, \n      url: `https://twitter.com/${tweet.authorHandle}`,\n      iconURL: 'https://abs.twimg.com/icons/apple-touch-icon-192x192.png'\n    })\n    .setDescription(\n      `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n      `**💰 Earn ${tweet.bonusMultiplier}x points:**\\n` +\n      `❤️ Like: ${likePoints} pts | 🔁 RT: ${retweetPoints} pts | 💬 Reply: ${replyPoints} pts`\n    )\n    .addFields(\n      { name: 'Tier', value: `⭐ ${tweet.tier}`, inline: true },\n      { name: 'Category', value: `${tweet.category}`, inline: true },\n      { name: 'Submitted', value: `<t:${Math.floor(new Date(tweet.submittedAt).getTime() / 1000)}:R>`, inline: true }\n    )\n    .setFooter({ text: `Submitted by ${submitterName}` })\n  \n  if (includeButtons) {\n    // Create clickable button for the tweet\n    const row = new ActionRowBuilder()\n      .addComponents(\n        new ButtonBuilder()\n          .setLabel('View & Engage')\n          .setStyle(ButtonStyle.Link)\n          .setURL(tweet.url)\n          .setEmoji('🐦')\n      )\n    \n    return { embeds: [embed], components: [row] }\n  }\n  \n  return { embeds: [embed] }\n}\n\n// Handle slash commands\nclient.on('ready', async () => {\n  console.log(`✅ Engagement bot logged in as ${client.user.tag}`)\n  \n  // Start checking for channel info requests\n  setInterval(async () => {\n    try {\n      // Look for any channel info requests\n      const keys = await redis.keys('discord:channel-info-request:*')\n      \n      for (const key of keys) {\n        const request = await redis.get(key)\n        if (!request) continue\n        \n        let channelId, serverId, projectId\n        try {\n          // Upstash Redis returns the parsed object directly\n          const parsed = typeof request === 'string' ? JSON.parse(request) : request\n          channelId = parsed.channelId\n          serverId = parsed.serverId\n          projectId = parsed.projectId\n        } catch (parseError) {\n          console.error(`Error parsing channel info request from ${key}:`, parseError)\n          console.error('Raw request data:', request)\n          await redis.del(key)\n          continue\n        }\n        \n        // Try to fetch the channel\n        try {\n          console.log(`[DEBUG] Looking for guild ${serverId}`)\n          console.log(`[DEBUG] Available guilds: ${client.guilds.cache.map(g => `${g.name} (${g.id})`).join(', ')}`)\n          \n          const guild = client.guilds.cache.get(serverId)\n          if (!guild) {\n            console.log(`Guild ${serverId} not found in cache`)\n            continue\n          }\n          \n          const channel = guild.channels.cache.get(channelId)\n          if (channel) {\n            // Store the response\n            const responseKey = `discord:channel-info-response:${channelId}`\n            await redis.set(responseKey, JSON.stringify({\n              id: channelId,\n              name: channel.name,\n              type: channel.type === 0 ? 'text' : 'voice'\n            }), {\n              ex: 60 // expire in 60 seconds\n            })\n            \n            // Also store permanent channel metadata\n            const channelMetadataKey = `channel:discord:${channelId}`\n            await redis.json.set(channelMetadataKey, '$', {\n              id: channelId,\n              name: channel.name,\n              type: channel.type === 0 ? 'text' : 'voice',\n              projectId: projectId || null,\n              updatedAt: new Date().toISOString()\n            })\n            \n            console.log(`✅ Fetched channel info: #${channel.name} (${channelId})`)\n          } else {\n            console.log(`Channel ${channelId} not found in guild ${serverId}`)\n          }\n        } catch (error) {\n          console.error(`Error fetching channel ${channelId}:`, error)\n        }\n        \n        // Delete the request\n        await redis.del(key)\n      }\n    } catch (error) {\n      console.error('Error processing channel info requests:', error)\n    }\n  }, 2000) // Check every 2 seconds\n  \n  // Register slash commands\n  const commands = [\n    {\n      name: 'ping',\n      description: 'Test if bot is responding'\n    },\n    {\n      name: 'connect',\n      description: 'Connect your Twitter account (must be approved)'\n    },\n    {\n      name: 'submit',\n      description: 'Submit a tweet for engagement tracking',\n      options: [{\n        name: 'url',\n        type: 3, // STRING\n        description: 'The tweet URL',\n        required: true\n      }, {\n        name: 'category',\n        type: 3,\n        description: 'Tweet category (optional)',\n        required: false\n      }]\n    },\n    {\n      name: 'stats',\n      description: 'View your engagement stats'\n    },\n    {\n      name: 'leaderboard',\n      description: 'View the engagement leaderboard'\n    },\n    {\n      name: 'recent',\n      description: 'View recently submitted tweets'\n    },\n    {\n      name: 'tier',\n      description: 'Admin: Set user tier',\n      options: [{\n        name: 'user',\n        type: 6, // USER\n        description: 'The user to update',\n        required: true\n      }, {\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }]\n    },\n    {\n      name: 'scenarios',\n      description: 'Admin: Configure tier scenarios',\n      options: [{\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }, {\n        name: 'daily_limit',\n        type: 4,\n        description: 'Daily tweet limit',\n        required: false\n      }, {\n        name: 'min_followers',\n        type: 4,\n        description: 'Minimum followers required',\n        required: false\n      }, {\n        name: 'bonus_multiplier',\n        type: 10, // DOUBLE\n        description: 'Points bonus multiplier',\n        required: false\n      }]\n    }\n  ]\n  \n  // Import REST and Routes for proper command registration\n  const { REST } = require('@discordjs/rest')\n  const { Routes } = require('discord-api-types/v9')\n  \n  const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_ENGAGEMENT_BOT_TOKEN || process.env.DISCORD_BOT_TOKEN)\n  \n  try {\n    console.log('🔄 Refreshing application (/) commands...')\n    \n    // Clear existing commands first to remove duplicates\n    await rest.put(\n      Routes.applicationCommands(client.user.id),\n      { body: [] }\n    )\n    \n    // Register commands to each guild for instant update\n    for (const guild of client.guilds.cache.values()) {\n      try {\n        await rest.put(\n          Routes.applicationGuildCommands(client.user.id, guild.id),\n          { body: commands }\n        )\n        console.log(`✅ Registered commands to guild: ${guild.name}`)\n      } catch (error) {\n        console.error(`❌ Failed to register to ${guild.name}:`, error.message)\n      }\n    }\n    \n    console.log('✅ Slash commands registered')\n  } catch (error) {\n    console.error('Error registering commands:', error)\n  }\n})\n\n// Handle interactions\nclient.on('interactionCreate', async (interaction) => {\n  console.log(`📥 Received interaction: ${interaction.type} - Command: ${interaction.commandName || 'N/A'} - User: ${interaction.user?.tag || 'Unknown'}`)\n  \n  try {\n    // Handle slash commands\n    if (interaction.isCommand()) {\n      const { commandName } = interaction\n      console.log(`🎯 Processing command: ${commandName}`)\n    \n    \n    if (commandName === 'connect') {\n      await interaction.deferReply({ flags: 64 })\n      \n      try {\n        // Generate a unique verification session\n        const sessionId = `verify-${interaction.user.id}-${Date.now()}`\n        const sessionKey = `discord:verify:${sessionId}`\n        \n        // Store session data\n        await redis.set(sessionKey, JSON.stringify({\n          discordId: interaction.user.id,\n          discordUsername: interaction.user.username,\n          discordTag: interaction.user.tag,\n          timestamp: Date.now()\n        }), { EX: 600 }) // Expires in 10 minutes\n        \n        // Create verification URL that will use the website's Twitter OAuth\n        const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3002'\n        const verificationUrl = `${baseUrl}/auth/discord-link?session=${sessionId}`\n        \n        const embed = new EmbedBuilder()\n          .setColor(0x1DA1F2) // Twitter blue\n          .setTitle('🔐 Secure Twitter Connection')\n          .setDescription(\n            'To securely connect your Twitter account, you need to verify ownership through Twitter OAuth.\\n\\n' +\n            '**Click the button below to:**\\n' +\n            '1. Sign in with Twitter (OAuth)\\n' +\n            '2. Authorize the connection\\n' +\n            '3. Your accounts will be linked automatically'\n          )\n          .addFields(\n            { name: '⏱️ Expires In', value: '10 minutes', inline: true },\n            { name: '🔒 Security', value: 'OAuth 2.0', inline: true }\n          )\n          .setFooter({ text: 'Only you can complete this verification' })\n        \n        const row = new ActionRowBuilder()\n          .addComponents(\n            new ButtonBuilder()\n              .setLabel('Verify Twitter Account')\n              .setStyle(ButtonStyle.Link)\n              .setURL(verificationUrl)\n              .setEmoji('🐦')\n          )\n        \n        await interaction.editReply({\n          embeds: [embed],\n          components: [row],\n          flags: 64\n        })\n      } catch (error) {\n        console.error('Error in connect command:', error)\n        await interaction.editReply('❌ An error occurred. Please try again.')\n      }\n    }\n    \n    else if (commandName === 'submit') {\n      await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n      \n      const url = interaction.options.getString('url')\n      const category = interaction.options.getString('category')\n      \n      // Validate URL\n      const tweetId = extractTweetId(url)\n      if (!tweetId) {\n        await interaction.editReply('❌ Invalid tweet URL. Please provide a valid Twitter/X URL.')\n        return\n      }\n      \n      // Check if user is connected\n      const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n      if (!connection) {\n        await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n        return\n      }\n      \n      // Check if user is still approved\n      const { approved } = await isUserApproved(connection.twitterHandle)\n      if (!approved) {\n        await interaction.editReply('❌ Your Twitter account is no longer approved. Please contact an admin.')\n        return\n      }\n      \n      // Check tier scenarios\n      const scenarios = await getTierScenarios(connection.tier)\n      \n      // Check daily limit\n      const today = new Date().toISOString().split('T')[0]\n      const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n      \n      if (dailySubmissions >= scenarios.dailyTweetLimit) {\n        await interaction.editReply(`❌ You've reached your daily limit of ${scenarios.dailyTweetLimit} tweets for Tier ${connection.tier}.`)\n        return\n      }\n      \n      // Check for duplicate\n      const isDuplicate = await redis.exists(`engagement:tweetid:${tweetId}`)\n      if (isDuplicate) {\n        await interaction.editReply('❌ This tweet has already been submitted.')\n        return\n      }\n      \n      // Extract author handle\n      const authorHandle = extractTwitterHandle(url)\n      \n      // Check if submitter is author or admin\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin && connection.twitterHandle !== authorHandle) {\n        await interaction.editReply('❌ You can only submit your own tweets. Admins can submit any tweet.')\n        return\n      }\n      \n      // Validate category\n      let finalCategory = category\n      if (category && !scenarios.categories.includes(category)) {\n        await interaction.editReply(`❌ Invalid category. Available categories for Tier ${connection.tier}: ${scenarios.categories.join(', ')}`)\n        return\n      }\n      \n      if (!finalCategory) {\n        finalCategory = 'General'\n      }\n      \n      // Submit tweet\n      try {\n        const { nanoid } = await import('nanoid')\n        // Try to fetch tweet content from Twitter API\n        let tweetContent = null\n        try {\n          const response = await fetch(`https://api.twitter.com/2/tweets/${tweetId}?tweet.fields=text`, {\n            headers: {\n              'Authorization': `Bearer ${process.env.TWITTER_BEARER_TOKEN}`\n            }\n          })\n          \n          if (response.ok) {\n            const tweetData = await response.json()\n            tweetContent = tweetData.data?.text || null\n            console.log('📝 Fetched tweet content:', tweetContent ? 'Success' : 'No content')\n          }\n        } catch (error) {\n          console.log('⚠️ Could not fetch tweet content:', error.message)\n        }\n\n        const tweet = {\n          id: nanoid(),\n          tweetId,\n          submitterDiscordId: interaction.user.id,\n          submittedAt: new Date(),\n          category: finalCategory,\n          url,\n          authorHandle,\n          content: tweetContent,\n          tier: connection.tier,\n          bonusMultiplier: scenarios.bonusMultiplier\n        }\n        \n        await redis.json.set(`engagement:tweet:${tweet.id}`, '$', tweet)\n        // Store in sorted set for admin panel compatibility\n        await redis.zadd('engagement:tweets:recent', { score: Date.now(), member: tweet.id })\n        await redis.set(`engagement:tweetid:${tweet.tweetId}`, tweet.id)\n        \n        // Increment daily counter\n        await redis.incr(`engagement:daily:${interaction.user.id}:${today}`)\n        await redis.expire(`engagement:daily:${interaction.user.id}:${today}`, 86400) // 24 hours\n        \n        // Send to channel\n        const channel = interaction.guild.channels.cache.find(ch => ch.name === BOT_CHANNEL_NAME)\n        if (channel) {\n          // Debug: Check bot permissions in channel\n          const botMember = interaction.guild.members.cache.get(client.user.id)\n          const perms = channel.permissionsFor(botMember)\n          console.log(`Bot permissions in #${BOT_CHANNEL_NAME}:`, {\n            viewChannel: perms.has('ViewChannel'),\n            sendMessages: perms.has('SendMessages'),\n            embedLinks: perms.has('EmbedLinks'),\n            readMessageHistory: perms.has('ReadMessageHistory'),\n            useExternalEmojis: perms.has('UseExternalEmojis')\n          })\n          try {\n            const messageContent = createTweetEmbed(tweet, interaction.user.username)\n            await channel.send(messageContent)\n            console.log(`✅ Posted tweet preview to #${BOT_CHANNEL_NAME}`)\n          } catch (channelError) {\n            console.error('Error posting to channel:', channelError)\n            console.log('Make sure the bot has permission to send messages in #engagement-tracker')\n            console.log('Required permissions: View Channel, Send Messages, Embed Links')\n            \n            // Try sending without buttons as fallback\n            try {\n              console.log('Attempting to send without buttons...')\n              const simpleEmbed = createTweetEmbed(tweet, interaction.user.username, false)\n              await channel.send(simpleEmbed)\n              console.log('✅ Sent simplified preview without buttons')\n            } catch (fallbackError) {\n              console.error('Even simple embed failed:', fallbackError)\n              console.log('Bot may lack basic permissions in the channel')\n              \n              // Last resort - send plain text\n              try {\n                const plainMessage = `**@${tweet.authorHandle}**\\n` +\n                  `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n                  `💰 Earn ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | ${tweet.category}\\n` +\n                  `🔗 ${tweet.url}`\n                await channel.send(plainMessage)\n                console.log('✅ Sent plain text preview')\n              } catch (textError) {\n                console.error('Cannot send any message to channel:', textError)\n              }\n            }\n          }\n        } else {\n          console.log(`Channel \"${BOT_CHANNEL_NAME}\" not found. Please create it for tweet announcements.`)\n        }\n        \n        await interaction.editReply(`✅ Tweet submitted successfully! (${parseInt(dailySubmissions) + 1}/${scenarios.dailyTweetLimit} today)`)\n      } catch (error) {\n        console.error('Error submitting tweet:', error)\n        await interaction.editReply('❌ An error occurred while submitting the tweet. Please try again.')\n      }\n    }\n    \n    else if (commandName === 'stats') {\n      await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n      \n      const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n      if (!connection) {\n        await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n        return\n      }\n      \n      // Get tier scenarios\n      const scenarios = await getTierScenarios(connection.tier)\n      \n      // Get today's submissions\n      const today = new Date().toISOString().split('T')[0]\n      const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n      \n      // Get recent engagements (skip for now since we don't have logs yet)\n      const logs = []\n      \n      const embed = new EmbedBuilder()\n        .setColor(0x00FF00)\n        .setTitle('📊 Your Engagement Stats')\n        .setDescription(`**Twitter:** @${connection.twitterHandle}\\n**Tier:** ${connection.tier ? connection.tier.toUpperCase() : 'MICRO'}\\n**Total Points:** ${connection.totalPoints || 0}`)\n        .addFields(\n          { name: 'Daily Limit', value: `${dailySubmissions}/${scenarios.dailyTweetLimit}`, inline: true },\n          { name: 'Bonus Multiplier', value: `${scenarios.bonusMultiplier}x`, inline: true },\n          { name: 'Categories', value: scenarios.categories.join(', '), inline: false }\n        )\n        .setTimestamp()\n      \n      if (logs.length > 0) {\n        const recentActivity = logs.map(log => \n          `${log.interactionType === 'like' ? '❤️' : log.interactionType === 'retweet' ? '🔁' : '💬'} +${log.points} points`\n        ).join('\\n')\n        embed.addFields({ name: 'Recent Activity', value: recentActivity })\n      }\n      \n      await interaction.editReply({ embeds: [embed] })\n    }\n    \n    else if (commandName === 'leaderboard') {\n      await interaction.deferReply()\n      \n      // Get leaderboard data\n      const keys = await redis.keys('engagement:connection:*')\n      const entries = []\n      \n      for (const key of keys.slice(0, 50)) {\n        const connection = await redis.json.get(key)\n        if (connection) {\n          entries.push({\n            discordId: connection.discordId,\n            twitterHandle: connection.twitterHandle,\n            totalPoints: connection.totalPoints || 0,\n            tier: connection.tier\n          })\n        }\n      }\n      \n      // Sort by points\n      entries.sort((a, b) => b.totalPoints - a.totalPoints)\n      \n      const embed = new EmbedBuilder()\n        .setColor(0xFFD700) // Gold\n        .setTitle('🏆 Engagement Leaderboard')\n        .setDescription('Top 10 Engagers')\n        .setTimestamp()\n      \n      const top10 = entries.slice(0, 10).map((entry, index) => {\n        const tierEmoji = {\n          'micro': '⚪',\n          'rising': '🟢',\n          'star': '⭐',\n          'legend': '🟠',\n          'hero': '👑'\n        }[entry.tier] || '⚪'\n        return `**${index + 1}.** @${entry.twitterHandle} ${tierEmoji} ${entry.tier ? entry.tier.toUpperCase() : 'MICRO'} - ${entry.totalPoints} points`\n      }).join('\\n')\n      \n      embed.addFields({ name: 'Rankings', value: top10 || 'No data yet' })\n      \n      await interaction.editReply({ embeds: [embed] })\n    }\n    \n    else if (commandName === 'recent') {\n      await interaction.deferReply()\n      \n      try {\n        // Get recent tweets from sorted set\n        const tweetIds = await redis.zrange('engagement:tweets:recent', 0, 9, { rev: true }) // Get last 10\n        const tweets = []\n        \n        for (const id of tweetIds) {\n          const tweet = await redis.json.get(`engagement:tweet:${id}`)\n          if (tweet) tweets.push(tweet)\n        }\n        \n        const embed = new EmbedBuilder()\n          .setColor(0x1DA1F2) // Twitter blue\n          .setTitle('🐦 Recent Tweets for Engagement')\n          .setDescription('Click on any tweet to engage and earn points!')\n          .setTimestamp()\n        \n        if (tweets.length === 0) {\n          embed.addFields({ name: 'No tweets yet', value: 'Be the first to submit a tweet with `/submit`!' })\n        } else {\n          let tweetList = ''\n          tweets.forEach((tweet, index) => {\n            tweetList += `**${index + 1}. @${tweet.authorHandle}**\\n`\n            if (tweet.content) {\n              tweetList += `\"${tweet.content.substring(0, 100)}${tweet.content.length > 100 ? '...' : ''}\"\\n`\n            }\n            tweetList += `💰 ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | [View Tweet](${tweet.url})\\n\\n`\n          })\n          embed.addFields({ name: 'Recent Tweets', value: tweetList || 'No tweets yet' })\n        }\n        \n        await interaction.editReply({ embeds: [embed] })\n      } catch (error) {\n        console.error('Error in /recent command:', error)\n        await interaction.editReply('❌ An error occurred while fetching recent tweets.')\n      }\n    }\n    \n    else if (commandName === 'tier') {\n      // Admin only\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin) {\n        await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n        return\n      }\n      \n      const user = interaction.options.getUser('user')\n      const tier = interaction.options.getString('tier')\n      \n      const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n      if (!validTiers.includes(tier)) {\n        await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n        return\n      }\n      \n      const connection = await redis.json.get(`engagement:connection:${user.id}`)\n      if (!connection) {\n        await interaction.reply({ content: '❌ User has not connected their Twitter account.', flags: 64 })\n        return\n      }\n      \n      await redis.json.set(`engagement:connection:${user.id}`, '$.tier', tier)\n      await interaction.reply({ content: `✅ Updated ${user.username}'s tier to ${tier.toUpperCase()}`, flags: 64 })\n    }\n    \n    else if (commandName === 'scenarios') {\n      // Admin only\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin) {\n        await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n        return\n      }\n      \n      const tier = interaction.options.getString('tier')\n      const dailyLimit = interaction.options.getInteger('daily_limit')\n      const minFollowers = interaction.options.getInteger('min_followers')\n      const bonusMultiplier = interaction.options.getNumber('bonus_multiplier')\n      \n      const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n      if (!validTiers.includes(tier)) {\n        await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n        return\n      }\n      \n      // Get current scenarios\n      const currentScenarios = await getTierScenarios(tier)\n      \n      // Update with new values\n      if (dailyLimit !== null) currentScenarios.dailyTweetLimit = dailyLimit\n      if (minFollowers !== null) currentScenarios.minFollowers = minFollowers\n      if (bonusMultiplier !== null) currentScenarios.bonusMultiplier = bonusMultiplier\n      \n      // Save scenarios\n      await redis.json.set(`engagement:scenarios:${tier}`, '$', currentScenarios)\n      \n      await interaction.reply({ \n        content: `✅ Updated ${tier.toUpperCase()} tier scenarios:\\n` +\n                 `Daily Limit: ${currentScenarios.dailyTweetLimit}\\n` +\n                 `Min Followers: ${currentScenarios.minFollowers}\\n` +\n                 `Bonus Multiplier: ${currentScenarios.bonusMultiplier}x`,\n        flags: 64 \n      })\n    }\n  }\n  \n  // Handle modal submissions\n  else if (interaction.isModalSubmit()) {\n    if (interaction.customId === 'connect-twitter') {\n      const handle = interaction.fields.getTextInputValue('twitter-handle')\n      const cleanHandle = handle.toLowerCase().replace('@', '').trim()\n      \n      // Check if user is approved\n      const { approved, userData, exists } = await isUserApproved(cleanHandle)\n      \n      // If user doesn't exist, create a new profile (pending approval)\n      if (!exists) {\n        try {\n          const newUser = await createUserProfile(cleanHandle, interaction.user.id)\n          console.log(`✅ Created new profile (pending) for @${cleanHandle}`)\n          \n          await interaction.reply({ \n            content: `📝 Your Twitter account @${cleanHandle} has been registered!\\n\\n` +\n                     `⏳ **Your account is pending approval.** An admin will review and approve your account soon.\\n` +\n                     `📢 You'll be notified once approved and can then use the engagement features.`, \n            flags: 64 \n          })\n          return\n        } catch (error) {\n          console.error('Error creating new user profile:', error)\n          await interaction.reply({ \n            content: '❌ An error occurred while creating your profile. Please try again or contact an admin.', \n            flags: 64 \n          })\n          return\n        }\n      }\n      \n      // If user exists but is not approved\n      if (!approved) {\n        await interaction.reply({ \n          content: '❌ Your Twitter account is pending approval. Please wait for an admin to approve your account.', \n          flags: 64 \n        })\n        return\n      }\n      \n      // Check if handle is already connected\n      const existingDiscordId = await redis.get(`engagement:twitter:${cleanHandle}`)\n      if (existingDiscordId && existingDiscordId !== interaction.user.id) {\n        await interaction.reply({ \n          content: '❌ This Twitter account is already connected to another Discord user.', \n          flags: 64 \n        })\n        return\n      }\n      \n      // Get current role from database\n      const currentRole = userData.role || 'user'\n      \n      // Assign KOL role if user doesn't have a higher role\n      let finalRole = currentRole\n      if (ROLE_HIERARCHY[currentRole] < ROLE_HIERARCHY['kol']) {\n        finalRole = 'kol'\n        await updateUserRole(cleanHandle, 'kol')\n        \n        // Also assign Discord role if available\n        try {\n          const member = await interaction.guild.members.fetch(interaction.user.id)\n          const kolRole = interaction.guild.roles.cache.find(role => role.name.toLowerCase() === KOL_ROLE_NAME)\n          \n          if (kolRole) {\n            // Check if bot has permission to manage roles\n            const botMember = interaction.guild.members.cache.get(client.user.id)\n            if (!botMember.permissions.has('ManageRoles')) {\n              console.warn('⚠️  Bot lacks \"Manage Roles\" permission - cannot assign KOL role')\n              console.log('   Please grant the bot \"Manage Roles\" permission in Discord')\n            } \n            // Check if bot's highest role is above the KOL role\n            else if (botMember.roles.highest.position <= kolRole.position) {\n              console.warn('⚠️  Bot\\'s role is not high enough to assign the KOL role')\n              console.log('   Please move the bot\\'s role above the KOL role in Discord settings')\n            }\n            // Try to assign the role\n            else if (!member.roles.cache.has(kolRole.id)) {\n              await member.roles.add(kolRole)\n              console.log(`✅ Assigned KOL role to ${member.user.tag}`)\n            }\n          } else {\n            console.warn(`⚠️  No role found with name \"${KOL_ROLE_NAME}\" (case-insensitive)`)\n            console.log('   Please create a role named \"kol\" in your Discord server')\n          }\n        } catch (error) {\n          console.error('❌ Error assigning Discord role:', error.message)\n          if (error.code === 50013) {\n            console.log('   This is a permissions issue. Please check:')\n            console.log('   1. Bot has \"Manage Roles\" permission')\n            console.log('   2. Bot\\'s role is above the KOL role in the hierarchy')\n          }\n        }\n      }\n      \n      // Create connection - get tier from user profile\n      const userTier = userData.tier || 'micro'  // Default to micro if no tier\n      const connection = {\n        discordId: interaction.user.id,\n        twitterHandle: cleanHandle,\n        tier: userTier,\n        connectedAt: new Date(),\n        totalPoints: 0,\n        role: finalRole\n      }\n      \n      await redis.json.set(`engagement:connection:${interaction.user.id}`, '$', connection)\n      await redis.set(`engagement:twitter:${cleanHandle}`, interaction.user.id)\n      \n      let message = `✅ Successfully connected Twitter account @${cleanHandle}!`\n      if (finalRole === 'kol' && currentRole !== 'kol') {\n        message += '\\n🎉 You\\'ve been assigned the KOL role!'\n      }\n      \n      await interaction.reply({ \n        content: message, \n        flags: 64 \n      })\n    }\n  }\n})\n\n// Error handling\nclient.on('error', console.error)\n\n// Handle regular messages (for ping/pong)\nclient.on('messageCreate', async (message) => {\n  // Ignore messages from bots\n  if (message.author.bot) return\n  \n  // Simple ping/pong response\n  if (message.content.toLowerCase() === 'ping' || message.content.toLowerCase() === '!ping') {\n    try {\n      await message.reply('pong! 🏓')\n      console.log(`Replied to ping from ${message.author.tag}`)\n    } catch (error) {\n      console.error('Error replying to ping:', error)\n    }\n  }\n})\n\n// Login\nconst botToken = process.env.DISCORD_ENGAGEMENT_BOT_TOKEN || process.env.DISCORD_BOT_TOKEN\nif (!botToken) {\n  console.error('❌ No bot token found! Please set DISCORD_ENGAGEMENT_BOT_TOKEN in your .env.local file')\n  console.error('   You need to create a separate Discord bot for the engagement bot')\n  process.exit(1)\n}\n\nclient.login(botToken)\n  .then(() => console.log('🚀 Engagement bot starting...'))\n  .catch((error) => {\n    console.error('❌ Failed to login:', error)\n    console.error('   Make sure DISCORD_ENGAGEMENT_BOT_TOKEN is set correctly in .env.local')\n  }) ",
    "fixed": "const { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, ModalBuilder, TextInputBuilder, TextInputStyle, REST, Routes } = require('discord.js')\nconst { config } = require('dotenv')\nconst { Redis } = require('@upstash/redis')\nconst { GoogleGenerativeAI } = require('@google/generative-ai')\nconst path = require('path')\nconst { nanoid } = require('nanoid')\n\n// Load environment variables from parent directory\nconst envPath = path.join(__dirname, '..', '.env.local')\nconsole.log('🔍 Loading environment from:', envPath)\nconfig({ path: envPath })\n\n// Check required environment variables\nconst requiredVars = ['UPSTASH_REDIS_REST_URL', 'UPSTASH_REDIS_REST_TOKEN', 'DISCORD_BOT_TOKEN']\nconst optionalVars = ['GEMINI_API_KEY', 'GOOGLE_AI_API_KEY'] // Try both for compatibility\nconst missingVars = requiredVars.filter(v => !process.env[v])\n\n// Check for Gemini/Google AI key\nconst hasAiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n\nif (missingVars.length > 0) {\n  console.error('❌ Missing required environment variables:', missingVars.join(', '))\n  console.error('🔍 Please check your .env.local file contains:')\n  missingVars.forEach(v => console.error(`   ${v}=your_value_here`))\n  process.exit(1)\n}\n\nif (!hasAiKey) {\n  console.warn('⚠️  No AI API key found (GEMINI_API_KEY or GOOGLE_AI_API_KEY)')\n  console.warn('   Sentiment analysis will be disabled')\n}\n\n// Initialize Redis\nconst redis = new Redis({\n  url: process.env.UPSTASH_REDIS_REST_URL,\n  token: process.env.UPSTASH_REDIS_REST_TOKEN\n})\n\n// Initialize Gemini for sentiment analysis (if available)\nlet genAI = null\nlet model = null\n\nif (hasAiKey) {\n  const apiKey = process.env.GEMINI_API_KEY || process.env.GOOGLE_AI_API_KEY\n  genAI = new GoogleGenerativeAI(apiKey)\n  model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' })\n  console.log('✅ AI model initialized for sentiment analysis')\n}\n\n// Initialize Discord client\nconst client = new Client({\n  intents: [\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildMessages,\n    GatewayIntentBits.MessageContent,\n    GatewayIntentBits.GuildMessageReactions,\n    GatewayIntentBits.GuildMembers\n  ]\n})\n\n// Tweet URL regex\nconst TWEET_REGEX = /https?:\\/\\/(twitter\\.com|x\\.com)\\/[\\w]+\\/status\\/(\\d+)/i\n\n// Bot configuration\nconst BOT_CHANNEL_NAME = 'engagement-tracker'\nconst ADMIN_ROLE_NAME = 'admin'\nconst KOL_ROLE_NAME = 'kol'\n\n// Role hierarchy (higher number = higher priority)\nconst ROLE_HIERARCHY = {\n  'admin': 4,\n  'core': 3,\n  'team': 2,\n  'kol': 1,\n  'user': 0\n}\n\n// Helper function to extract tweet ID from URL\nfunction extractTweetId(url) {\n  const match = url.match(TWEET_REGEX)\n  return match ? match[2] : null\n}\n\n// Helper function to extract Twitter handle from URL\nfunction extractTwitterHandle(url) {\n  const match = url.match(/https?:\\/\\/(twitter\\.com|x\\.com)\\/([\\w]+)\\/status/)\n  return match ? match[2] : null\n}\n\n// Create a new user profile (pending approval)\nasync function createUserProfile(twitterHandle, discordId) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userId = `user_${normalizedHandle}`\n    \n    const newUser = {\n      id: userId,\n      twitterHandle: `@${normalizedHandle}`,\n      name: normalizedHandle, // Use handle as name initially\n      approvalStatus: 'pending', // Set to pending, requiring admin approval\n      role: 'user', // Default to user role\n      tier: 'micro', // Default tier\n      discordId: discordId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      socialAccounts: {\n        twitter: {\n          handle: normalizedHandle,\n          connected: true\n        }\n      }\n    }\n    \n    // Save to Redis\n    await redis.json.set(userId, '$', newUser)\n    \n    // Create username index\n    await redis.sadd(`idx:username:${normalizedHandle}`, userId)\n    \n    // Add to pending users set (not approved)\n    await redis.sadd('users:pending', userId)\n    \n    console.log(`✅ Created new user profile (pending) for @${normalizedHandle}`)\n    return newUser\n  } catch (error) {\n    console.error('Error creating user profile:', error)\n    throw error\n  }\n}\n\n\n// Check if user is approved in the database\nasync function isUserApproved(twitterHandle) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    \n    // Check if user exists via username index\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    if (!userIds || userIds.length === 0) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Get user data\n    const userData = await redis.json.get(`user:${userIds[0]}`)\n    if (!userData) {\n      return { approved: false, userData: null, exists: false }\n    }\n    \n    // Check approval status\n    const isApproved = userData.approvalStatus === 'approved'\n    return { approved: isApproved, userData, exists: true }\n  } catch (error) {\n    console.error('Error checking user approval:', error)\n    return { approved: false, userData: null, exists: false }\n  }\n}\n\n// Get user's current role from database\nasync function getUserRole(twitterHandle) {\n  try {\n    const { approved, userData } = await isUserApproved(twitterHandle)\n    if (!approved || !userData) return 'user'\n    \n    return userData.role || 'user'\n  } catch (error) {\n    console.error('Error getting user role:', error)\n    return 'user'\n  }\n}\n\n// Update user's role in database\nasync function updateUserRole(twitterHandle, newRole) {\n  try {\n    const normalizedHandle = twitterHandle.toLowerCase().replace('@', '')\n    const userIds = await redis.smembers(`idx:username:${normalizedHandle}`)\n    \n    if (userIds && userIds.length > 0) {\n      await redis.json.set(`user:${userIds[0]}`, '$.role', newRole)\n      return true\n    }\n    return false\n  } catch (error) {\n    console.error('Error updating user role:', error)\n    return false\n  }\n}\n\n// Get tier-based scenarios\nasync function getTierScenarios(tier) {\n  try {\n    const safeTier = tier || 'micro' // Default to micro if tier is null/undefined\n    const scenarios = await redis.json.get(`engagement:scenarios:${safeTier}`)\n    return scenarios || getDefaultScenarios(safeTier)\n  } catch (error) {\n    console.error('Error getting tier scenarios:', error)\n    return getDefaultScenarios(tier || 'micro')\n  }\n}\n\n// Default scenarios by tier\nfunction getDefaultScenarios(tier) {\n  const scenarios = {\n    'micro': {\n      dailyTweetLimit: 5,\n      categories: ['General', 'DeFi', 'NFT'],\n      minFollowers: 100,\n      bonusMultiplier: 1.0\n    },\n    'rising': {\n      dailyTweetLimit: 10,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech'],\n      minFollowers: 500,\n      bonusMultiplier: 1.5\n    },\n    'star': {\n      dailyTweetLimit: 20,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News'],\n      minFollowers: 1000,\n      bonusMultiplier: 2.0\n    },\n    'legend': {\n      dailyTweetLimit: 30,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special'],\n      minFollowers: 5000,\n      bonusMultiplier: 2.5\n    },\n    'hero': {\n      dailyTweetLimit: 50,\n      categories: ['General', 'DeFi', 'NFT', 'Gaming', 'Tech', 'Memes', 'News', 'Special', 'VIP'],\n      minFollowers: 10000,\n      bonusMultiplier: 3.0\n    }\n  }\n  \n  return scenarios[tier] || scenarios['micro']\n}\n\n// Create minimal tweet embed with preview\nfunction createTweetEmbed(tweet, submitterName, includeButtons = true) {\n  // Choose color based on tier\n  const tierColors = {\n    'micro': 0x6B7280,  // Gray\n    'rising': 0x3BA55D, // Green\n    'star': 0x5865F2,   // Blue\n    'legend': 0xEA580C, // Orange\n    'hero': 0x9333EA    // Purple\n  }\n  \n  // Calculate potential points\n  const likePoints = Math.floor(10 * tweet.bonusMultiplier)\n  const retweetPoints = Math.floor(20 * tweet.bonusMultiplier)\n  const replyPoints = Math.floor(30 * tweet.bonusMultiplier)\n  \n  const embed = new EmbedBuilder()\n    .setColor(tierColors[tweet.tier] || 0x1DA1F2)\n    .setAuthor({ \n      name: `@${tweet.authorHandle}`, \n      url: `https://twitter.com/${tweet.authorHandle}`,\n      iconURL: 'https://abs.twimg.com/icons/apple-touch-icon-192x192.png'\n    })\n    .setDescription(\n      `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n      `**💰 Earn ${tweet.bonusMultiplier}x points:**\\n` +\n      `❤️ Like: ${likePoints} pts | 🔁 RT: ${retweetPoints} pts | 💬 Reply: ${replyPoints} pts`\n    )\n    .addFields(\n      { name: 'Tier', value: `⭐ ${tweet.tier}`, inline: true },\n      { name: 'Category', value: `${tweet.category}`, inline: true },\n      { name: 'Submitted', value: `<t:${Math.floor(new Date(tweet.submittedAt).getTime() / 1000)}:R>`, inline: true }\n    )\n    .setFooter({ text: `Submitted by ${submitterName}` })\n  \n  if (includeButtons) {\n    // Create clickable button for the tweet\n    const row = new ActionRowBuilder()\n      .addComponents(\n        new ButtonBuilder()\n          .setLabel('View & Engage')\n          .setStyle(ButtonStyle.Link)\n          .setURL(tweet.url)\n          .setEmoji('🐦')\n      )\n    \n    return { embeds: [embed], components: [row] }\n  }\n  \n  return { embeds: [embed] }\n}\n\n// Handle slash commands\nclient.on('ready', async () => {\n  console.log(`✅ Engagement bot logged in as ${client.user.tag}`)\n  \n  // Start checking for channel info requests\n  setInterval(async () => {\n    try {\n      // Look for any channel info requests\n      const keys = await redis.keys('discord:channel-info-request:*')\n      \n      for (const key of keys) {\n        const request = await redis.get(key)\n        if (!request) continue\n        \n        let channelId, serverId, projectId\n        try {\n          // Upstash Redis returns the parsed object directly\n          const parsed = typeof request === 'string' ? JSON.parse(request) : request\n          channelId = parsed.channelId\n          serverId = parsed.serverId\n          projectId = parsed.projectId\n        } catch (parseError) {\n          console.error(`Error parsing channel info request from ${key}:`, parseError)\n          console.error('Raw request data:', request)\n          await redis.del(key)\n          continue\n        }\n        \n        // Try to fetch the channel\n        try {\n          console.log(`[DEBUG] Looking for guild ${serverId}`)\n          console.log(`[DEBUG] Available guilds: ${client.guilds.cache.map(g => `${g.name} (${g.id})`).join(', ')}`)\n          \n          const guild = client.guilds.cache.get(serverId)\n          if (!guild) {\n            console.log(`Guild ${serverId} not found in cache`)\n            continue\n          }\n          \n          const channel = guild.channels.cache.get(channelId)\n          if (channel) {\n            // Store the response\n            const responseKey = `discord:channel-info-response:${channelId}`\n            await redis.set(responseKey, JSON.stringify({\n              id: channelId,\n              name: channel.name,\n              type: channel.type === 0 ? 'text' : 'voice'\n            }), {\n              ex: 60 // expire in 60 seconds\n            })\n            \n            // Also store permanent channel metadata\n            const channelMetadataKey = `channel:discord:${channelId}`\n            await redis.json.set(channelMetadataKey, '$', {\n              id: channelId,\n              name: channel.name,\n              type: channel.type === 0 ? 'text' : 'voice',\n              projectId: projectId || null,\n              updatedAt: new Date().toISOString()\n            })\n            \n            console.log(`✅ Fetched channel info: #${channel.name} (${channelId})`)\n          } else {\n            console.log(`Channel ${channelId} not found in guild ${serverId}`)\n          }\n        } catch (error) {\n          console.error(`Error fetching channel ${channelId}:`, error)\n        }\n        \n        // Delete the request\n        await redis.del(key)\n      }\n    } catch (error) {\n      console.error('Error processing channel info requests:', error)\n    }\n  }, 2000) // Check every 2 seconds\n  \n  // Register slash commands\n  const commands = [\n    {\n      name: 'ping',\n      description: 'Test if bot is responding'\n    },\n    {\n      name: 'connect',\n      description: 'Connect your Twitter account (must be approved)'\n    },\n    {\n      name: 'submit',\n      description: 'Submit a tweet for engagement tracking',\n      options: [{\n        name: 'url',\n        type: 3, // STRING\n        description: 'The tweet URL',\n        required: true\n      }, {\n        name: 'category',\n        type: 3,\n        description: 'Tweet category (optional)',\n        required: false\n      }]\n    },\n    {\n      name: 'stats',\n      description: 'View your engagement stats'\n    },\n    {\n      name: 'leaderboard',\n      description: 'View the engagement leaderboard'\n    },\n    {\n      name: 'recent',\n      description: 'View recently submitted tweets'\n    },\n    {\n      name: 'tier',\n      description: 'Admin: Set user tier',\n      options: [{\n        name: 'user',\n        type: 6, // USER\n        description: 'The user to update',\n        required: true\n      }, {\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }]\n    },\n    {\n      name: 'scenarios',\n      description: 'Admin: Configure tier scenarios',\n      options: [{\n        name: 'tier',\n        type: 3, // STRING\n        description: 'Tier level (micro/rising/star/legend/hero)',\n        required: true,\n        choices: [\n          { name: 'Micro', value: 'micro' },\n          { name: 'Rising', value: 'rising' },\n          { name: 'Star', value: 'star' },\n          { name: 'Legend', value: 'legend' },\n          { name: 'Hero', value: 'hero' }\n        ]\n      }, {\n        name: 'daily_limit',\n        type: 4,\n        description: 'Daily tweet limit',\n        required: false\n      }, {\n        name: 'min_followers',\n        type: 4,\n        description: 'Minimum followers required',\n        required: false\n      }, {\n        name: 'bonus_multiplier',\n        type: 10, // DOUBLE\n        description: 'Points bonus multiplier',\n        required: false\n      }]\n    }\n  ]\n  \n  // Import REST and Routes for proper command registration\n  const { REST } = require('@discordjs/rest')\n  const { Routes } = require('discord-api-types/v9')\n  \n  const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_ENGAGEMENT_BOT_TOKEN || process.env.DISCORD_BOT_TOKEN)\n  \n  try {\n    console.log('🔄 Refreshing application (/) commands...')\n    \n    // Clear existing commands first to remove duplicates\n    await rest.put(\n      Routes.applicationCommands(client.user.id),\n      { body: [] }\n    )\n    \n    // Register commands to each guild for instant update\n    for (const guild of client.guilds.cache.values()) {\n      try {\n        await rest.put(\n          Routes.applicationGuildCommands(client.user.id, guild.id),\n          { body: commands }\n        )\n        console.log(`✅ Registered commands to guild: ${guild.name}`)\n      } catch (error) {\n        console.error(`❌ Failed to register to ${guild.name}:`, error.message)\n      }\n    }\n    \n    console.log('✅ Slash commands registered')\n  } catch (error) {\n    console.error('Error registering commands:', error)\n  }\n})\n\n// Handle interactions\nclient.on('interactionCreate', async (interaction) => {\n  console.log(`📥 Received interaction: ${interaction.type} - Command: ${interaction.commandName || 'N/A'} - User: ${interaction.user?.tag || 'Unknown'}`)\n  \n  try {\n    // Handle slash commands\n    if (interaction.isCommand()) {\n      const { commandName } = interaction\n      console.log(`🎯 Processing command: ${commandName}`)\n    \n    \n    if (commandName === 'connect') {\n      await interaction.deferReply({ flags: 64 })\n      \n      try {\n        // Generate a unique verification session\n        const sessionId = `verify-${interaction.user.id}-${Date.now()}`\n        const sessionKey = `discord:verify:${sessionId}`\n        \n        // Store session data\n        await redis.set(sessionKey, JSON.stringify({\n          discordId: interaction.user.id,\n          discordUsername: interaction.user.username,\n          discordTag: interaction.user.tag,\n          timestamp: Date.now()\n        }), { EX: 600 }) // Expires in 10 minutes\n        \n        // Create verification URL that will use the website's Twitter OAuth\n        const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3002'\n        const verificationUrl = `${baseUrl}/auth/discord-link?session=${sessionId}`\n        \n        const embed = new EmbedBuilder()\n          .setColor(0x1DA1F2) // Twitter blue\n          .setTitle('🔐 Secure Twitter Connection')\n          .setDescription(\n            'To securely connect your Twitter account, you need to verify ownership through Twitter OAuth.\\n\\n' +\n            '**Click the button below to:**\\n' +\n            '1. Sign in with Twitter (OAuth)\\n' +\n            '2. Authorize the connection\\n' +\n            '3. Your accounts will be linked automatically'\n          )\n          .addFields(\n            { name: '⏱️ Expires In', value: '10 minutes', inline: true },\n            { name: '🔒 Security', value: 'OAuth 2.0', inline: true }\n          )\n          .setFooter({ text: 'Only you can complete this verification' })\n        \n        const row = new ActionRowBuilder()\n          .addComponents(\n            new ButtonBuilder()\n              .setLabel('Verify Twitter Account')\n              .setStyle(ButtonStyle.Link)\n              .setURL(verificationUrl)\n              .setEmoji('🐦')\n          )\n        \n        await interaction.editReply({\n          embeds: [embed],\n          components: [row],\n          flags: 64\n        })\n      } catch (error) {\n        console.error('Error in connect command:', error)\n        await interaction.editReply('❌ An error occurred. Please try again.')\n      }\n    }\n    \n    else if (commandName === 'submit') {\n      await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n      \n      const url = interaction.options.getString('url')\n      const category = interaction.options.getString('category')\n      \n      // Validate URL\n      const tweetId = extractTweetId(url)\n      if (!tweetId) {\n        await interaction.editReply('❌ Invalid tweet URL. Please provide a valid Twitter/X URL.')\n        return\n      }\n      \n      // Check if user is connected\n      const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n      if (!connection) {\n        await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n        return\n      }\n      \n      // Check if user is still approved\n      const { approved } = await isUserApproved(connection.twitterHandle)\n      if (!approved) {\n        await interaction.editReply('❌ Your Twitter account is no longer approved. Please contact an admin.')\n        return\n      }\n      \n      // Check tier scenarios\n      const scenarios = await getTierScenarios(connection.tier)\n      \n      // Check daily limit\n      const today = new Date().toISOString().split('T')[0]\n      const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n      \n      if (dailySubmissions >= scenarios.dailyTweetLimit) {\n        await interaction.editReply(`❌ You've reached your daily limit of ${scenarios.dailyTweetLimit} tweets for Tier ${connection.tier}.`)\n        return\n      }\n      \n      // Check for duplicate\n      const isDuplicate = await redis.exists(`engagement:tweetid:${tweetId}`)\n      if (isDuplicate) {\n        await interaction.editReply('❌ This tweet has already been submitted.')\n        return\n      }\n      \n      // Extract author handle\n      const authorHandle = extractTwitterHandle(url)\n      \n      // Check if submitter is author or admin\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin && connection.twitterHandle !== authorHandle) {\n        await interaction.editReply('❌ You can only submit your own tweets. Admins can submit any tweet.')\n        return\n      }\n      \n      // Validate category\n      let finalCategory = category\n      if (category && !scenarios.categories.includes(category)) {\n        await interaction.editReply(`❌ Invalid category. Available categories for Tier ${connection.tier}: ${scenarios.categories.join(', ')}`)\n        return\n      }\n      \n      if (!finalCategory) {\n        finalCategory = 'General'\n      }\n      \n      // Submit tweet\n      try {\n        const { nanoid } = await import('nanoid')\n        // Try to fetch tweet content from Twitter API\n        let tweetContent = null\n        try {\n          const response = await fetch(`https://api.twitter.com/2/tweets/${tweetId}?tweet.fields=text`, {\n            headers: {\n              'Authorization': `Bearer ${process.env.TWITTER_BEARER_TOKEN}`\n            }\n          })\n          \n          if (response.ok) {\n            const tweetData = await response.json()\n            tweetContent = tweetData.data?.text || null\n            console.log('📝 Fetched tweet content:', tweetContent ? 'Success' : 'No content')\n          }\n        } catch (error) {\n          console.log('⚠️ Could not fetch tweet content:', error.message)\n        }\n\n        const tweet = {\n          id: nanoid(),\n          tweetId,\n          submitterDiscordId: interaction.user.id,\n          submittedAt: new Date(),\n          category: finalCategory,\n          url,\n          authorHandle,\n          content: tweetContent,\n          tier: connection.tier,\n          bonusMultiplier: scenarios.bonusMultiplier\n        }\n        \n        await redis.json.set(`engagement:tweet:${tweet.id}`, '$', tweet)\n        // Store in sorted set for admin panel compatibility\n        await redis.zadd('engagement:tweets:recent', { score: Date.now(), member: tweet.id })\n        await redis.set(`engagement:tweetid:${tweet.tweetId}`, tweet.id)\n        \n        // Increment daily counter\n        await redis.incr(`engagement:daily:${interaction.user.id}:${today}`)\n        await redis.expire(`engagement:daily:${interaction.user.id}:${today}`, 86400) // 24 hours\n        \n        // Send to channel\n        const channel = interaction.guild.channels.cache.find(ch => ch.name === BOT_CHANNEL_NAME)\n        if (channel) {\n          // Debug: Check bot permissions in channel\n          const botMember = interaction.guild.members.cache.get(client.user.id)\n          const perms = channel.permissionsFor(botMember)\n          console.log(`Bot permissions in #${BOT_CHANNEL_NAME}:`, {\n            viewChannel: perms.has('ViewChannel'),\n            sendMessages: perms.has('SendMessages'),\n            embedLinks: perms.has('EmbedLinks'),\n            readMessageHistory: perms.has('ReadMessageHistory'),\n            useExternalEmojis: perms.has('UseExternalEmojis')\n          })\n          try {\n            const messageContent = createTweetEmbed(tweet, interaction.user.username)\n            await channel.send(messageContent)\n            console.log(`✅ Posted tweet preview to #${BOT_CHANNEL_NAME}`)\n          } catch (channelError) {\n            console.error('Error posting to channel:', channelError)\n            console.log('Make sure the bot has permission to send messages in #engagement-tracker')\n            console.log('Required permissions: View Channel, Send Messages, Embed Links')\n            \n            // Try sending without buttons as fallback\n            try {\n              console.log('Attempting to send without buttons...')\n              const simpleEmbed = createTweetEmbed(tweet, interaction.user.username, false)\n              await channel.send(simpleEmbed)\n              console.log('✅ Sent simplified preview without buttons')\n            } catch (fallbackError) {\n              console.error('Even simple embed failed:', fallbackError)\n              console.log('Bot may lack basic permissions in the channel')\n              \n              // Last resort - send plain text\n              try {\n                const plainMessage = `**@${tweet.authorHandle}**\\n` +\n                  `${tweet.content ? `\"${tweet.content}\"\\n\\n` : ''}` +\n                  `💰 Earn ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | ${tweet.category}\\n` +\n                  `🔗 ${tweet.url}`\n                await channel.send(plainMessage)\n                console.log('✅ Sent plain text preview')\n              } catch (textError) {\n                console.error('Cannot send any message to channel:', textError)\n              }\n            }\n          }\n        } else {\n          console.log(`Channel \"${BOT_CHANNEL_NAME}\" not found. Please create it for tweet announcements.`)\n        }\n        \n        await interaction.editReply(`✅ Tweet submitted successfully! (${parseInt(dailySubmissions) + 1}/${scenarios.dailyTweetLimit} today)`)\n      } catch (error) {\n        console.error('Error submitting tweet:', error)\n        await interaction.editReply('❌ An error occurred while submitting the tweet. Please try again.')\n      }\n    }\n    \n    else if (commandName === 'stats') {\n      await interaction.deferReply({ flags: 64 }) // 64 is the flag for ephemeral\n      \n      const connection = await redis.json.get(`engagement:connection:${interaction.user.id}`)\n      if (!connection) {\n        await interaction.editReply('❌ Please connect your Twitter account first using `/connect`')\n        return\n      }\n      \n      // Get tier scenarios\n      const scenarios = await getTierScenarios(connection.tier)\n      \n      // Get today's submissions\n      const today = new Date().toISOString().split('T')[0]\n      const dailySubmissions = await redis.get(`engagement:daily:${interaction.user.id}:${today}`) || 0\n      \n      // Get recent engagements (skip for now since we don't have logs yet)\n      const logs = []\n      \n      const embed = new EmbedBuilder()\n        .setColor(0x00FF00)\n        .setTitle('📊 Your Engagement Stats')\n        .setDescription(`**Twitter:** @${connection.twitterHandle}\\n**Tier:** ${connection.tier ? connection.tier.toUpperCase() : 'MICRO'}\\n**Total Points:** ${connection.totalPoints || 0}`)\n        .addFields(\n          { name: 'Daily Limit', value: `${dailySubmissions}/${scenarios.dailyTweetLimit}`, inline: true },\n          { name: 'Bonus Multiplier', value: `${scenarios.bonusMultiplier}x`, inline: true },\n          { name: 'Categories', value: scenarios.categories.join(', '), inline: false }\n        )\n        .setTimestamp()\n      \n      if (logs.length > 0) {\n        const recentActivity = logs.map(log => \n          `${log.interactionType === 'like' ? '❤️' : log.interactionType === 'retweet' ? '🔁' : '💬'} +${log.points} points`\n        ).join('\\n')\n        embed.addFields({ name: 'Recent Activity', value: recentActivity })\n      }\n      \n      await interaction.editReply({ embeds: [embed] })\n    }\n    \n    else if (commandName === 'leaderboard') {\n      await interaction.deferReply()\n      \n      // Get leaderboard data\n      const keys = await redis.keys('engagement:connection:*')\n      const entries = []\n      \n      for (const key of keys.slice(0, 50)) {\n        const connection = await redis.json.get(key)\n        if (connection) {\n          entries.push({\n            discordId: connection.discordId,\n            twitterHandle: connection.twitterHandle,\n            totalPoints: connection.totalPoints || 0,\n            tier: connection.tier\n          })\n        }\n      }\n      \n      // Sort by points\n      entries.sort((a, b) => b.totalPoints - a.totalPoints)\n      \n      const embed = new EmbedBuilder()\n        .setColor(0xFFD700) // Gold\n        .setTitle('🏆 Engagement Leaderboard')\n        .setDescription('Top 10 Engagers')\n        .setTimestamp()\n      \n      const top10 = entries.slice(0, 10).map((entry, index) => {\n        const tierEmoji = {\n          'micro': '⚪',\n          'rising': '🟢',\n          'star': '⭐',\n          'legend': '🟠',\n          'hero': '👑'\n        }[entry.tier] || '⚪'\n        return `**${index + 1}.** @${entry.twitterHandle} ${tierEmoji} ${entry.tier ? entry.tier.toUpperCase() : 'MICRO'} - ${entry.totalPoints} points`\n      }).join('\\n')\n      \n      embed.addFields({ name: 'Rankings', value: top10 || 'No data yet' })\n      \n      await interaction.editReply({ embeds: [embed] })\n    }\n    \n    else if (commandName === 'recent') {\n      await interaction.deferReply()\n      \n      try {\n        // Get recent tweets from sorted set\n        const tweetIds = await redis.zrange('engagement:tweets:recent', 0, 9, { rev: true }) // Get last 10\n        const tweets = []\n        \n        for (const id of tweetIds) {\n          const tweet = await redis.json.get(`engagement:tweet:${id}`)\n          if (tweet) tweets.push(tweet)\n        }\n        \n        const embed = new EmbedBuilder()\n          .setColor(0x1DA1F2) // Twitter blue\n          .setTitle('🐦 Recent Tweets for Engagement')\n          .setDescription('Click on any tweet to engage and earn points!')\n          .setTimestamp()\n        \n        if (tweets.length === 0) {\n          embed.addFields({ name: 'No tweets yet', value: 'Be the first to submit a tweet with `/submit`!' })\n        } else {\n          let tweetList = ''\n          tweets.forEach((tweet, index) => {\n            tweetList += `**${index + 1}. @${tweet.authorHandle}**\\n`\n            if (tweet.content) {\n              tweetList += `\"${tweet.content.substring(0, 100)}${tweet.content.length > 100 ? '...' : ''}\"\\n`\n            }\n            tweetList += `💰 ${tweet.bonusMultiplier}x points | ⭐ Tier ${tweet.tier} | [View Tweet](${tweet.url})\\n\\n`\n          })\n          embed.addFields({ name: 'Recent Tweets', value: tweetList || 'No tweets yet' })\n        }\n        \n        await interaction.editReply({ embeds: [embed] })\n      } catch (error) {\n        console.error('Error in /recent command:', error)\n        await interaction.editReply('❌ An error occurred while fetching recent tweets.')\n      }\n    }\n    \n    else if (commandName === 'tier') {\n      // Admin only\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin) {\n        await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n        return\n      }\n      \n      const user = interaction.options.getUser('user')\n      const tier = interaction.options.getString('tier')\n      \n      const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n      if (!validTiers.includes(tier)) {\n        await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n        return\n      }\n      \n      const connection = await redis.json.get(`engagement:connection:${user.id}`)\n      if (!connection) {\n        await interaction.reply({ content: '❌ User has not connected their Twitter account.', flags: 64 })\n        return\n      }\n      \n      await redis.json.set(`engagement:connection:${user.id}`, '$.tier', tier)\n      await interaction.reply({ content: `✅ Updated ${user.username}'s tier to ${tier.toUpperCase()}`, flags: 64 })\n    }\n    \n    else if (commandName === 'scenarios') {\n      // Admin only\n      const member = interaction.guild.members.cache.get(interaction.user.id)\n      const isAdmin = member.roles.cache.some(role => role.name === ADMIN_ROLE_NAME)\n      \n      if (!isAdmin) {\n        await interaction.reply({ content: '❌ This command is admin only.', flags: 64 })\n        return\n      }\n      \n      const tier = interaction.options.getString('tier')\n      const dailyLimit = interaction.options.getInteger('daily_limit')\n      const minFollowers = interaction.options.getInteger('min_followers')\n      const bonusMultiplier = interaction.options.getNumber('bonus_multiplier')\n      \n      const validTiers = ['micro', 'rising', 'star', 'legend', 'hero']\n      if (!validTiers.includes(tier)) {\n        await interaction.reply({ content: '❌ Invalid tier. Must be one of: micro, rising, star, legend, hero', flags: 64 })\n        return\n      }\n      \n      // Get current scenarios\n      const currentScenarios = await getTierScenarios(tier)\n      \n      // Update with new values\n      if (dailyLimit !== null) currentScenarios.dailyTweetLimit = dailyLimit\n      if (minFollowers !== null) currentScenarios.minFollowers = minFollowers\n      if (bonusMultiplier !== null) currentScenarios.bonusMultiplier = bonusMultiplier\n      \n      // Save scenarios\n      await redis.json.set(`engagement:scenarios:${tier}`, '$', currentScenarios)\n      \n      await interaction.reply({ \n        content: `✅ Updated ${tier.toUpperCase()} tier scenarios:\\n` +\n                 `Daily Limit: ${currentScenarios.dailyTweetLimit}\\n` +\n                 `Min Followers: ${currentScenarios.minFollowers}\\n` +\n                 `Bonus Multiplier: ${currentScenarios.bonusMultiplier}x`,\n        flags: 64 \n      })\n    }\n  }\n  \n  // Handle modal submissions\n  else if (interaction.isModalSubmit()) {\n    if (interaction.customId === 'connect-twitter') {\n      const handle = interaction.fields.getTextInputValue('twitter-handle')\n      const cleanHandle = handle.toLowerCase().replace('@', '').trim()\n      \n      // Check if user is approved\n      const { approved, userData, exists } = await isUserApproved(cleanHandle)\n      \n      // If user doesn't exist, create a new profile (pending approval)\n      if (!exists) {\n        try {\n          const newUser = await createUserProfile(cleanHandle, interaction.user.id)\n          console.log(`✅ Created new profile (pending) for @${cleanHandle}`)\n          \n          await interaction.reply({ \n            content: `📝 Your Twitter account @${cleanHandle} has been registered!\\n\\n` +\n                     `⏳ **Your account is pending approval.** An admin will review and approve your account soon.\\n` +\n                     `📢 You'll be notified once approved and can then use the engagement features.`, \n            flags: 64 \n          })\n          return\n        } catch (error) {\n          console.error('Error creating new user profile:', error)\n          await interaction.reply({ \n            content: '❌ An error occurred while creating your profile. Please try again or contact an admin.', \n            flags: 64 \n          })\n          return\n        }\n      }\n      \n      // If user exists but is not approved\n      if (!approved) {\n        await interaction.reply({ \n          content: '❌ Your Twitter account is pending approval. Please wait for an admin to approve your account.', \n          flags: 64 \n        })\n        return\n      }\n      \n      // Check if handle is already connected\n      const existingDiscordId = await redis.get(`engagement:twitter:${cleanHandle}`)\n      if (existingDiscordId && existingDiscordId !== interaction.user.id) {\n        await interaction.reply({ \n          content: '❌ This Twitter account is already connected to another Discord user.', \n          flags: 64 \n        })\n        return\n      }\n      \n      // Get current role from database\n      const currentRole = userData.role || 'user'\n      \n      // Assign KOL role if user doesn't have a higher role\n      let finalRole = currentRole\n      if (ROLE_HIERARCHY[currentRole] < ROLE_HIERARCHY['kol']) {\n        finalRole = 'kol'\n        await updateUserRole(cleanHandle, 'kol')\n        \n        // Also assign Discord role if available\n        try {\n          const member = await interaction.guild.members.fetch(interaction.user.id)\n          const kolRole = interaction.guild.roles.cache.find(role => role.name.toLowerCase() === KOL_ROLE_NAME)\n          \n          if (kolRole) {\n            // Check if bot has permission to manage roles\n            const botMember = interaction.guild.members.cache.get(client.user.id)\n            if (!botMember.permissions.has('ManageRoles')) {\n              console.warn('⚠️  Bot lacks \"Manage Roles\" permission - cannot assign KOL role')\n              console.log('   Please grant the bot \"Manage Roles\" permission in Discord')\n            } \n            // Check if bot's highest role is above the KOL role\n            else if (botMember.roles.highest.position <= kolRole.position) {\n              console.warn('⚠️  Bot\\'s role is not high enough to assign the KOL role')\n              console.log('   Please move the bot\\'s role above the KOL role in Discord settings')\n            }\n            // Try to assign the role\n            else if (!member.roles.cache.has(kolRole.id)) {\n              await member.roles.add(kolRole)\n              console.log(`✅ Assigned KOL role to ${member.user.tag}`)\n            }\n          } else {\n            console.warn(`⚠️  No role found with name \"${KOL_ROLE_NAME}\" (case-insensitive)`)\n            console.log('   Please create a role named \"kol\" in your Discord server')\n          }\n        } catch (error) {\n          console.error('❌ Error assigning Discord role:', error.message)\n          if (error.code === 50013) {\n            console.log('   This is a permissions issue. Please check:')\n            console.log('   1. Bot has \"Manage Roles\" permission')\n            console.log('   2. Bot\\'s role is above the KOL role in the hierarchy')\n          }\n        }\n      }\n      \n      // Create connection - get tier from user profile\n      const userTier = userData.tier || 'micro'  // Default to micro if no tier\n      const connection = {\n        discordId: interaction.user.id,\n        twitterHandle: cleanHandle,\n        tier: userTier,\n        connectedAt: new Date(),\n        totalPoints: 0,\n        role: finalRole\n      }\n      \n      await redis.json.set(`engagement:connection:${interaction.user.id}`, '$', connection)\n      await redis.set(`engagement:twitter:${cleanHandle}`, interaction.user.id)\n      \n      let message = `✅ Successfully connected Twitter account @${cleanHandle}!`\n      if (finalRole === 'kol' && currentRole !== 'kol') {\n        message += '\\n🎉 You\\'ve been assigned the KOL role!'\n      }\n      \n      await interaction.reply({ \n        content: message, \n        flags: 64 \n      })\n    }\n  }\n})\n\n// Error handling\nclient.on('error', console.error)\n\n// Handle regular messages (for ping/pong)\nclient.on('messageCreate', async (message) => {\n  // Ignore messages from bots\n  if (message.author.bot) return\n  \n  // Simple ping/pong response\n  if (message.content.toLowerCase() === 'ping' || message.content.toLowerCase() === '!ping') {\n    try {\n      await message.reply('pong! 🏓')\n      console.log(`Replied to ping from ${message.author.tag}`)\n    } catch (error) {\n      console.error('Error replying to ping:', error)\n    }\n  }\n})\n\n// Login\nconst botToken = process.env.DISCORD_ENGAGEMENT_BOT_TOKEN || process.env.DISCORD_BOT_TOKEN\nif (!botToken) {\n  console.error('❌ No bot token found! Please set DISCORD_ENGAGEMENT_BOT_TOKEN in your .env.local file')\n  console.error('   You need to create a separate Discord bot for the engagement bot')\n  process.exit(1)\n}\n\nclient.login(botToken)\n  .then(() => console.log('🚀 Engagement bot starting...'))\n  .catch((error) => {\n    console.error('❌ Failed to login:', error)\n    console.error('   Make sure DISCORD_ENGAGEMENT_BOT_TOKEN is set correctly in .env.local')\n  }) "
  }
]